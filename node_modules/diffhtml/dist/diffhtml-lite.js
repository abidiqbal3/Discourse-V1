(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.diff = {}));
}(this, (function (exports) { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var NODE_TYPE = {
    ELEMENT: 1,
    ATTR: 2,
    TEXT: 3,
    COMMENT: 8,
    FRAGMENT: 11
  };
  var EMPTY = {
    STR: '',
    NUM: 1,
    OBJ: {},
    ARR: [],
    MAP: new Map(),
    SET: new Set(),
    DOM: {}
  };
  var PATCH_TYPE = {
    'SET_ATTRIBUTE': 0,
    'REMOVE_ATTRIBUTE': 1,
    'NODE_VALUE': 2,
    'INSERT_BEFORE': 3,
    'REPLACE_CHILD': 4,
    'REMOVE_CHILD': 5
  };
  var TransitionStateNames = ['attached', 'detached', 'replaced', 'attributeChanged', 'textChanged'];
  var TransitionCache = new Map([['attached', new Set()], ['detached', new Set()], ['replaced', new Set()], ['attributeChanged', new Set()], ['textChanged', new Set()]]);
  var StateCache = new Map();
  var NodeCache = new Map();
  var MiddlewareCache = new Set();
  var CreateTreeHookCache = new Set();
  var CreateNodeHookCache = new Set();
  var SyncTreeHookCache = new Set();
  var ReleaseHookCache = new Set();
  var ParseHookCache = new Set();

  var process = {
    env: {
      NODE_ENV: 'production'
    }
  };

  var globalThis = typeof global === 'object' ? global : window || {};

  var parseInt = Number.parseInt;
  var parse = JSON.parse;
  var location = globalThis.location,
      URLSearchParams = globalThis.URLSearchParams;
  var hasSearchParams = typeof URLSearchParams !== 'undefined';
  var hasLocation = typeof location !== 'undefined';
  var useSearchParams = hasSearchParams && hasLocation;
  var useEnv = process.env;
  var globalConfig = {
    collectMetrics: true,
    executeScripts: true
  };

  function formatValue(value, type) {
    var valueAsString = String(value);

    switch (type) {
      case 'boolean':
        {
          return valueAsString !== 'false';
        }

      case 'string':
        {
          return valueAsString;
        }

      case 'number':
        {
          return parseInt(valueAsString, 10);
        }

      case 'array':
        {
          return valueAsString.split(',');
        }

      case 'object':
        {
          return parse(valueAsString);
        }
    }
  }

  function getConfig(name, defaultValue) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : typeof defaultValue;
    var overrides = arguments.length > 3 ? arguments[3] : undefined;

    if (overrides && name in overrides) {
      return overrides[name];
    }

    var keyName = "DIFF_".concat(name.replace(/[^a-zA-Z0-9]/, '')).toLowerCase();

    if (useSearchParams) {
      var searchParams = new URLSearchParams(location.search);

      if (searchParams.has(keyName)) {
        return formatValue(decodeURIComponent(String(searchParams.get(keyName))), type);
      }
    }

    if (useEnv && keyName in process.env) {
      return formatValue(process.env[keyName], type);
    }

    return defaultValue;
  }

  var size = getConfig('initialPoolSize', 5000);
  var free = new Set();
  var allocate = new Set();
  var protect = new Set();

  var shape = function () {
    return {
      rawNodeName: EMPTY.STR,
      nodeName: EMPTY.STR,
      nodeValue: EMPTY.STR,
      nodeType: NODE_TYPE.ELEMENT,
      key: EMPTY.STR,
      childNodes: [],
      attributes: {}
    };
  };

  var memory = {
    free: free,
    allocated: allocate,
    protected: protect
  };
  var freeValues = free.values();
  var Pool = {
    size: size,
    memory: memory,
    fill: function () {
      var _this = this;

      for (var i = free.size; i < this.size; i++) {
        free.add(shape());
      }

      if (this.size < free.size) {
        free.forEach(function (value) {
          if (free.size !== _this.size) {
            free.delete(value);
          }
        });
      }
    },
    get: function () {
      var _freeValues$next = freeValues.next(),
          _freeValues$next$valu = _freeValues$next.value,
          value = _freeValues$next$valu === void 0 ? shape() : _freeValues$next$valu,
          done = _freeValues$next.done;

      if (done) {
        freeValues = free.values();
      }

      free.delete(value);
      allocate.add(value);
      return value;
    },
    protect: function (vTree) {
      allocate.delete(vTree);
      protect.add(vTree);
    },
    unprotect: function (vTree) {
      if (protect.has(vTree)) {
        protect.delete(vTree);
        free.add(vTree);
      } else if (allocate.has(vTree)) {
        allocate.delete(vTree);
        free.add(vTree);
      }
    }
  };
  Pool.fill();

  var isArray = Array.isArray;
  var memory$1 = Pool.memory;
  var fragmentName = '#document-fragment';
  var textName = '#text';
  function createTree(input, attributes, childNodes) {
    var entry = null;

    if (memory$1.protected.has(input) || memory$1.allocated.has(input)) {
      entry = input;
    } else if (!input || isArray(input)) {
        var length = input ? input.length : 0;
        childNodes = [];

        for (var i = 0; i < length; i++) {
          if (!input) continue;
          childNodes.push(input[i]);
        }

        entry = createTree(fragmentName, null, childNodes);
      }

    if (entry) {
      return entry;
    }

    var isObject = typeof input === 'object';
    var inputAsHTMLEl = input;

    if (input && isObject && 'ownerDocument' in inputAsHTMLEl) {
      var nodeType = inputAsHTMLEl.nodeType;

      if (nodeType === NODE_TYPE.TEXT) {
        var vTree = createTree(textName, inputAsHTMLEl.nodeValue);
        NodeCache.set(vTree, inputAsHTMLEl);
        return vTree;
      }

      attributes = {};
      childNodes = [];
      var inputAttrs = inputAsHTMLEl.attributes;

      if (inputAsHTMLEl.nodeType === NODE_TYPE.ELEMENT && inputAttrs && inputAttrs.length) {
        for (var _i = 0; _i < inputAttrs.length; _i++) {
          var _inputAttrs$_i = inputAttrs[_i],
              name = _inputAttrs$_i.name,
              value = _inputAttrs$_i.value;

          if (value === EMPTY.STR && name in inputAsHTMLEl) {
            attributes[name] = input[name];
            continue;
          }

          attributes[name] = value;
        }
      }

      if (inputAsHTMLEl.nodeType === NODE_TYPE.ELEMENT || inputAsHTMLEl.nodeType === NODE_TYPE.FRAGMENT) {
        childNodes = [];

        for (var _i2 = 0; _i2 < inputAsHTMLEl.childNodes.length; _i2++) {
          var childNodeElement = inputAsHTMLEl.childNodes[_i2];
          childNodes.push(createTree(childNodeElement));
        }
      }

      NodeCache.forEach(function (node, vTree) {
        if (node === input) {
          entry = vTree;
        }
      });
      entry = entry || createTree(inputAsHTMLEl.nodeName, attributes, childNodes);
      entry.attributes = _objectSpread2(_objectSpread2({}, entry.attributes), attributes);
      entry.childNodes = childNodes;
      NodeCache.set(entry, inputAsHTMLEl);
      return entry;
    }

    if (isObject) {
      var rawNodeName = input.rawNodeName,
          nodeName = input.nodeName,
          nodeValue = input.nodeValue,
          _attributes = input.attributes,
          _childNodes = input.childNodes,
          children = input.children;
      var treeName = rawNodeName || nodeName;

      var _vTree = createTree(treeName, _attributes || null, children || _childNodes);

      if (nodeValue) {
        _vTree.nodeValue = nodeValue;
      }

      return _vTree;
    }

    for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest[_key - 3] = arguments[_key];
    }

    if (rest.length) {
      childNodes = [childNodes].concat(rest);
    }

    entry = Pool.get();
    var isTextNode = input === textName;
    var isString = typeof input === 'string';

    if (isString) {
      entry.rawNodeName = input;
      entry.nodeName = entry.rawNodeName.toLowerCase();
    } else {
        entry.rawNodeName = input;
        entry.nodeName = fragmentName;
      }

    entry.nodeValue = EMPTY.STR;
    entry.key = EMPTY.STR;
    entry.childNodes.length = 0;
    entry.attributes = {};
    var useAttributes = isArray(attributes) || typeof attributes !== 'object';
    var useNodes = useAttributes ? attributes : childNodes;
    var allNodes = isArray(useNodes) ? useNodes : [useNodes];

    if (isTextNode) {
      var _nodeValue = allNodes.join(EMPTY.STR);

      entry.nodeType = NODE_TYPE.TEXT;
      entry.nodeValue = String(_nodeValue);
      return entry;
    } else if (entry.nodeName === fragmentName) {
      entry.nodeType = NODE_TYPE.FRAGMENT;
    } else if (input === '#comment') {
      entry.nodeType = NODE_TYPE.COMMENT;
    } else {
      entry.nodeType = NODE_TYPE.ELEMENT;
    }

    if (useNodes && allNodes.length && (!attributes || !attributes.childNodes)) {
      for (var _i3 = 0; _i3 < allNodes.length; _i3++) {
        var newNode = allNodes[_i3];

        if (isArray(newNode)) {
          var _entry$childNodes;

          (_entry$childNodes = entry.childNodes).push.apply(_entry$childNodes, _toConsumableArray(newNode));
        } else if (!newNode) {
            continue;
          } else if (newNode.nodeType === NODE_TYPE.FRAGMENT && typeof newNode.rawNodeName === 'string') {
              var _entry$childNodes2;

              (_entry$childNodes2 = entry.childNodes).push.apply(_entry$childNodes2, _toConsumableArray(newNode.childNodes));
            } else if (newNode && typeof newNode === 'object') {
                entry.childNodes.push(createTree(newNode));
              } else {
                  entry.childNodes.push(createTree(textName, null, newNode));
                }
      }
    }

    if (attributes && typeof attributes === 'object' && !isArray(attributes)) {
      entry.attributes = _objectSpread2({}, attributes);

      if (attributes.childNodes) {
        var _isObject = typeof attributes.childNodes === 'object';

        entry.childNodes.push(_isObject ? createTree(attributes.childNodes) : createTree('#text', attributes.childNodes));
      }
    }

    if (entry.nodeName === 'script' && entry.attributes.src) {
      entry.key = String(entry.attributes.src);
    }

    if (entry.attributes && 'key' in entry.attributes) {
      entry.key = String(entry.attributes.key);
    }

    if (CreateTreeHookCache.size) {
      CreateTreeHookCache.forEach(function (fn, retVal) {
        if (retVal = fn(entry)) {
          entry = createTree(retVal);
        }
      });
    }

    return entry;
  }

  var protect$1 = Pool.protect,
      unprotect = Pool.unprotect,
      memory$2 = Pool.memory;
  function protectVTree(vTree) {
    protect$1(vTree);

    if (vTree.childNodes.length) {
      for (var i = 0; i < vTree.childNodes.length; i++) {
        protectVTree(vTree.childNodes[i]);
      }
    }
  }
  function unprotectVTree(vTree) {
    unprotect(vTree);

    if (vTree.childNodes.length) {
      for (var i = 0; i < vTree.childNodes.length; i++) {
        unprotectVTree(vTree.childNodes[i]);
      }
    }

    NodeCache.delete(vTree);
  }
  function gc() {
    memory$2.allocated.forEach(function (vTree) {
      memory$2.free.add(vTree);
      memory$2.allocated.delete(vTree);
      NodeCache.delete(vTree);
    });
  }

  var memory$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    protectVTree: protectVTree,
    unprotectVTree: unprotectVTree,
    gc: gc
  });

  var prefix = 'diffHTML';
  var marks = new Map();

  var nop = function () {};

  var count = 0;
  function makeMeasure(transaction) {
    var mount = transaction.mount,
        input = transaction.input;
    var inputAsVTree = input;
    var id = count++;

    if (!getConfig('collectMetrics', false)) {
      return nop;
    }

    return function (name) {
      name = "[".concat(id, "] ").concat(name);
      var host = mount.host;

      if (mount && host) {
        name = "".concat(host.constructor.name, " ").concat(name);
      } else if (inputAsVTree && typeof inputAsVTree.rawNodeName === 'function') {
          name = "".concat(inputAsVTree.rawNodeName.name, " ").concat(name);
        }

      var endName = "".concat(name, "-end");

      if (marks.has(name)) {
        var prevMark = marks.get(name) || 0;
        var totalMs = (performance.now() - prevMark).toFixed(3);
        marks.delete(name);
        performance.mark(endName);
        performance.measure("".concat(prefix, " ").concat(name, " (").concat(totalMs, "ms)"), name, endName);
      } else {
        marks.set(name, performance.now());
        performance.mark(name);
      }
    };
  }

  function schedule(transaction) {
    var state = transaction.state,
        isRendering = transaction.state.isRendering;
    state.measure('schedule');
    StateCache.forEach(function (val) {
      var oldMount = val.activeTransaction && val.activeTransaction.mount;
      var newMount = transaction.mount;

      if (!oldMount || !newMount || !val.isRendering) {
        return;
      } else if (oldMount.contains && oldMount.contains(newMount) || newMount.contains && newMount.contains(oldMount)) {
          state = val;
          isRendering = true;
        } else if (oldMount === newMount) {
            state = val;
            isRendering = true;
          }
    });
    var _state = state,
        activeTransaction = _state.activeTransaction,
        nextTransaction = _state.nextTransaction;

    if (isRendering) {
      var tasks = transaction.tasks;
      state.nextTransaction = transaction;
      transaction.abort();
      var promise = nextTransaction && nextTransaction.promise || activeTransaction.promise || Promise.resolve();
      return transaction.promise = promise.then(function () {
        transaction.aborted = false;
        transaction.state.isRendering = true;
        transaction.state.activeTransaction = transaction;
        state.measure('schedule');
        return Transaction.flow(transaction, tasks.slice(1));
      });
    }

    state.isRendering = true;
    state.activeTransaction = transaction;
    state.measure('schedule');
  }

  function shouldUpdate(transaction) {
    var mount = transaction.mount,
        input = transaction.input,
        measure = transaction.state.measure,
        options = transaction.config;
    var prop = options.inner ? 'innerHTML' : 'outerHTML';
    measure('should update');
    var mountAsHTMLEl = mount;

    if (typeof input === 'string' && mountAsHTMLEl[prop] === input) {
      return transaction.abort(true);
    }

    measure('should update');
  }

  function release(mount) {
    if (StateCache.has(mount)) {
      var _StateCache$get = StateCache.get(mount),
          mutationObserver = _StateCache$get.mutationObserver,
          oldTree = _StateCache$get.oldTree;

      mutationObserver && mutationObserver.disconnect();
      StateCache.delete(mount);

      if (oldTree && !NodeCache.has(oldTree)) {
        ReleaseHookCache.forEach(function (fn) {
          return fn(oldTree);
        });
        unprotectVTree(oldTree);
      }
    }

    if (!mount) {
      return;
    }

    var asHTMLElement = mount;

    if (asHTMLElement.childNodes && asHTMLElement.childNodes.length) {
      for (var i = 0; i < asHTMLElement.childNodes.length; i++) {
        release(asHTMLElement.childNodes[i]);
      }
    }

    if (asHTMLElement.shadowRoot) {
      release(asHTMLElement.shadowRoot);
    }

    NodeCache.forEach(function (domNode, vTree) {
      if (domNode === asHTMLElement) {
        ReleaseHookCache.forEach(function (fn) {
          return fn(vTree);
        });
        unprotectVTree(vTree);
      }
    });
  }

  function reconcileTrees(transaction) {
    var state = transaction.state,
        mount = transaction.mount,
        input = transaction.input,
        options = transaction.config;
    var inner = options.inner;
    var mountAsHTMLEl = mount;
    var outerHTML = mountAsHTMLEl.outerHTML;

    if (state.mutationObserver && !state.isDirty) {
      state.isDirty = Boolean(state.mutationObserver.takeRecords().length);
    }

    if (state.previousMarkup !== outerHTML) {
      state.isDirty = true;
    }

    if (state.isDirty || !state.oldTree || !outerHTML) {
      release(mount);
      state.oldTree = createTree(mountAsHTMLEl);
      protectVTree(state.oldTree);
      StateCache.set(mount, state);
    }

    var _state$oldTree = state.oldTree,
        nodeName = _state$oldTree.nodeName,
        attributes = _state$oldTree.attributes;
    var inputAsVTree = input;

    if (!inner && inputAsVTree.nodeType === NODE_TYPE.FRAGMENT && state.oldTree.nodeType !== NODE_TYPE.FRAGMENT) {
      var foundElements = [];
      inputAsVTree.childNodes.forEach(function (value) {
        var isText = value.nodeType === NODE_TYPE.TEXT;

        if (!isText || value.nodeValue.trim()) {
          foundElements.push(value);
        }
      });

      if (foundElements.length === 1) {
        transaction.newTree = foundElements[0];
      } else if (foundElements.length > 1) {
          transaction.newTree = createTree(inputAsVTree.childNodes);
        }
    }

    if (!transaction.newTree) {
      transaction.newTree = createTree(input);
    }

    transaction.oldTree = state.oldTree;
    var oldTree = transaction.oldTree,
        newTree = transaction.newTree;

    if (inner && oldTree && newTree) {
      var isUnknown = typeof newTree.rawNodeName !== 'string';
      var isFragment = newTree.nodeType === NODE_TYPE.FRAGMENT;
      var children = isFragment && !isUnknown ? newTree.childNodes : newTree;
      transaction.newTree = createTree(nodeName, attributes, children);
    }
  }

  var max = Math.max;
  var keyNames = ['old', 'new'];
  var textName$1 = '#text';
  function syncTree(oldTree, newTree) {
    var patches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var attributesOnly = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    if (!oldTree) oldTree = EMPTY.OBJ;
    if (!newTree) newTree = EMPTY.OBJ;
    var _state$svgElements = state.svgElements,
        svgElements = _state$svgElements === void 0 ? new Set() : _state$svgElements;
    var oldNodeName = oldTree.nodeName;
    var newNodeName = newTree.nodeName;
    var isEmpty = oldTree === EMPTY.OBJ || attributesOnly;
    var isSVG = newNodeName === 'svg' || svgElements.has(newTree);
    var shortCircuit = null;

    if (SyncTreeHookCache.size) {
      SyncTreeHookCache.forEach(function (fn) {
        var entry = fn(oldTree, newTree);

        if (entry && entry === oldTree) {
          shortCircuit = patches;
        } else if (entry === false) {
            shortCircuit = false;
          } else if (entry) {
              newTree = entry;
            }
      });
    }

    if (shortCircuit !== null || !newTree) {
      return shortCircuit;
    }

    if (newNodeName === textName$1) {
      if (oldNodeName === textName$1 && oldTree.nodeValue !== newTree.nodeValue) {
        patches.push(PATCH_TYPE.NODE_VALUE, oldTree, newTree.nodeValue, oldTree.nodeValue);
        oldTree.nodeValue = newTree.nodeValue;
        return patches;
      } else if (isEmpty) {
          patches.push(PATCH_TYPE.NODE_VALUE, newTree, newTree.nodeValue, null);
          return patches;
        }
    }

    var newChildNodes = newTree.childNodes || [];

    if (newTree.nodeType === NODE_TYPE.ELEMENT) {
      var oldAttributes = isEmpty ? EMPTY.OBJ : oldTree.attributes;
      var newAttributes = newTree.attributes || {};

      for (var key in newAttributes) {
        var value = newAttributes[key];

        if (key in oldAttributes && oldAttributes[key] === newAttributes[key]) {
          continue;
        }

        if (!isEmpty) {
          oldAttributes[key] = value;
        }

        if ((!oldTree || oldTree.nodeName !== 'script') && newTree.nodeName === 'script' && key === 'type') {
          continue;
        }

        patches.push(PATCH_TYPE.SET_ATTRIBUTE, isEmpty ? newTree : oldTree, key, value);
      }

      if (!isEmpty) {
        for (var _key in oldAttributes) {
          if (_key in newAttributes) {
            continue;
          }

          patches.push(PATCH_TYPE.REMOVE_ATTRIBUTE, oldTree, _key);
          delete oldAttributes[_key];
        }
      }
    }

    if (attributesOnly) {
      for (var i = 0; i < newChildNodes.length; i++) {
        isSVG && svgElements.add(newChildNodes[i]);
        syncTree(null, newChildNodes[i], patches, state, true);
      }

      return patches;
    }

    var keysLookup = {
      old: new Map(),
      new: new Map()
    };

    for (var _i = 0; _i < keyNames.length; _i++) {
      var keyName = keyNames[_i];
      var map = keysLookup[keyName];
      var vTree = arguments[_i];
      var nodes = vTree && vTree.childNodes;

      if (nodes && nodes.length) {
        for (var _i2 = 0; _i2 < nodes.length; _i2++) {
          var _vTree = nodes[_i2];

          if (_vTree.key) {

            map.set(_vTree.key, _vTree);
          }
        }
      }
    }

    var oldChildNodes = oldTree.childNodes;
    var maxLength = max(newChildNodes.length, oldChildNodes.length);

    for (var _i3 = 0; _i3 < maxLength; _i3++) {
      var oldChildNode = oldChildNodes && oldChildNodes[_i3];
      var newChildNode = newChildNodes[_i3];

      if (isSVG || newChildNode && newChildNode.nodeName === 'svg') {
        svgElements.add(newChildNode);
      }

      if (!newChildNode) {
        if (syncTree(oldChildNode, null, patches, state, true) === false) {
          newChildNodes.splice(_i3, 0, oldChildNode);
        }

        continue;
      }

      if (!oldChildNode) {
        oldChildNodes.push(newChildNode);
        syncTree(null, newChildNode, patches, state, true);
        patches.push(PATCH_TYPE.INSERT_BEFORE, oldTree, newChildNode, null);
        continue;
      }

      var newKey = newChildNode.key;
      var oldKey = oldChildNode.key;
      var oldInNew = keysLookup.new.has(oldKey);
      var newInOld = keysLookup.old.has(newKey);

      if (oldKey || newKey) {
        if (!oldInNew && !newInOld) {
          oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode), 1, newChildNode);
          syncTree(null, newChildNode, patches, state, true);
          patches.push(PATCH_TYPE.REPLACE_CHILD, newChildNode, oldChildNode);
          _i3 = _i3 - 1;
          continue;
        } else if (!oldInNew) {
          patches.push(PATCH_TYPE.REMOVE_CHILD, oldChildNode);
          oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode), 1);
          _i3 = _i3 - 1;
          continue;
        }

        if (newKey !== oldKey) {
          var optimalNewNode = newChildNode;

          if (newKey && newInOld) {
            optimalNewNode = keysLookup.old.get(newKey);
            oldChildNodes.splice(oldChildNodes.indexOf(optimalNewNode), 1);
          } else {
            optimalNewNode = newChildNode;
          }

          syncTree(null, optimalNewNode, patches, state, true);
          patches.push(PATCH_TYPE.INSERT_BEFORE, oldTree, optimalNewNode, oldChildNode);
          oldChildNodes.splice(_i3, 0, optimalNewNode);
          continue;
        }
      }

      var sameType = oldChildNode.nodeName === newChildNode.nodeName;
      var retVal = syncTree(oldChildNode, newChildNode, patches, state, !sameType);

      if (retVal === false) {
        newChildNodes.splice(_i3, 0, oldChildNode);
        maxLength += 1;
        continue;
      }

      if (!sameType) {
        oldChildNodes[_i3] = newChildNode;
        var lookupIndex = oldChildNodes.lastIndexOf(newChildNode);

        if (lookupIndex > _i3) {
          oldChildNodes.splice(lookupIndex, 1);
        }

        patches.push(PATCH_TYPE.REPLACE_CHILD, newChildNode, oldChildNode);
      }
    }

    if (oldChildNodes.length !== newChildNodes.length) {
      for (var _i4 = newChildNodes.length; _i4 < oldChildNodes.length; _i4++) {
        patches.push(PATCH_TYPE.REMOVE_CHILD, oldChildNodes[_i4]);
      }

      oldChildNodes.length = newChildNodes.length;
    }

    return patches;
  }

  var namespace = 'http://www.w3.org/2000/svg';
  function createNode(vTreeLike) {
    var ownerDocument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : globalThis.document;
    var isSVG = arguments.length > 2 ? arguments[2] : undefined;

    var vTree = createTree(vTreeLike);
    var existingNode = NodeCache.get(vTree);

    if (existingNode) {
      return existingNode;
    }

    var nodeName = vTree.nodeName,
        _vTree$rawNodeName = vTree.rawNodeName,
        rawNodeName = _vTree$rawNodeName === void 0 ? nodeName : _vTree$rawNodeName,
        _vTree$childNodes = vTree.childNodes,
        childNodes = _vTree$childNodes === void 0 ? [] : _vTree$childNodes;
    isSVG = isSVG || nodeName === 'svg';
    var domNode = null;
    var retVal = null;
    CreateNodeHookCache.forEach(function (fn) {
      if (retVal = fn(vTree)) {
        domNode = retVal;
      }
    });

    if (!ownerDocument) {
      return domNode;
    }

    if (domNode === null) {
      if (nodeName === '#text') {
        domNode = ownerDocument.createTextNode(vTree.nodeValue || EMPTY.STR);
      } else if (nodeName === '#document-fragment') {
          domNode = ownerDocument.createDocumentFragment();
        } else if (isSVG) {
            domNode = ownerDocument.createElementNS(namespace, rawNodeName);
          } else {
              domNode = ownerDocument.createElement(rawNodeName);
            }

      if (nodeName === 'script') {
        domNode.type = 'no-execute';
      }
    }

    var validNode = domNode;
    NodeCache.set(vTree, validNode);

    for (var i = 0; i < childNodes.length; i++) {
      var validChildNode = createNode(childNodes[i], ownerDocument, isSVG);
      validNode.appendChild(validChildNode);
    }

    return validNode;
  }

  function syncTrees(transaction) {
    var state = transaction.state,
        measure = transaction.state.measure,
        oldTree = transaction.oldTree,
        newTree = transaction.newTree,
        mount = transaction.mount;
    measure('sync trees');

    if (oldTree && newTree && oldTree.nodeName !== newTree.nodeName && newTree.nodeType !== NODE_TYPE.FRAGMENT) {

      transaction.patches = [PATCH_TYPE.REPLACE_CHILD, newTree, oldTree];
      transaction.oldTree = state.oldTree = newTree;
      var newNode = createNode(newTree);
      StateCache.delete(mount);
      StateCache.set(newNode, state);
      transaction.mount = newNode;

      if (newTree.nodeName === 'script') {
        state.scriptsToExecute.set(newTree, newTree.attributes.type || EMPTY.STR);
      }
    } else {
        transaction.patches = syncTree(oldTree || null, newTree || null, [], state);
      }

    measure('sync trees');
  }

  function addTransitionState(stateName, callback) {
    var _TransitionCache$get;

    (_TransitionCache$get = TransitionCache.get(stateName)) === null || _TransitionCache$get === void 0 ? void 0 : _TransitionCache$get.add(callback);
  }
  function removeTransitionState(stateName, callback) {

    if (!callback && stateName) {
      var _TransitionCache$get2;

      (_TransitionCache$get2 = TransitionCache.get(stateName)) === null || _TransitionCache$get2 === void 0 ? void 0 : _TransitionCache$get2.clear();
    } else if (stateName && callback) {
        var _TransitionCache$get3;

        (_TransitionCache$get3 = TransitionCache.get(stateName)) === null || _TransitionCache$get3 === void 0 ? void 0 : _TransitionCache$get3.delete(callback);
      } else {
          for (var i = 0; i < TransitionStateNames.length; i++) {
            var _TransitionCache$get4;

            (_TransitionCache$get4 = TransitionCache.get(TransitionStateNames[i])) === null || _TransitionCache$get4 === void 0 ? void 0 : _TransitionCache$get4.clear();
          }
        }
  }
  function runTransitions(setName) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var set = TransitionCache.get(setName);
    var promises = [];

    if (!set) {
      return promises;
    }

    var vTree = args[0];
    var isElement = vTree.nodeType === NODE_TYPE.ELEMENT;

    if (!set.size || setName !== 'textChanged' && !isElement) {
      return promises;
    }

    set.forEach(function (callback) {
      var nodes = args.map(function (x) {
        return NodeCache.get(x) || x;
      });
      var retVal = callback.apply(void 0, _toConsumableArray(nodes));

      if (typeof retVal === 'object' && retVal.then) {
        promises.push(retVal);
      }
    });

    if (setName === 'attached' || setName === 'detached') {
      vTree.childNodes.forEach(function (childTree) {
        promises.push.apply(promises, _toConsumableArray(runTransitions.apply(void 0, [setName, childTree].concat(_toConsumableArray(args.slice(1))))));
      });
    }

    return promises;
  }

  var element = globalThis.document ? document.createElement('div') : null;
  function decodeEntities(string) {
    if (!element || !string || !string.indexOf || !string.includes('&')) {
      return string;
    }

    element.innerHTML = string;
    return element.textContent || EMPTY.STR;
  }

  var keys = Object.keys;
  var blocklist = new Set();
  var allowlist = new Set();
  var DIRECT = ['class', 'checked', 'disabled', 'selected'];

  var setAttribute = function (vTree, domNode, name, value) {
    var isObject = typeof value === 'object' && value;
    var isFunction = typeof value === 'function';
    var isSymbol = typeof value === 'symbol';
    var isEvent = name.indexOf('on') === 0;
    var lowerName = isEvent ? name.toLowerCase() : name;
    var blocklistName = vTree.nodeName + '-' + lowerName;
    var htmlElement = domNode;

    if (allowlist.has(blocklistName)) {
      domNode[lowerName] = value;
    } else if (!blocklist.has(blocklistName)) {
      try {
        domNode[lowerName] = value;
        allowlist.add(blocklistName);
      } catch (unhandledException) {
        blocklist.add(blocklistName);
      }
    }

    if (!isObject && !isFunction && !isSymbol) {
      var noValue = value === null || value === undefined;

      if (lowerName) {
        htmlElement.setAttribute(lowerName, noValue ? EMPTY.STR : value);
      }
    } else if (isObject && lowerName === 'style') {
        var valueKeys = keys(value);

        for (var i = 0; i < valueKeys.length; i++) {
          htmlElement.style[valueKeys[i]] = value[valueKeys[i]];
        }
      }
  };

  var removeAttribute = function (domNode, name) {
    var isEvent = name.indexOf('on') === 0;
    domNode.removeAttribute(name);
    var blocklistName = domNode.nodeName + '-' + name;

    if (allowlist.has(blocklistName)) {
      var anyNode = domNode;

      if (isEvent) {
        anyNode[name] = undefined;
      } else {
        delete anyNode[name];
      }

      if (DIRECT.includes(name)) {
        domNode[name] = false;
      }
    } else if (!blocklist.has(blocklistName)) {
      try {
        var _anyNode = domNode;

        if (isEvent) {
          _anyNode[name] = undefined;
        } else {
          delete _anyNode[name];
        }

        if (DIRECT.includes(name)) {
          domNode[name] = false;
        }

        allowlist.add(blocklistName);
      } catch (unhandledException) {
        blocklist.add(blocklistName);
      }
    }
  };

  var changeNodeValue = function (domNode, nodeValue) {
    var htmlElement = domNode;

    if (nodeValue.includes('&')) {
      htmlElement.nodeValue = decodeEntities(nodeValue);
    } else {
      htmlElement.nodeValue = nodeValue;
    }
  };

  function patchNode(patches) {
    var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY.OBJ;
    var promises = [];
    var ownerDocument = state.ownerDocument,
        _state$svgElements = state.svgElements,
        svgElements = _state$svgElements === void 0 ? new Set() : _state$svgElements;
    var length = patches.length;
    var i = 0;

    while (true) {
      var patchType = patches[i];

      if (i === length) {
        break;
      }

      switch (patchType) {
        case PATCH_TYPE.SET_ATTRIBUTE:
          {
            var _ret = function () {
              var vTree = patches[i + 1];
              var name = patches[i + 2];
              var value = decodeEntities(patches[i + 3]);
              i += 4;
              var isSVG = svgElements.has(vTree);
              var domNode = createNode(vTree, ownerDocument, isSVG);

              if (!domNode) {
                return "break";
              }

              var oldValue = domNode.getAttribute(name);
              var attributeChangedPromises = runTransitions('attributeChanged', vTree, name, oldValue, value);
              protectVTree(vTree);

              if (attributeChangedPromises.length) {
                Promise.all(attributeChangedPromises).then(function () {
                  return setAttribute(vTree, domNode, name, value);
                });
                promises.push.apply(promises, _toConsumableArray(attributeChangedPromises));
              } else {
                setAttribute(vTree, domNode, name, value);
              }

              return "break";
            }();

            if (_ret === "break") break;
          }

        case PATCH_TYPE.REMOVE_ATTRIBUTE:
          {
            var _ret2 = function () {
              var vTree = patches[i + 1];
              var name = patches[i + 2];
              i += 3;
              var isSVG = svgElements.has(vTree);
              var domNode = createNode(vTree, ownerDocument, isSVG);

              if (!domNode) {
                return "break";
              }

              var oldValue = domNode.getAttribute(name);
              var attributeChangedPromises = runTransitions('attributeChanged', vTree, name, oldValue, null);
              protectVTree(vTree);

              if (attributeChangedPromises.length) {
                Promise.all(attributeChangedPromises).then(function () {
                  return removeAttribute(domNode, name);
                });
                promises.push.apply(promises, _toConsumableArray(attributeChangedPromises));
              } else {
                removeAttribute(domNode, name);
              }

              return "break";
            }();

            if (_ret2 === "break") break;
          }

        case PATCH_TYPE.NODE_VALUE:
          {
            var _ret3 = function () {
              var vTree = patches[i + 1];
              var nodeValue = patches[i + 2];
              var oldValue = patches[i + 3];
              var isSVG = svgElements.has(vTree);
              i += 4;
              var domNode = createNode(vTree, ownerDocument, isSVG);

              if (!domNode) {
                return "break";
              }

              protectVTree(vTree);
              var textChangedPromises = runTransitions('textChanged', vTree, oldValue, nodeValue);

              if (textChangedPromises.length) {
                Promise.all(textChangedPromises).then(function () {
                  return changeNodeValue(domNode, nodeValue);
                });
                promises.push.apply(promises, _toConsumableArray(textChangedPromises));
              } else {
                changeNodeValue(domNode, nodeValue);
              }

              return "break";
            }();

            if (_ret3 === "break") break;
          }

        case PATCH_TYPE.INSERT_BEFORE:
          {
            var vTree = patches[i + 1];
            var newTree = patches[i + 2];
            var refTree = patches[i + 3];
            i += 4;
            var domNode = NodeCache.get(vTree);

            if (!domNode) {
              break;
            }

            var isSVG = svgElements.has(newTree);
            protectVTree(newTree);
            var refNode = refTree && createNode(refTree, ownerDocument, isSVG);
            var newNode = createNode(newTree, ownerDocument, isSVG);
            domNode.insertBefore(newNode, refNode || null);
            promises.push.apply(promises, _toConsumableArray(runTransitions('attached', newTree)));
            break;
          }

        case PATCH_TYPE.REPLACE_CHILD:
          {
            var _ret4 = function () {
              var _TransitionCache$get, _TransitionCache$get2, _TransitionCache$get3;

              var newTree = patches[i + 1];
              var oldTree = patches[i + 2];
              i += 3;
              var isSVG = svgElements.has(newTree);
              var oldDomNode = NodeCache.get(oldTree);
              var newDomNode = createNode(newTree, ownerDocument, isSVG);

              if (!oldDomNode || !oldDomNode.parentNode) {
                return "break";
              }

              protectVTree(newTree);
              var hasAttached = (_TransitionCache$get = TransitionCache.get('attached')) === null || _TransitionCache$get === void 0 ? void 0 : _TransitionCache$get.size;
              var hasDetached = (_TransitionCache$get2 = TransitionCache.get('detached')) === null || _TransitionCache$get2 === void 0 ? void 0 : _TransitionCache$get2.size;
              var hasReplaced = (_TransitionCache$get3 = TransitionCache.get('replaced')) === null || _TransitionCache$get3 === void 0 ? void 0 : _TransitionCache$get3.size;

              if (!hasAttached && !hasDetached && !hasReplaced) {
                if (oldDomNode.parentNode) {
                  oldDomNode.parentNode.replaceChild(newDomNode, oldDomNode);
                  unprotectVTree(oldTree);
                }

                return "break";
              }

              if (oldDomNode.parentNode) {
                oldDomNode.parentNode.insertBefore(newDomNode, oldDomNode);
              }

              var allPromises = [].concat(_toConsumableArray(hasAttached && runTransitions('attached', newTree) || EMPTY.ARR), _toConsumableArray(hasDetached && runTransitions('detached', oldTree) || EMPTY.ARR), _toConsumableArray(hasReplaced && runTransitions('replaced', oldTree, newTree) || EMPTY.ARR));

              if (allPromises.length) {
                Promise.all(allPromises).then(function () {
                  if (oldDomNode.parentNode) {
                    oldDomNode.parentNode.removeChild(oldDomNode);
                  }

                  unprotectVTree(oldTree);
                });
                promises.push.apply(promises, _toConsumableArray(allPromises));
              } else {
                if (oldDomNode.parentNode) {
                  oldDomNode.parentNode.removeChild(oldDomNode);
                }

                unprotectVTree(oldTree);
              }

              return "break";
            }();

            if (_ret4 === "break") break;
          }

        case PATCH_TYPE.REMOVE_CHILD:
          {
            var _ret5 = function () {
              var vTree = patches[i + 1];
              i += 2;
              var domNode = NodeCache.get(vTree);

              if (!domNode || !domNode.parentNode) {
                return "break";
              }

              var detachedPromises = runTransitions('detached', vTree);

              if (detachedPromises.length) {
                Promise.all(detachedPromises).then(function () {
                  if (domNode.parentNode) {
                    domNode.parentNode.removeChild(domNode);
                  }

                  unprotectVTree(vTree);
                });
                promises.push.apply(promises, _toConsumableArray(detachedPromises));
              } else {
                if (domNode.parentNode) {
                  domNode.parentNode.removeChild(domNode);
                }

                unprotectVTree(vTree);
              }

              return "break";
            }();

            if (_ret5 === "break") break;
          }
      }
    }

    return promises;
  }

  function patch(transaction) {
    var mount = transaction.mount,
        state = transaction.state,
        patches = transaction.patches;
    var mutationObserver = state.mutationObserver,
        measure = state.measure,
        scriptsToExecute = state.scriptsToExecute;
    measure('patch node');
    var ownerDocument = mount.ownerDocument;
    var promises = transaction.promises || [];
    state.ownerDocument = ownerDocument || globalThis.document;

    if (mutationObserver) {
      mutationObserver.disconnect();
    }

    var collectScripts = function (vTree) {
      if (vTree.nodeName === 'script') {
        scriptsToExecute.set(vTree, vTree.attributes.type);
      }
    };

    CreateNodeHookCache.add(collectScripts);

    if (state.ownerDocument) {
      promises.push.apply(promises, _toConsumableArray(patchNode(patches, state)));
    }

    CreateNodeHookCache.delete(collectScripts);
    transaction.promises = promises;
    measure('patch node');
  }

  function endAsPromise(transaction) {
    var promises = transaction.promises;

    if (promises && promises.length) {
      return transaction.promise = Promise.all(promises).then(function () {
        return transaction.end();
      });
    }

    return transaction.promise = Promise.resolve(transaction.end());
  }

  var defaultTasks = [schedule, shouldUpdate, reconcileTrees, syncTrees, patch, endAsPromise];
  var tasks = {
    schedule: schedule,
    shouldUpdate: shouldUpdate,
    reconcileTrees: reconcileTrees,
    syncTrees: syncTrees,
    patchNode: patch,
    endAsPromise: endAsPromise
  };

  var Transaction = function () {
    function Transaction(mount, input, config) {
      var _this = this;

      _classCallCheck(this, Transaction);

      _defineProperty(this, "state", EMPTY.OBJ);

      _defineProperty(this, "mount", EMPTY.OBJ);

      _defineProperty(this, "input", EMPTY.OBJ);

      _defineProperty(this, "oldTree", undefined);

      _defineProperty(this, "newTree", undefined);

      _defineProperty(this, "promise", undefined);

      _defineProperty(this, "promises", undefined);

      _defineProperty(this, "tasks", []);

      _defineProperty(this, "patches", []);

      this.mount = mount;
      this.input = input;
      this.config = config;

      var isDirtyCheck = function () {
        return _this.state.isDirty = true;
      };

      var hasObserver = ('MutationObserver' in (globalThis.window || EMPTY.OBJ));
      this.state = StateCache.get(mount) || {
        measure: makeMeasure(this),
        svgElements: new Set(),
        scriptsToExecute: new Map(),
        activeTransaction: this,
        mutationObserver: hasObserver && new globalThis.window.MutationObserver(isDirtyCheck)
      };
      this.tasks = getConfig('tasks', defaultTasks, undefined, config).slice();
      this.endedCallbacks = new Set();
      StateCache.set(mount, this.state);
    }

    _createClass(Transaction, [{
      key: "start",
      value: function start() {

        var measure = this.state.measure,
            tasks = this.tasks;
        var takeLastTask = tasks.pop();
        measure('render');
        this.aborted = false;
        Transaction.invokeMiddleware(this);
        takeLastTask && tasks.push(takeLastTask);
        return Transaction.flow(this, tasks);
      }
    }, {
      key: "abort",
      value: function abort(isReturn) {
        this.aborted = true;

        if (isReturn) {
          return this.tasks[this.tasks.length - 1](this);
        }
      }
    }, {
      key: "end",
      value: function end() {
        var _this2 = this;

        var state = this.state,
            config = this.config,
            mount = this.mount;
        var mutationObserver = state.mutationObserver,
            measure = state.measure,
            svgElements = state.svgElements,
            scriptsToExecute = state.scriptsToExecute;
        var mountAsHTMLEl = mount;
        measure('finalize');
        this.completed = true;
        svgElements.clear();
        state.isRendering = false;
        state.isDirty = false;

        if (mountAsHTMLEl.ownerDocument && mutationObserver) {
          mutationObserver.observe(mountAsHTMLEl, {
            subtree: true,
            childList: true,
            attributes: true,
            characterData: true
          });
        } else {
            state.isDirty = true;
          }

        scriptsToExecute.forEach(function () {
          var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY.STR;
          var vTree = arguments.length > 1 ? arguments[1] : undefined;
          var oldNode = NodeCache.get(vTree);
          if (type) oldNode.setAttribute('type', type);else oldNode.removeAttribute('type');
        });
        state.previousMarkup = 'outerHTML' in mountAsHTMLEl ? mountAsHTMLEl.outerHTML : EMPTY.STR;

        if (config.executeScripts) {
          scriptsToExecute.forEach(function (_, vTree) {
            var oldNode = NodeCache.get(vTree);
            var newNode = oldNode.cloneNode(true);

            if (!oldNode) {
              return;
            }

            if (StateCache.has(oldNode)) {
              release(oldNode);
              StateCache.set(newNode, state);
            }

            NodeCache.set(vTree, newNode);
            oldNode.parentNode && oldNode.parentNode.replaceChild(newNode, oldNode);
          });
        }

        scriptsToExecute.clear();

        if (Pool.memory.free.size < Pool.memory.allocated.size * 2) {
          gc();
        }

        this.endedCallbacks.forEach(function (callback) {
          return callback(_this2);
        });
        this.endedCallbacks.clear();
        measure('finalize');
        measure('render');
        return this;
      }
    }, {
      key: "onceEnded",
      value: function onceEnded(callback) {
        this.endedCallbacks.add(callback);
      }
    }], [{
      key: "create",
      value: function create(mount, input, options) {
        return new Transaction(mount, input, options);
      }
    }, {
      key: "flow",
      value: function flow(transaction, tasks) {
        var retVal = transaction;

        for (var i = 0; i < tasks.length; i++) {
          if (transaction.aborted) {
            return retVal;
          }

          retVal = tasks[i](transaction);

          if (retVal !== undefined && retVal !== transaction) {
            return retVal;
          }
        }

        return retVal;
      }
    }, {
      key: "assert",
      value: function assert(transaction) {
      }
    }, {
      key: "invokeMiddleware",
      value: function invokeMiddleware(transaction) {
        var measure = transaction.state.measure,
            tasks = transaction.tasks;
        MiddlewareCache.forEach(function (fn) {
          var label = "invoke ".concat(fn.name || 'anon');
          measure(label);
          var result = fn(transaction);

          if (result) {
            tasks.push(result);
          }

          measure(label);
        });
      }
    }]);

    return Transaction;
  }();

  function escape(unescaped) {
    return unescaped.replace(/[&<>]/g, function (match) {
      return "&#".concat(match.charCodeAt(0), ";");
    });
  }

  var caches = {
    StateCache: StateCache,
    NodeCache: NodeCache,
    TransitionCache: TransitionCache,
    MiddlewareCache: MiddlewareCache,
    CreateTreeHookCache: CreateTreeHookCache,
    CreateNodeHookCache: CreateNodeHookCache,
    SyncTreeHookCache: SyncTreeHookCache,
    ReleaseHookCache: ReleaseHookCache,
    ParseHookCache: ParseHookCache
  };
  var internals = _objectSpread2({
    decodeEntities: decodeEntities,
    escape: escape,
    makeMeasure: makeMeasure,
    memory: memory$3,
    Pool: Pool,
    process: process,
    PATCH_TYPE: PATCH_TYPE,
    globalConfig: globalConfig,
    createNode: createNode,
    syncTree: syncTree,
    Transaction: Transaction,
    defaultTasks: defaultTasks,
    tasks: tasks
  }, caches);

  var $$diffHTML = Symbol.for('diffHTML');

  function innerHTML(mount) {
    var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY.STR;
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    config.inner = true;
    config.executeScripts = 'executeScripts' in config ? config.executeScripts : true;
    config.tasks = config.tasks || defaultTasks;
    return Transaction.create(mount, input, config).start();
  }

  function outerHTML(mount) {
    var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY.STR;
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    config.inner = false;
    config.executeScripts = 'executeScripts' in config ? config.executeScripts : true;
    config.tasks = config.tasks || defaultTasks;
    return Transaction.create(mount, input, config).start();
  }

  function use(middleware) {
    var isFunction = typeof middleware === 'function';

    var subscribe = middleware.subscribe,
        unsubscribe = middleware.unsubscribe,
        createTreeHook = middleware.createTreeHook,
        createNodeHook = middleware.createNodeHook,
        syncTreeHook = middleware.syncTreeHook,
        releaseHook = middleware.releaseHook,
        parseHook = middleware.parseHook;
    isFunction && MiddlewareCache.add(middleware);
    subscribe && subscribe(internals);
    createTreeHook && CreateTreeHookCache.add(createTreeHook);
    createNodeHook && CreateNodeHookCache.add(createNodeHook);
    syncTreeHook && SyncTreeHookCache.add(syncTreeHook);
    releaseHook && ReleaseHookCache.add(releaseHook);
    parseHook && ParseHookCache.add(parseHook);
    return function () {
      isFunction && MiddlewareCache.delete(middleware);
      unsubscribe && unsubscribe(internals);
      createTreeHook && CreateTreeHookCache.delete(createTreeHook);
      createNodeHook && CreateNodeHookCache.delete(createNodeHook);
      syncTreeHook && SyncTreeHookCache.delete(syncTreeHook);
      releaseHook && ReleaseHookCache.delete(releaseHook);
      parseHook && ParseHookCache.delete(parseHook);
    };
  }

  var __VERSION__ = '1.0.0-beta.20';

  var assign = Object.assign;
  var VERSION = "".concat(__VERSION__, "-lite");
  assign(internals, {
    VERSION: VERSION
  });
  var api = {};
  api.VERSION = VERSION;
  api.addTransitionState = addTransitionState;
  api.removeTransitionState = removeTransitionState;
  api.release = release;
  api.createTree = createTree;
  api.use = use;
  api.outerHTML = outerHTML;
  api.innerHTML = innerHTML;
  api.html = createTree;
  api.Internals = internals;
  var global$1 = globalThis;

  if ($$diffHTML in globalThis) {
    var existingApi = global$1[$$diffHTML];

    if (VERSION !== existingApi.VERSION) {
      console.log("Loaded ".concat(VERSION, " after ").concat(existingApi.VERSION));
    }
  }

  global$1[$$diffHTML] = api;

  if (global$1.devTools) {
    global$1.unsubscribeDevTools = use(global$1.devTools(internals));
  }

  exports.Internals = internals;
  exports.VERSION = VERSION;
  exports.addTransitionState = addTransitionState;
  exports.createTree = createTree;
  exports.default = api;
  exports.html = createTree;
  exports.innerHTML = innerHTML;
  exports.outerHTML = outerHTML;
  exports.release = release;
  exports.removeTransitionState = removeTransitionState;
  exports.use = use;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
