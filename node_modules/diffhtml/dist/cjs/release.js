"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = release;

var _memory = require("./util/memory");

var _types = require("./util/types");

/**
 * Releases state and memory associated to a DOM Node.
 *
 * @param {Mount} mount - Valid input node
 */
function release(mount) {
  // If this was a top-level rendered element, deallocate the VTree and remove
  // the StateCache reference.
  if (_types.StateCache.has(mount)) {
    const {
      mutationObserver,
      oldTree
    } = _types.StateCache.get(mount); // Ensure the mutation observer is cleaned up.


    mutationObserver && mutationObserver.disconnect();

    _types.StateCache.delete(mount); // If there is a known root association that is not in the NodeCache,
    // remove this VTree.


    if (oldTree && !_types.NodeCache.has(oldTree)) {
      _types.ReleaseHookCache.forEach(fn => fn(oldTree));

      (0, _memory.unprotectVTree)(oldTree);
    }
  } // The rest of this function only pertains to real HTML element nodes. If
  // this is undefined, then it isn't one.


  if (!mount) {
    return;
  }

  const asHTMLElement =
  /** @type {HTMLElement} */
  mount; // Crawl the childNodes if this is an HTMLElement for state trees.

  if (asHTMLElement.childNodes && asHTMLElement.childNodes.length) {
    for (let i = 0; i < asHTMLElement.childNodes.length; i++) {
      release(asHTMLElement.childNodes[i]);
    }
  } // If there is a shadowRoot attached to the DOM node, attempt to release this
  // as well.


  if (asHTMLElement.shadowRoot) {
    release(asHTMLElement.shadowRoot);
  } // Do a thorough check within the NodeCache to fully deallocate all
  // references to the associated trees.


  _types.NodeCache.forEach((domNode, vTree) => {
    if (domNode === asHTMLElement) {
      _types.ReleaseHookCache.forEach(fn => fn(vTree));

      (0, _memory.unprotectVTree)(vTree);
    }
  });
}

module.exports = exports.default;