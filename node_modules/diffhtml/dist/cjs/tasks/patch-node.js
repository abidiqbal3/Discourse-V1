"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = patch;

var _patch = _interopRequireDefault(require("../node/patch"));

var _transaction = _interopRequireDefault(require("../transaction"));

var _types = require("../util/types");

var _global = _interopRequireDefault(require("../util/global"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Processes a set of patches onto a tracked DOM Node.
 *
 * @param {Transaction} transaction
 * @return {void}
 */
function patch(transaction) {
  const {
    mount,
    state,
    patches
  } = transaction;
  const {
    mutationObserver,
    measure,
    scriptsToExecute
  } = state;
  measure('patch node');
  const {
    ownerDocument
  } =
  /** @type {HTMLElement} */
  mount;
  const promises = transaction.promises || [];
  state.ownerDocument = ownerDocument || _global.default.document; // Always disconnect a MutationObserver before patching.

  if (mutationObserver) {
    mutationObserver.disconnect();
  } // Hook into the Node creation process to find all script tags, and mark them
  // for execution.


  const collectScripts = (
  /** @type {VTree} */
  vTree) => {
    if (vTree.nodeName === 'script') {
      scriptsToExecute.set(vTree, vTree.attributes.type);
    }
  };

  _types.CreateNodeHookCache.add(collectScripts); // Skip patching completely if we aren't in a DOM environment.


  if (state.ownerDocument) {
    promises.push(...(0, _patch.default)(patches, state));
  }

  _types.CreateNodeHookCache.delete(collectScripts);

  transaction.promises = promises;
  measure('patch node');
}

module.exports = exports.default;