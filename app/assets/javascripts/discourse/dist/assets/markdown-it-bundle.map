{"version":3,"sources":["markdown-it.js","pretty-text/engines/discourse-markdown/anchor.js","pretty-text/engines/discourse-markdown/bbcode-block.js","pretty-text/engines/discourse-markdown/bbcode-inline.js","pretty-text/engines/discourse-markdown/category-hashtag.js","pretty-text/engines/discourse-markdown/censored.js","pretty-text/engines/discourse-markdown/code.js","pretty-text/engines/discourse-markdown/custom-typographer-replacements.js","pretty-text/engines/discourse-markdown/d-wrap.js","pretty-text/engines/discourse-markdown/emoji.js","pretty-text/engines/discourse-markdown/helpers.js","pretty-text/engines/discourse-markdown/html-img.js","pretty-text/engines/discourse-markdown/image-controls.js","pretty-text/engines/discourse-markdown/mentions.js","pretty-text/engines/discourse-markdown/newline.js","pretty-text/engines/discourse-markdown/onebox.js","pretty-text/engines/discourse-markdown/paragraph.js","pretty-text/engines/discourse-markdown/quotes.js","pretty-text/engines/discourse-markdown/table.js","pretty-text/engines/discourse-markdown/text-post-process.js","pretty-text/engines/discourse-markdown/upload-protocol.js","pretty-text/engines/discourse-markdown/watched-words.js"],"sourcesContent":["/*! markdown-it 13.0.1 https://github.com/markdown-it/markdown-it @license MIT */\n(function(global, factory) {\n  typeof exports === \"object\" && typeof module !== \"undefined\" ? module.exports = factory() : typeof define === \"function\" && define.amd ? define(factory) : (global = typeof globalThis !== \"undefined\" ? globalThis : global || self, \n  global.markdownit = factory());\n})(this, (function() {\n  \"use strict\";\n  function createCommonjsModule(fn, basedir, module) {\n    return module = {\n      path: basedir,\n      exports: {},\n      require: function(path, base) {\n        return commonjsRequire(path, base === undefined || base === null ? module.path : base);\n      }\n    }, fn(module, module.exports), module.exports;\n  }\n  function getAugmentedNamespace(n) {\n    if (n.__esModule) return n;\n    var a = Object.defineProperty({}, \"__esModule\", {\n      value: true\n    });\n    Object.keys(n).forEach((function(k) {\n      var d = Object.getOwnPropertyDescriptor(n, k);\n      Object.defineProperty(a, k, d.get ? d : {\n        enumerable: true,\n        get: function() {\n          return n[k];\n        }\n      });\n    }));\n    return a;\n  }\n  function commonjsRequire() {\n    throw new Error(\"Dynamic requires are not currently supported by @rollup/plugin-commonjs\");\n  }\n  var require$$0 = {\n    Aacute: \"\\xc1\",\n    aacute: \"\\xe1\",\n    Abreve: \"\\u0102\",\n    abreve: \"\\u0103\",\n    ac: \"\\u223e\",\n    acd: \"\\u223f\",\n    acE: \"\\u223e\\u0333\",\n    Acirc: \"\\xc2\",\n    acirc: \"\\xe2\",\n    acute: \"\\xb4\",\n    Acy: \"\\u0410\",\n    acy: \"\\u0430\",\n    AElig: \"\\xc6\",\n    aelig: \"\\xe6\",\n    af: \"\\u2061\",\n    Afr: \"\\ud835\\udd04\",\n    afr: \"\\ud835\\udd1e\",\n    Agrave: \"\\xc0\",\n    agrave: \"\\xe0\",\n    alefsym: \"\\u2135\",\n    aleph: \"\\u2135\",\n    Alpha: \"\\u0391\",\n    alpha: \"\\u03b1\",\n    Amacr: \"\\u0100\",\n    amacr: \"\\u0101\",\n    amalg: \"\\u2a3f\",\n    amp: \"&\",\n    AMP: \"&\",\n    andand: \"\\u2a55\",\n    And: \"\\u2a53\",\n    and: \"\\u2227\",\n    andd: \"\\u2a5c\",\n    andslope: \"\\u2a58\",\n    andv: \"\\u2a5a\",\n    ang: \"\\u2220\",\n    ange: \"\\u29a4\",\n    angle: \"\\u2220\",\n    angmsdaa: \"\\u29a8\",\n    angmsdab: \"\\u29a9\",\n    angmsdac: \"\\u29aa\",\n    angmsdad: \"\\u29ab\",\n    angmsdae: \"\\u29ac\",\n    angmsdaf: \"\\u29ad\",\n    angmsdag: \"\\u29ae\",\n    angmsdah: \"\\u29af\",\n    angmsd: \"\\u2221\",\n    angrt: \"\\u221f\",\n    angrtvb: \"\\u22be\",\n    angrtvbd: \"\\u299d\",\n    angsph: \"\\u2222\",\n    angst: \"\\xc5\",\n    angzarr: \"\\u237c\",\n    Aogon: \"\\u0104\",\n    aogon: \"\\u0105\",\n    Aopf: \"\\ud835\\udd38\",\n    aopf: \"\\ud835\\udd52\",\n    apacir: \"\\u2a6f\",\n    ap: \"\\u2248\",\n    apE: \"\\u2a70\",\n    ape: \"\\u224a\",\n    apid: \"\\u224b\",\n    apos: \"'\",\n    ApplyFunction: \"\\u2061\",\n    approx: \"\\u2248\",\n    approxeq: \"\\u224a\",\n    Aring: \"\\xc5\",\n    aring: \"\\xe5\",\n    Ascr: \"\\ud835\\udc9c\",\n    ascr: \"\\ud835\\udcb6\",\n    Assign: \"\\u2254\",\n    ast: \"*\",\n    asymp: \"\\u2248\",\n    asympeq: \"\\u224d\",\n    Atilde: \"\\xc3\",\n    atilde: \"\\xe3\",\n    Auml: \"\\xc4\",\n    auml: \"\\xe4\",\n    awconint: \"\\u2233\",\n    awint: \"\\u2a11\",\n    backcong: \"\\u224c\",\n    backepsilon: \"\\u03f6\",\n    backprime: \"\\u2035\",\n    backsim: \"\\u223d\",\n    backsimeq: \"\\u22cd\",\n    Backslash: \"\\u2216\",\n    Barv: \"\\u2ae7\",\n    barvee: \"\\u22bd\",\n    barwed: \"\\u2305\",\n    Barwed: \"\\u2306\",\n    barwedge: \"\\u2305\",\n    bbrk: \"\\u23b5\",\n    bbrktbrk: \"\\u23b6\",\n    bcong: \"\\u224c\",\n    Bcy: \"\\u0411\",\n    bcy: \"\\u0431\",\n    bdquo: \"\\u201e\",\n    becaus: \"\\u2235\",\n    because: \"\\u2235\",\n    Because: \"\\u2235\",\n    bemptyv: \"\\u29b0\",\n    bepsi: \"\\u03f6\",\n    bernou: \"\\u212c\",\n    Bernoullis: \"\\u212c\",\n    Beta: \"\\u0392\",\n    beta: \"\\u03b2\",\n    beth: \"\\u2136\",\n    between: \"\\u226c\",\n    Bfr: \"\\ud835\\udd05\",\n    bfr: \"\\ud835\\udd1f\",\n    bigcap: \"\\u22c2\",\n    bigcirc: \"\\u25ef\",\n    bigcup: \"\\u22c3\",\n    bigodot: \"\\u2a00\",\n    bigoplus: \"\\u2a01\",\n    bigotimes: \"\\u2a02\",\n    bigsqcup: \"\\u2a06\",\n    bigstar: \"\\u2605\",\n    bigtriangledown: \"\\u25bd\",\n    bigtriangleup: \"\\u25b3\",\n    biguplus: \"\\u2a04\",\n    bigvee: \"\\u22c1\",\n    bigwedge: \"\\u22c0\",\n    bkarow: \"\\u290d\",\n    blacklozenge: \"\\u29eb\",\n    blacksquare: \"\\u25aa\",\n    blacktriangle: \"\\u25b4\",\n    blacktriangledown: \"\\u25be\",\n    blacktriangleleft: \"\\u25c2\",\n    blacktriangleright: \"\\u25b8\",\n    blank: \"\\u2423\",\n    blk12: \"\\u2592\",\n    blk14: \"\\u2591\",\n    blk34: \"\\u2593\",\n    block: \"\\u2588\",\n    bne: \"=\\u20e5\",\n    bnequiv: \"\\u2261\\u20e5\",\n    bNot: \"\\u2aed\",\n    bnot: \"\\u2310\",\n    Bopf: \"\\ud835\\udd39\",\n    bopf: \"\\ud835\\udd53\",\n    bot: \"\\u22a5\",\n    bottom: \"\\u22a5\",\n    bowtie: \"\\u22c8\",\n    boxbox: \"\\u29c9\",\n    boxdl: \"\\u2510\",\n    boxdL: \"\\u2555\",\n    boxDl: \"\\u2556\",\n    boxDL: \"\\u2557\",\n    boxdr: \"\\u250c\",\n    boxdR: \"\\u2552\",\n    boxDr: \"\\u2553\",\n    boxDR: \"\\u2554\",\n    boxh: \"\\u2500\",\n    boxH: \"\\u2550\",\n    boxhd: \"\\u252c\",\n    boxHd: \"\\u2564\",\n    boxhD: \"\\u2565\",\n    boxHD: \"\\u2566\",\n    boxhu: \"\\u2534\",\n    boxHu: \"\\u2567\",\n    boxhU: \"\\u2568\",\n    boxHU: \"\\u2569\",\n    boxminus: \"\\u229f\",\n    boxplus: \"\\u229e\",\n    boxtimes: \"\\u22a0\",\n    boxul: \"\\u2518\",\n    boxuL: \"\\u255b\",\n    boxUl: \"\\u255c\",\n    boxUL: \"\\u255d\",\n    boxur: \"\\u2514\",\n    boxuR: \"\\u2558\",\n    boxUr: \"\\u2559\",\n    boxUR: \"\\u255a\",\n    boxv: \"\\u2502\",\n    boxV: \"\\u2551\",\n    boxvh: \"\\u253c\",\n    boxvH: \"\\u256a\",\n    boxVh: \"\\u256b\",\n    boxVH: \"\\u256c\",\n    boxvl: \"\\u2524\",\n    boxvL: \"\\u2561\",\n    boxVl: \"\\u2562\",\n    boxVL: \"\\u2563\",\n    boxvr: \"\\u251c\",\n    boxvR: \"\\u255e\",\n    boxVr: \"\\u255f\",\n    boxVR: \"\\u2560\",\n    bprime: \"\\u2035\",\n    breve: \"\\u02d8\",\n    Breve: \"\\u02d8\",\n    brvbar: \"\\xa6\",\n    bscr: \"\\ud835\\udcb7\",\n    Bscr: \"\\u212c\",\n    bsemi: \"\\u204f\",\n    bsim: \"\\u223d\",\n    bsime: \"\\u22cd\",\n    bsolb: \"\\u29c5\",\n    bsol: \"\\\\\",\n    bsolhsub: \"\\u27c8\",\n    bull: \"\\u2022\",\n    bullet: \"\\u2022\",\n    bump: \"\\u224e\",\n    bumpE: \"\\u2aae\",\n    bumpe: \"\\u224f\",\n    Bumpeq: \"\\u224e\",\n    bumpeq: \"\\u224f\",\n    Cacute: \"\\u0106\",\n    cacute: \"\\u0107\",\n    capand: \"\\u2a44\",\n    capbrcup: \"\\u2a49\",\n    capcap: \"\\u2a4b\",\n    cap: \"\\u2229\",\n    Cap: \"\\u22d2\",\n    capcup: \"\\u2a47\",\n    capdot: \"\\u2a40\",\n    CapitalDifferentialD: \"\\u2145\",\n    caps: \"\\u2229\\ufe00\",\n    caret: \"\\u2041\",\n    caron: \"\\u02c7\",\n    Cayleys: \"\\u212d\",\n    ccaps: \"\\u2a4d\",\n    Ccaron: \"\\u010c\",\n    ccaron: \"\\u010d\",\n    Ccedil: \"\\xc7\",\n    ccedil: \"\\xe7\",\n    Ccirc: \"\\u0108\",\n    ccirc: \"\\u0109\",\n    Cconint: \"\\u2230\",\n    ccups: \"\\u2a4c\",\n    ccupssm: \"\\u2a50\",\n    Cdot: \"\\u010a\",\n    cdot: \"\\u010b\",\n    cedil: \"\\xb8\",\n    Cedilla: \"\\xb8\",\n    cemptyv: \"\\u29b2\",\n    cent: \"\\xa2\",\n    centerdot: \"\\xb7\",\n    CenterDot: \"\\xb7\",\n    cfr: \"\\ud835\\udd20\",\n    Cfr: \"\\u212d\",\n    CHcy: \"\\u0427\",\n    chcy: \"\\u0447\",\n    check: \"\\u2713\",\n    checkmark: \"\\u2713\",\n    Chi: \"\\u03a7\",\n    chi: \"\\u03c7\",\n    circ: \"\\u02c6\",\n    circeq: \"\\u2257\",\n    circlearrowleft: \"\\u21ba\",\n    circlearrowright: \"\\u21bb\",\n    circledast: \"\\u229b\",\n    circledcirc: \"\\u229a\",\n    circleddash: \"\\u229d\",\n    CircleDot: \"\\u2299\",\n    circledR: \"\\xae\",\n    circledS: \"\\u24c8\",\n    CircleMinus: \"\\u2296\",\n    CirclePlus: \"\\u2295\",\n    CircleTimes: \"\\u2297\",\n    cir: \"\\u25cb\",\n    cirE: \"\\u29c3\",\n    cire: \"\\u2257\",\n    cirfnint: \"\\u2a10\",\n    cirmid: \"\\u2aef\",\n    cirscir: \"\\u29c2\",\n    ClockwiseContourIntegral: \"\\u2232\",\n    CloseCurlyDoubleQuote: \"\\u201d\",\n    CloseCurlyQuote: \"\\u2019\",\n    clubs: \"\\u2663\",\n    clubsuit: \"\\u2663\",\n    colon: \":\",\n    Colon: \"\\u2237\",\n    Colone: \"\\u2a74\",\n    colone: \"\\u2254\",\n    coloneq: \"\\u2254\",\n    comma: \",\",\n    commat: \"@\",\n    comp: \"\\u2201\",\n    compfn: \"\\u2218\",\n    complement: \"\\u2201\",\n    complexes: \"\\u2102\",\n    cong: \"\\u2245\",\n    congdot: \"\\u2a6d\",\n    Congruent: \"\\u2261\",\n    conint: \"\\u222e\",\n    Conint: \"\\u222f\",\n    ContourIntegral: \"\\u222e\",\n    copf: \"\\ud835\\udd54\",\n    Copf: \"\\u2102\",\n    coprod: \"\\u2210\",\n    Coproduct: \"\\u2210\",\n    copy: \"\\xa9\",\n    COPY: \"\\xa9\",\n    copysr: \"\\u2117\",\n    CounterClockwiseContourIntegral: \"\\u2233\",\n    crarr: \"\\u21b5\",\n    cross: \"\\u2717\",\n    Cross: \"\\u2a2f\",\n    Cscr: \"\\ud835\\udc9e\",\n    cscr: \"\\ud835\\udcb8\",\n    csub: \"\\u2acf\",\n    csube: \"\\u2ad1\",\n    csup: \"\\u2ad0\",\n    csupe: \"\\u2ad2\",\n    ctdot: \"\\u22ef\",\n    cudarrl: \"\\u2938\",\n    cudarrr: \"\\u2935\",\n    cuepr: \"\\u22de\",\n    cuesc: \"\\u22df\",\n    cularr: \"\\u21b6\",\n    cularrp: \"\\u293d\",\n    cupbrcap: \"\\u2a48\",\n    cupcap: \"\\u2a46\",\n    CupCap: \"\\u224d\",\n    cup: \"\\u222a\",\n    Cup: \"\\u22d3\",\n    cupcup: \"\\u2a4a\",\n    cupdot: \"\\u228d\",\n    cupor: \"\\u2a45\",\n    cups: \"\\u222a\\ufe00\",\n    curarr: \"\\u21b7\",\n    curarrm: \"\\u293c\",\n    curlyeqprec: \"\\u22de\",\n    curlyeqsucc: \"\\u22df\",\n    curlyvee: \"\\u22ce\",\n    curlywedge: \"\\u22cf\",\n    curren: \"\\xa4\",\n    curvearrowleft: \"\\u21b6\",\n    curvearrowright: \"\\u21b7\",\n    cuvee: \"\\u22ce\",\n    cuwed: \"\\u22cf\",\n    cwconint: \"\\u2232\",\n    cwint: \"\\u2231\",\n    cylcty: \"\\u232d\",\n    dagger: \"\\u2020\",\n    Dagger: \"\\u2021\",\n    daleth: \"\\u2138\",\n    darr: \"\\u2193\",\n    Darr: \"\\u21a1\",\n    dArr: \"\\u21d3\",\n    dash: \"\\u2010\",\n    Dashv: \"\\u2ae4\",\n    dashv: \"\\u22a3\",\n    dbkarow: \"\\u290f\",\n    dblac: \"\\u02dd\",\n    Dcaron: \"\\u010e\",\n    dcaron: \"\\u010f\",\n    Dcy: \"\\u0414\",\n    dcy: \"\\u0434\",\n    ddagger: \"\\u2021\",\n    ddarr: \"\\u21ca\",\n    DD: \"\\u2145\",\n    dd: \"\\u2146\",\n    DDotrahd: \"\\u2911\",\n    ddotseq: \"\\u2a77\",\n    deg: \"\\xb0\",\n    Del: \"\\u2207\",\n    Delta: \"\\u0394\",\n    delta: \"\\u03b4\",\n    demptyv: \"\\u29b1\",\n    dfisht: \"\\u297f\",\n    Dfr: \"\\ud835\\udd07\",\n    dfr: \"\\ud835\\udd21\",\n    dHar: \"\\u2965\",\n    dharl: \"\\u21c3\",\n    dharr: \"\\u21c2\",\n    DiacriticalAcute: \"\\xb4\",\n    DiacriticalDot: \"\\u02d9\",\n    DiacriticalDoubleAcute: \"\\u02dd\",\n    DiacriticalGrave: \"`\",\n    DiacriticalTilde: \"\\u02dc\",\n    diam: \"\\u22c4\",\n    diamond: \"\\u22c4\",\n    Diamond: \"\\u22c4\",\n    diamondsuit: \"\\u2666\",\n    diams: \"\\u2666\",\n    die: \"\\xa8\",\n    DifferentialD: \"\\u2146\",\n    digamma: \"\\u03dd\",\n    disin: \"\\u22f2\",\n    div: \"\\xf7\",\n    divide: \"\\xf7\",\n    divideontimes: \"\\u22c7\",\n    divonx: \"\\u22c7\",\n    DJcy: \"\\u0402\",\n    djcy: \"\\u0452\",\n    dlcorn: \"\\u231e\",\n    dlcrop: \"\\u230d\",\n    dollar: \"$\",\n    Dopf: \"\\ud835\\udd3b\",\n    dopf: \"\\ud835\\udd55\",\n    Dot: \"\\xa8\",\n    dot: \"\\u02d9\",\n    DotDot: \"\\u20dc\",\n    doteq: \"\\u2250\",\n    doteqdot: \"\\u2251\",\n    DotEqual: \"\\u2250\",\n    dotminus: \"\\u2238\",\n    dotplus: \"\\u2214\",\n    dotsquare: \"\\u22a1\",\n    doublebarwedge: \"\\u2306\",\n    DoubleContourIntegral: \"\\u222f\",\n    DoubleDot: \"\\xa8\",\n    DoubleDownArrow: \"\\u21d3\",\n    DoubleLeftArrow: \"\\u21d0\",\n    DoubleLeftRightArrow: \"\\u21d4\",\n    DoubleLeftTee: \"\\u2ae4\",\n    DoubleLongLeftArrow: \"\\u27f8\",\n    DoubleLongLeftRightArrow: \"\\u27fa\",\n    DoubleLongRightArrow: \"\\u27f9\",\n    DoubleRightArrow: \"\\u21d2\",\n    DoubleRightTee: \"\\u22a8\",\n    DoubleUpArrow: \"\\u21d1\",\n    DoubleUpDownArrow: \"\\u21d5\",\n    DoubleVerticalBar: \"\\u2225\",\n    DownArrowBar: \"\\u2913\",\n    downarrow: \"\\u2193\",\n    DownArrow: \"\\u2193\",\n    Downarrow: \"\\u21d3\",\n    DownArrowUpArrow: \"\\u21f5\",\n    DownBreve: \"\\u0311\",\n    downdownarrows: \"\\u21ca\",\n    downharpoonleft: \"\\u21c3\",\n    downharpoonright: \"\\u21c2\",\n    DownLeftRightVector: \"\\u2950\",\n    DownLeftTeeVector: \"\\u295e\",\n    DownLeftVectorBar: \"\\u2956\",\n    DownLeftVector: \"\\u21bd\",\n    DownRightTeeVector: \"\\u295f\",\n    DownRightVectorBar: \"\\u2957\",\n    DownRightVector: \"\\u21c1\",\n    DownTeeArrow: \"\\u21a7\",\n    DownTee: \"\\u22a4\",\n    drbkarow: \"\\u2910\",\n    drcorn: \"\\u231f\",\n    drcrop: \"\\u230c\",\n    Dscr: \"\\ud835\\udc9f\",\n    dscr: \"\\ud835\\udcb9\",\n    DScy: \"\\u0405\",\n    dscy: \"\\u0455\",\n    dsol: \"\\u29f6\",\n    Dstrok: \"\\u0110\",\n    dstrok: \"\\u0111\",\n    dtdot: \"\\u22f1\",\n    dtri: \"\\u25bf\",\n    dtrif: \"\\u25be\",\n    duarr: \"\\u21f5\",\n    duhar: \"\\u296f\",\n    dwangle: \"\\u29a6\",\n    DZcy: \"\\u040f\",\n    dzcy: \"\\u045f\",\n    dzigrarr: \"\\u27ff\",\n    Eacute: \"\\xc9\",\n    eacute: \"\\xe9\",\n    easter: \"\\u2a6e\",\n    Ecaron: \"\\u011a\",\n    ecaron: \"\\u011b\",\n    Ecirc: \"\\xca\",\n    ecirc: \"\\xea\",\n    ecir: \"\\u2256\",\n    ecolon: \"\\u2255\",\n    Ecy: \"\\u042d\",\n    ecy: \"\\u044d\",\n    eDDot: \"\\u2a77\",\n    Edot: \"\\u0116\",\n    edot: \"\\u0117\",\n    eDot: \"\\u2251\",\n    ee: \"\\u2147\",\n    efDot: \"\\u2252\",\n    Efr: \"\\ud835\\udd08\",\n    efr: \"\\ud835\\udd22\",\n    eg: \"\\u2a9a\",\n    Egrave: \"\\xc8\",\n    egrave: \"\\xe8\",\n    egs: \"\\u2a96\",\n    egsdot: \"\\u2a98\",\n    el: \"\\u2a99\",\n    Element: \"\\u2208\",\n    elinters: \"\\u23e7\",\n    ell: \"\\u2113\",\n    els: \"\\u2a95\",\n    elsdot: \"\\u2a97\",\n    Emacr: \"\\u0112\",\n    emacr: \"\\u0113\",\n    empty: \"\\u2205\",\n    emptyset: \"\\u2205\",\n    EmptySmallSquare: \"\\u25fb\",\n    emptyv: \"\\u2205\",\n    EmptyVerySmallSquare: \"\\u25ab\",\n    emsp13: \"\\u2004\",\n    emsp14: \"\\u2005\",\n    emsp: \"\\u2003\",\n    ENG: \"\\u014a\",\n    eng: \"\\u014b\",\n    ensp: \"\\u2002\",\n    Eogon: \"\\u0118\",\n    eogon: \"\\u0119\",\n    Eopf: \"\\ud835\\udd3c\",\n    eopf: \"\\ud835\\udd56\",\n    epar: \"\\u22d5\",\n    eparsl: \"\\u29e3\",\n    eplus: \"\\u2a71\",\n    epsi: \"\\u03b5\",\n    Epsilon: \"\\u0395\",\n    epsilon: \"\\u03b5\",\n    epsiv: \"\\u03f5\",\n    eqcirc: \"\\u2256\",\n    eqcolon: \"\\u2255\",\n    eqsim: \"\\u2242\",\n    eqslantgtr: \"\\u2a96\",\n    eqslantless: \"\\u2a95\",\n    Equal: \"\\u2a75\",\n    equals: \"=\",\n    EqualTilde: \"\\u2242\",\n    equest: \"\\u225f\",\n    Equilibrium: \"\\u21cc\",\n    equiv: \"\\u2261\",\n    equivDD: \"\\u2a78\",\n    eqvparsl: \"\\u29e5\",\n    erarr: \"\\u2971\",\n    erDot: \"\\u2253\",\n    escr: \"\\u212f\",\n    Escr: \"\\u2130\",\n    esdot: \"\\u2250\",\n    Esim: \"\\u2a73\",\n    esim: \"\\u2242\",\n    Eta: \"\\u0397\",\n    eta: \"\\u03b7\",\n    ETH: \"\\xd0\",\n    eth: \"\\xf0\",\n    Euml: \"\\xcb\",\n    euml: \"\\xeb\",\n    euro: \"\\u20ac\",\n    excl: \"!\",\n    exist: \"\\u2203\",\n    Exists: \"\\u2203\",\n    expectation: \"\\u2130\",\n    exponentiale: \"\\u2147\",\n    ExponentialE: \"\\u2147\",\n    fallingdotseq: \"\\u2252\",\n    Fcy: \"\\u0424\",\n    fcy: \"\\u0444\",\n    female: \"\\u2640\",\n    ffilig: \"\\ufb03\",\n    fflig: \"\\ufb00\",\n    ffllig: \"\\ufb04\",\n    Ffr: \"\\ud835\\udd09\",\n    ffr: \"\\ud835\\udd23\",\n    filig: \"\\ufb01\",\n    FilledSmallSquare: \"\\u25fc\",\n    FilledVerySmallSquare: \"\\u25aa\",\n    fjlig: \"fj\",\n    flat: \"\\u266d\",\n    fllig: \"\\ufb02\",\n    fltns: \"\\u25b1\",\n    fnof: \"\\u0192\",\n    Fopf: \"\\ud835\\udd3d\",\n    fopf: \"\\ud835\\udd57\",\n    forall: \"\\u2200\",\n    ForAll: \"\\u2200\",\n    fork: \"\\u22d4\",\n    forkv: \"\\u2ad9\",\n    Fouriertrf: \"\\u2131\",\n    fpartint: \"\\u2a0d\",\n    frac12: \"\\xbd\",\n    frac13: \"\\u2153\",\n    frac14: \"\\xbc\",\n    frac15: \"\\u2155\",\n    frac16: \"\\u2159\",\n    frac18: \"\\u215b\",\n    frac23: \"\\u2154\",\n    frac25: \"\\u2156\",\n    frac34: \"\\xbe\",\n    frac35: \"\\u2157\",\n    frac38: \"\\u215c\",\n    frac45: \"\\u2158\",\n    frac56: \"\\u215a\",\n    frac58: \"\\u215d\",\n    frac78: \"\\u215e\",\n    frasl: \"\\u2044\",\n    frown: \"\\u2322\",\n    fscr: \"\\ud835\\udcbb\",\n    Fscr: \"\\u2131\",\n    gacute: \"\\u01f5\",\n    Gamma: \"\\u0393\",\n    gamma: \"\\u03b3\",\n    Gammad: \"\\u03dc\",\n    gammad: \"\\u03dd\",\n    gap: \"\\u2a86\",\n    Gbreve: \"\\u011e\",\n    gbreve: \"\\u011f\",\n    Gcedil: \"\\u0122\",\n    Gcirc: \"\\u011c\",\n    gcirc: \"\\u011d\",\n    Gcy: \"\\u0413\",\n    gcy: \"\\u0433\",\n    Gdot: \"\\u0120\",\n    gdot: \"\\u0121\",\n    ge: \"\\u2265\",\n    gE: \"\\u2267\",\n    gEl: \"\\u2a8c\",\n    gel: \"\\u22db\",\n    geq: \"\\u2265\",\n    geqq: \"\\u2267\",\n    geqslant: \"\\u2a7e\",\n    gescc: \"\\u2aa9\",\n    ges: \"\\u2a7e\",\n    gesdot: \"\\u2a80\",\n    gesdoto: \"\\u2a82\",\n    gesdotol: \"\\u2a84\",\n    gesl: \"\\u22db\\ufe00\",\n    gesles: \"\\u2a94\",\n    Gfr: \"\\ud835\\udd0a\",\n    gfr: \"\\ud835\\udd24\",\n    gg: \"\\u226b\",\n    Gg: \"\\u22d9\",\n    ggg: \"\\u22d9\",\n    gimel: \"\\u2137\",\n    GJcy: \"\\u0403\",\n    gjcy: \"\\u0453\",\n    gla: \"\\u2aa5\",\n    gl: \"\\u2277\",\n    glE: \"\\u2a92\",\n    glj: \"\\u2aa4\",\n    gnap: \"\\u2a8a\",\n    gnapprox: \"\\u2a8a\",\n    gne: \"\\u2a88\",\n    gnE: \"\\u2269\",\n    gneq: \"\\u2a88\",\n    gneqq: \"\\u2269\",\n    gnsim: \"\\u22e7\",\n    Gopf: \"\\ud835\\udd3e\",\n    gopf: \"\\ud835\\udd58\",\n    grave: \"`\",\n    GreaterEqual: \"\\u2265\",\n    GreaterEqualLess: \"\\u22db\",\n    GreaterFullEqual: \"\\u2267\",\n    GreaterGreater: \"\\u2aa2\",\n    GreaterLess: \"\\u2277\",\n    GreaterSlantEqual: \"\\u2a7e\",\n    GreaterTilde: \"\\u2273\",\n    Gscr: \"\\ud835\\udca2\",\n    gscr: \"\\u210a\",\n    gsim: \"\\u2273\",\n    gsime: \"\\u2a8e\",\n    gsiml: \"\\u2a90\",\n    gtcc: \"\\u2aa7\",\n    gtcir: \"\\u2a7a\",\n    gt: \">\",\n    GT: \">\",\n    Gt: \"\\u226b\",\n    gtdot: \"\\u22d7\",\n    gtlPar: \"\\u2995\",\n    gtquest: \"\\u2a7c\",\n    gtrapprox: \"\\u2a86\",\n    gtrarr: \"\\u2978\",\n    gtrdot: \"\\u22d7\",\n    gtreqless: \"\\u22db\",\n    gtreqqless: \"\\u2a8c\",\n    gtrless: \"\\u2277\",\n    gtrsim: \"\\u2273\",\n    gvertneqq: \"\\u2269\\ufe00\",\n    gvnE: \"\\u2269\\ufe00\",\n    Hacek: \"\\u02c7\",\n    hairsp: \"\\u200a\",\n    half: \"\\xbd\",\n    hamilt: \"\\u210b\",\n    HARDcy: \"\\u042a\",\n    hardcy: \"\\u044a\",\n    harrcir: \"\\u2948\",\n    harr: \"\\u2194\",\n    hArr: \"\\u21d4\",\n    harrw: \"\\u21ad\",\n    Hat: \"^\",\n    hbar: \"\\u210f\",\n    Hcirc: \"\\u0124\",\n    hcirc: \"\\u0125\",\n    hearts: \"\\u2665\",\n    heartsuit: \"\\u2665\",\n    hellip: \"\\u2026\",\n    hercon: \"\\u22b9\",\n    hfr: \"\\ud835\\udd25\",\n    Hfr: \"\\u210c\",\n    HilbertSpace: \"\\u210b\",\n    hksearow: \"\\u2925\",\n    hkswarow: \"\\u2926\",\n    hoarr: \"\\u21ff\",\n    homtht: \"\\u223b\",\n    hookleftarrow: \"\\u21a9\",\n    hookrightarrow: \"\\u21aa\",\n    hopf: \"\\ud835\\udd59\",\n    Hopf: \"\\u210d\",\n    horbar: \"\\u2015\",\n    HorizontalLine: \"\\u2500\",\n    hscr: \"\\ud835\\udcbd\",\n    Hscr: \"\\u210b\",\n    hslash: \"\\u210f\",\n    Hstrok: \"\\u0126\",\n    hstrok: \"\\u0127\",\n    HumpDownHump: \"\\u224e\",\n    HumpEqual: \"\\u224f\",\n    hybull: \"\\u2043\",\n    hyphen: \"\\u2010\",\n    Iacute: \"\\xcd\",\n    iacute: \"\\xed\",\n    ic: \"\\u2063\",\n    Icirc: \"\\xce\",\n    icirc: \"\\xee\",\n    Icy: \"\\u0418\",\n    icy: \"\\u0438\",\n    Idot: \"\\u0130\",\n    IEcy: \"\\u0415\",\n    iecy: \"\\u0435\",\n    iexcl: \"\\xa1\",\n    iff: \"\\u21d4\",\n    ifr: \"\\ud835\\udd26\",\n    Ifr: \"\\u2111\",\n    Igrave: \"\\xcc\",\n    igrave: \"\\xec\",\n    ii: \"\\u2148\",\n    iiiint: \"\\u2a0c\",\n    iiint: \"\\u222d\",\n    iinfin: \"\\u29dc\",\n    iiota: \"\\u2129\",\n    IJlig: \"\\u0132\",\n    ijlig: \"\\u0133\",\n    Imacr: \"\\u012a\",\n    imacr: \"\\u012b\",\n    image: \"\\u2111\",\n    ImaginaryI: \"\\u2148\",\n    imagline: \"\\u2110\",\n    imagpart: \"\\u2111\",\n    imath: \"\\u0131\",\n    Im: \"\\u2111\",\n    imof: \"\\u22b7\",\n    imped: \"\\u01b5\",\n    Implies: \"\\u21d2\",\n    incare: \"\\u2105\",\n    in: \"\\u2208\",\n    infin: \"\\u221e\",\n    infintie: \"\\u29dd\",\n    inodot: \"\\u0131\",\n    intcal: \"\\u22ba\",\n    int: \"\\u222b\",\n    Int: \"\\u222c\",\n    integers: \"\\u2124\",\n    Integral: \"\\u222b\",\n    intercal: \"\\u22ba\",\n    Intersection: \"\\u22c2\",\n    intlarhk: \"\\u2a17\",\n    intprod: \"\\u2a3c\",\n    InvisibleComma: \"\\u2063\",\n    InvisibleTimes: \"\\u2062\",\n    IOcy: \"\\u0401\",\n    iocy: \"\\u0451\",\n    Iogon: \"\\u012e\",\n    iogon: \"\\u012f\",\n    Iopf: \"\\ud835\\udd40\",\n    iopf: \"\\ud835\\udd5a\",\n    Iota: \"\\u0399\",\n    iota: \"\\u03b9\",\n    iprod: \"\\u2a3c\",\n    iquest: \"\\xbf\",\n    iscr: \"\\ud835\\udcbe\",\n    Iscr: \"\\u2110\",\n    isin: \"\\u2208\",\n    isindot: \"\\u22f5\",\n    isinE: \"\\u22f9\",\n    isins: \"\\u22f4\",\n    isinsv: \"\\u22f3\",\n    isinv: \"\\u2208\",\n    it: \"\\u2062\",\n    Itilde: \"\\u0128\",\n    itilde: \"\\u0129\",\n    Iukcy: \"\\u0406\",\n    iukcy: \"\\u0456\",\n    Iuml: \"\\xcf\",\n    iuml: \"\\xef\",\n    Jcirc: \"\\u0134\",\n    jcirc: \"\\u0135\",\n    Jcy: \"\\u0419\",\n    jcy: \"\\u0439\",\n    Jfr: \"\\ud835\\udd0d\",\n    jfr: \"\\ud835\\udd27\",\n    jmath: \"\\u0237\",\n    Jopf: \"\\ud835\\udd41\",\n    jopf: \"\\ud835\\udd5b\",\n    Jscr: \"\\ud835\\udca5\",\n    jscr: \"\\ud835\\udcbf\",\n    Jsercy: \"\\u0408\",\n    jsercy: \"\\u0458\",\n    Jukcy: \"\\u0404\",\n    jukcy: \"\\u0454\",\n    Kappa: \"\\u039a\",\n    kappa: \"\\u03ba\",\n    kappav: \"\\u03f0\",\n    Kcedil: \"\\u0136\",\n    kcedil: \"\\u0137\",\n    Kcy: \"\\u041a\",\n    kcy: \"\\u043a\",\n    Kfr: \"\\ud835\\udd0e\",\n    kfr: \"\\ud835\\udd28\",\n    kgreen: \"\\u0138\",\n    KHcy: \"\\u0425\",\n    khcy: \"\\u0445\",\n    KJcy: \"\\u040c\",\n    kjcy: \"\\u045c\",\n    Kopf: \"\\ud835\\udd42\",\n    kopf: \"\\ud835\\udd5c\",\n    Kscr: \"\\ud835\\udca6\",\n    kscr: \"\\ud835\\udcc0\",\n    lAarr: \"\\u21da\",\n    Lacute: \"\\u0139\",\n    lacute: \"\\u013a\",\n    laemptyv: \"\\u29b4\",\n    lagran: \"\\u2112\",\n    Lambda: \"\\u039b\",\n    lambda: \"\\u03bb\",\n    lang: \"\\u27e8\",\n    Lang: \"\\u27ea\",\n    langd: \"\\u2991\",\n    langle: \"\\u27e8\",\n    lap: \"\\u2a85\",\n    Laplacetrf: \"\\u2112\",\n    laquo: \"\\xab\",\n    larrb: \"\\u21e4\",\n    larrbfs: \"\\u291f\",\n    larr: \"\\u2190\",\n    Larr: \"\\u219e\",\n    lArr: \"\\u21d0\",\n    larrfs: \"\\u291d\",\n    larrhk: \"\\u21a9\",\n    larrlp: \"\\u21ab\",\n    larrpl: \"\\u2939\",\n    larrsim: \"\\u2973\",\n    larrtl: \"\\u21a2\",\n    latail: \"\\u2919\",\n    lAtail: \"\\u291b\",\n    lat: \"\\u2aab\",\n    late: \"\\u2aad\",\n    lates: \"\\u2aad\\ufe00\",\n    lbarr: \"\\u290c\",\n    lBarr: \"\\u290e\",\n    lbbrk: \"\\u2772\",\n    lbrace: \"{\",\n    lbrack: \"[\",\n    lbrke: \"\\u298b\",\n    lbrksld: \"\\u298f\",\n    lbrkslu: \"\\u298d\",\n    Lcaron: \"\\u013d\",\n    lcaron: \"\\u013e\",\n    Lcedil: \"\\u013b\",\n    lcedil: \"\\u013c\",\n    lceil: \"\\u2308\",\n    lcub: \"{\",\n    Lcy: \"\\u041b\",\n    lcy: \"\\u043b\",\n    ldca: \"\\u2936\",\n    ldquo: \"\\u201c\",\n    ldquor: \"\\u201e\",\n    ldrdhar: \"\\u2967\",\n    ldrushar: \"\\u294b\",\n    ldsh: \"\\u21b2\",\n    le: \"\\u2264\",\n    lE: \"\\u2266\",\n    LeftAngleBracket: \"\\u27e8\",\n    LeftArrowBar: \"\\u21e4\",\n    leftarrow: \"\\u2190\",\n    LeftArrow: \"\\u2190\",\n    Leftarrow: \"\\u21d0\",\n    LeftArrowRightArrow: \"\\u21c6\",\n    leftarrowtail: \"\\u21a2\",\n    LeftCeiling: \"\\u2308\",\n    LeftDoubleBracket: \"\\u27e6\",\n    LeftDownTeeVector: \"\\u2961\",\n    LeftDownVectorBar: \"\\u2959\",\n    LeftDownVector: \"\\u21c3\",\n    LeftFloor: \"\\u230a\",\n    leftharpoondown: \"\\u21bd\",\n    leftharpoonup: \"\\u21bc\",\n    leftleftarrows: \"\\u21c7\",\n    leftrightarrow: \"\\u2194\",\n    LeftRightArrow: \"\\u2194\",\n    Leftrightarrow: \"\\u21d4\",\n    leftrightarrows: \"\\u21c6\",\n    leftrightharpoons: \"\\u21cb\",\n    leftrightsquigarrow: \"\\u21ad\",\n    LeftRightVector: \"\\u294e\",\n    LeftTeeArrow: \"\\u21a4\",\n    LeftTee: \"\\u22a3\",\n    LeftTeeVector: \"\\u295a\",\n    leftthreetimes: \"\\u22cb\",\n    LeftTriangleBar: \"\\u29cf\",\n    LeftTriangle: \"\\u22b2\",\n    LeftTriangleEqual: \"\\u22b4\",\n    LeftUpDownVector: \"\\u2951\",\n    LeftUpTeeVector: \"\\u2960\",\n    LeftUpVectorBar: \"\\u2958\",\n    LeftUpVector: \"\\u21bf\",\n    LeftVectorBar: \"\\u2952\",\n    LeftVector: \"\\u21bc\",\n    lEg: \"\\u2a8b\",\n    leg: \"\\u22da\",\n    leq: \"\\u2264\",\n    leqq: \"\\u2266\",\n    leqslant: \"\\u2a7d\",\n    lescc: \"\\u2aa8\",\n    les: \"\\u2a7d\",\n    lesdot: \"\\u2a7f\",\n    lesdoto: \"\\u2a81\",\n    lesdotor: \"\\u2a83\",\n    lesg: \"\\u22da\\ufe00\",\n    lesges: \"\\u2a93\",\n    lessapprox: \"\\u2a85\",\n    lessdot: \"\\u22d6\",\n    lesseqgtr: \"\\u22da\",\n    lesseqqgtr: \"\\u2a8b\",\n    LessEqualGreater: \"\\u22da\",\n    LessFullEqual: \"\\u2266\",\n    LessGreater: \"\\u2276\",\n    lessgtr: \"\\u2276\",\n    LessLess: \"\\u2aa1\",\n    lesssim: \"\\u2272\",\n    LessSlantEqual: \"\\u2a7d\",\n    LessTilde: \"\\u2272\",\n    lfisht: \"\\u297c\",\n    lfloor: \"\\u230a\",\n    Lfr: \"\\ud835\\udd0f\",\n    lfr: \"\\ud835\\udd29\",\n    lg: \"\\u2276\",\n    lgE: \"\\u2a91\",\n    lHar: \"\\u2962\",\n    lhard: \"\\u21bd\",\n    lharu: \"\\u21bc\",\n    lharul: \"\\u296a\",\n    lhblk: \"\\u2584\",\n    LJcy: \"\\u0409\",\n    ljcy: \"\\u0459\",\n    llarr: \"\\u21c7\",\n    ll: \"\\u226a\",\n    Ll: \"\\u22d8\",\n    llcorner: \"\\u231e\",\n    Lleftarrow: \"\\u21da\",\n    llhard: \"\\u296b\",\n    lltri: \"\\u25fa\",\n    Lmidot: \"\\u013f\",\n    lmidot: \"\\u0140\",\n    lmoustache: \"\\u23b0\",\n    lmoust: \"\\u23b0\",\n    lnap: \"\\u2a89\",\n    lnapprox: \"\\u2a89\",\n    lne: \"\\u2a87\",\n    lnE: \"\\u2268\",\n    lneq: \"\\u2a87\",\n    lneqq: \"\\u2268\",\n    lnsim: \"\\u22e6\",\n    loang: \"\\u27ec\",\n    loarr: \"\\u21fd\",\n    lobrk: \"\\u27e6\",\n    longleftarrow: \"\\u27f5\",\n    LongLeftArrow: \"\\u27f5\",\n    Longleftarrow: \"\\u27f8\",\n    longleftrightarrow: \"\\u27f7\",\n    LongLeftRightArrow: \"\\u27f7\",\n    Longleftrightarrow: \"\\u27fa\",\n    longmapsto: \"\\u27fc\",\n    longrightarrow: \"\\u27f6\",\n    LongRightArrow: \"\\u27f6\",\n    Longrightarrow: \"\\u27f9\",\n    looparrowleft: \"\\u21ab\",\n    looparrowright: \"\\u21ac\",\n    lopar: \"\\u2985\",\n    Lopf: \"\\ud835\\udd43\",\n    lopf: \"\\ud835\\udd5d\",\n    loplus: \"\\u2a2d\",\n    lotimes: \"\\u2a34\",\n    lowast: \"\\u2217\",\n    lowbar: \"_\",\n    LowerLeftArrow: \"\\u2199\",\n    LowerRightArrow: \"\\u2198\",\n    loz: \"\\u25ca\",\n    lozenge: \"\\u25ca\",\n    lozf: \"\\u29eb\",\n    lpar: \"(\",\n    lparlt: \"\\u2993\",\n    lrarr: \"\\u21c6\",\n    lrcorner: \"\\u231f\",\n    lrhar: \"\\u21cb\",\n    lrhard: \"\\u296d\",\n    lrm: \"\\u200e\",\n    lrtri: \"\\u22bf\",\n    lsaquo: \"\\u2039\",\n    lscr: \"\\ud835\\udcc1\",\n    Lscr: \"\\u2112\",\n    lsh: \"\\u21b0\",\n    Lsh: \"\\u21b0\",\n    lsim: \"\\u2272\",\n    lsime: \"\\u2a8d\",\n    lsimg: \"\\u2a8f\",\n    lsqb: \"[\",\n    lsquo: \"\\u2018\",\n    lsquor: \"\\u201a\",\n    Lstrok: \"\\u0141\",\n    lstrok: \"\\u0142\",\n    ltcc: \"\\u2aa6\",\n    ltcir: \"\\u2a79\",\n    lt: \"<\",\n    LT: \"<\",\n    Lt: \"\\u226a\",\n    ltdot: \"\\u22d6\",\n    lthree: \"\\u22cb\",\n    ltimes: \"\\u22c9\",\n    ltlarr: \"\\u2976\",\n    ltquest: \"\\u2a7b\",\n    ltri: \"\\u25c3\",\n    ltrie: \"\\u22b4\",\n    ltrif: \"\\u25c2\",\n    ltrPar: \"\\u2996\",\n    lurdshar: \"\\u294a\",\n    luruhar: \"\\u2966\",\n    lvertneqq: \"\\u2268\\ufe00\",\n    lvnE: \"\\u2268\\ufe00\",\n    macr: \"\\xaf\",\n    male: \"\\u2642\",\n    malt: \"\\u2720\",\n    maltese: \"\\u2720\",\n    Map: \"\\u2905\",\n    map: \"\\u21a6\",\n    mapsto: \"\\u21a6\",\n    mapstodown: \"\\u21a7\",\n    mapstoleft: \"\\u21a4\",\n    mapstoup: \"\\u21a5\",\n    marker: \"\\u25ae\",\n    mcomma: \"\\u2a29\",\n    Mcy: \"\\u041c\",\n    mcy: \"\\u043c\",\n    mdash: \"\\u2014\",\n    mDDot: \"\\u223a\",\n    measuredangle: \"\\u2221\",\n    MediumSpace: \"\\u205f\",\n    Mellintrf: \"\\u2133\",\n    Mfr: \"\\ud835\\udd10\",\n    mfr: \"\\ud835\\udd2a\",\n    mho: \"\\u2127\",\n    micro: \"\\xb5\",\n    midast: \"*\",\n    midcir: \"\\u2af0\",\n    mid: \"\\u2223\",\n    middot: \"\\xb7\",\n    minusb: \"\\u229f\",\n    minus: \"\\u2212\",\n    minusd: \"\\u2238\",\n    minusdu: \"\\u2a2a\",\n    MinusPlus: \"\\u2213\",\n    mlcp: \"\\u2adb\",\n    mldr: \"\\u2026\",\n    mnplus: \"\\u2213\",\n    models: \"\\u22a7\",\n    Mopf: \"\\ud835\\udd44\",\n    mopf: \"\\ud835\\udd5e\",\n    mp: \"\\u2213\",\n    mscr: \"\\ud835\\udcc2\",\n    Mscr: \"\\u2133\",\n    mstpos: \"\\u223e\",\n    Mu: \"\\u039c\",\n    mu: \"\\u03bc\",\n    multimap: \"\\u22b8\",\n    mumap: \"\\u22b8\",\n    nabla: \"\\u2207\",\n    Nacute: \"\\u0143\",\n    nacute: \"\\u0144\",\n    nang: \"\\u2220\\u20d2\",\n    nap: \"\\u2249\",\n    napE: \"\\u2a70\\u0338\",\n    napid: \"\\u224b\\u0338\",\n    napos: \"\\u0149\",\n    napprox: \"\\u2249\",\n    natural: \"\\u266e\",\n    naturals: \"\\u2115\",\n    natur: \"\\u266e\",\n    nbsp: \"\\xa0\",\n    nbump: \"\\u224e\\u0338\",\n    nbumpe: \"\\u224f\\u0338\",\n    ncap: \"\\u2a43\",\n    Ncaron: \"\\u0147\",\n    ncaron: \"\\u0148\",\n    Ncedil: \"\\u0145\",\n    ncedil: \"\\u0146\",\n    ncong: \"\\u2247\",\n    ncongdot: \"\\u2a6d\\u0338\",\n    ncup: \"\\u2a42\",\n    Ncy: \"\\u041d\",\n    ncy: \"\\u043d\",\n    ndash: \"\\u2013\",\n    nearhk: \"\\u2924\",\n    nearr: \"\\u2197\",\n    neArr: \"\\u21d7\",\n    nearrow: \"\\u2197\",\n    ne: \"\\u2260\",\n    nedot: \"\\u2250\\u0338\",\n    NegativeMediumSpace: \"\\u200b\",\n    NegativeThickSpace: \"\\u200b\",\n    NegativeThinSpace: \"\\u200b\",\n    NegativeVeryThinSpace: \"\\u200b\",\n    nequiv: \"\\u2262\",\n    nesear: \"\\u2928\",\n    nesim: \"\\u2242\\u0338\",\n    NestedGreaterGreater: \"\\u226b\",\n    NestedLessLess: \"\\u226a\",\n    NewLine: \"\\n\",\n    nexist: \"\\u2204\",\n    nexists: \"\\u2204\",\n    Nfr: \"\\ud835\\udd11\",\n    nfr: \"\\ud835\\udd2b\",\n    ngE: \"\\u2267\\u0338\",\n    nge: \"\\u2271\",\n    ngeq: \"\\u2271\",\n    ngeqq: \"\\u2267\\u0338\",\n    ngeqslant: \"\\u2a7e\\u0338\",\n    nges: \"\\u2a7e\\u0338\",\n    nGg: \"\\u22d9\\u0338\",\n    ngsim: \"\\u2275\",\n    nGt: \"\\u226b\\u20d2\",\n    ngt: \"\\u226f\",\n    ngtr: \"\\u226f\",\n    nGtv: \"\\u226b\\u0338\",\n    nharr: \"\\u21ae\",\n    nhArr: \"\\u21ce\",\n    nhpar: \"\\u2af2\",\n    ni: \"\\u220b\",\n    nis: \"\\u22fc\",\n    nisd: \"\\u22fa\",\n    niv: \"\\u220b\",\n    NJcy: \"\\u040a\",\n    njcy: \"\\u045a\",\n    nlarr: \"\\u219a\",\n    nlArr: \"\\u21cd\",\n    nldr: \"\\u2025\",\n    nlE: \"\\u2266\\u0338\",\n    nle: \"\\u2270\",\n    nleftarrow: \"\\u219a\",\n    nLeftarrow: \"\\u21cd\",\n    nleftrightarrow: \"\\u21ae\",\n    nLeftrightarrow: \"\\u21ce\",\n    nleq: \"\\u2270\",\n    nleqq: \"\\u2266\\u0338\",\n    nleqslant: \"\\u2a7d\\u0338\",\n    nles: \"\\u2a7d\\u0338\",\n    nless: \"\\u226e\",\n    nLl: \"\\u22d8\\u0338\",\n    nlsim: \"\\u2274\",\n    nLt: \"\\u226a\\u20d2\",\n    nlt: \"\\u226e\",\n    nltri: \"\\u22ea\",\n    nltrie: \"\\u22ec\",\n    nLtv: \"\\u226a\\u0338\",\n    nmid: \"\\u2224\",\n    NoBreak: \"\\u2060\",\n    NonBreakingSpace: \"\\xa0\",\n    nopf: \"\\ud835\\udd5f\",\n    Nopf: \"\\u2115\",\n    Not: \"\\u2aec\",\n    not: \"\\xac\",\n    NotCongruent: \"\\u2262\",\n    NotCupCap: \"\\u226d\",\n    NotDoubleVerticalBar: \"\\u2226\",\n    NotElement: \"\\u2209\",\n    NotEqual: \"\\u2260\",\n    NotEqualTilde: \"\\u2242\\u0338\",\n    NotExists: \"\\u2204\",\n    NotGreater: \"\\u226f\",\n    NotGreaterEqual: \"\\u2271\",\n    NotGreaterFullEqual: \"\\u2267\\u0338\",\n    NotGreaterGreater: \"\\u226b\\u0338\",\n    NotGreaterLess: \"\\u2279\",\n    NotGreaterSlantEqual: \"\\u2a7e\\u0338\",\n    NotGreaterTilde: \"\\u2275\",\n    NotHumpDownHump: \"\\u224e\\u0338\",\n    NotHumpEqual: \"\\u224f\\u0338\",\n    notin: \"\\u2209\",\n    notindot: \"\\u22f5\\u0338\",\n    notinE: \"\\u22f9\\u0338\",\n    notinva: \"\\u2209\",\n    notinvb: \"\\u22f7\",\n    notinvc: \"\\u22f6\",\n    NotLeftTriangleBar: \"\\u29cf\\u0338\",\n    NotLeftTriangle: \"\\u22ea\",\n    NotLeftTriangleEqual: \"\\u22ec\",\n    NotLess: \"\\u226e\",\n    NotLessEqual: \"\\u2270\",\n    NotLessGreater: \"\\u2278\",\n    NotLessLess: \"\\u226a\\u0338\",\n    NotLessSlantEqual: \"\\u2a7d\\u0338\",\n    NotLessTilde: \"\\u2274\",\n    NotNestedGreaterGreater: \"\\u2aa2\\u0338\",\n    NotNestedLessLess: \"\\u2aa1\\u0338\",\n    notni: \"\\u220c\",\n    notniva: \"\\u220c\",\n    notnivb: \"\\u22fe\",\n    notnivc: \"\\u22fd\",\n    NotPrecedes: \"\\u2280\",\n    NotPrecedesEqual: \"\\u2aaf\\u0338\",\n    NotPrecedesSlantEqual: \"\\u22e0\",\n    NotReverseElement: \"\\u220c\",\n    NotRightTriangleBar: \"\\u29d0\\u0338\",\n    NotRightTriangle: \"\\u22eb\",\n    NotRightTriangleEqual: \"\\u22ed\",\n    NotSquareSubset: \"\\u228f\\u0338\",\n    NotSquareSubsetEqual: \"\\u22e2\",\n    NotSquareSuperset: \"\\u2290\\u0338\",\n    NotSquareSupersetEqual: \"\\u22e3\",\n    NotSubset: \"\\u2282\\u20d2\",\n    NotSubsetEqual: \"\\u2288\",\n    NotSucceeds: \"\\u2281\",\n    NotSucceedsEqual: \"\\u2ab0\\u0338\",\n    NotSucceedsSlantEqual: \"\\u22e1\",\n    NotSucceedsTilde: \"\\u227f\\u0338\",\n    NotSuperset: \"\\u2283\\u20d2\",\n    NotSupersetEqual: \"\\u2289\",\n    NotTilde: \"\\u2241\",\n    NotTildeEqual: \"\\u2244\",\n    NotTildeFullEqual: \"\\u2247\",\n    NotTildeTilde: \"\\u2249\",\n    NotVerticalBar: \"\\u2224\",\n    nparallel: \"\\u2226\",\n    npar: \"\\u2226\",\n    nparsl: \"\\u2afd\\u20e5\",\n    npart: \"\\u2202\\u0338\",\n    npolint: \"\\u2a14\",\n    npr: \"\\u2280\",\n    nprcue: \"\\u22e0\",\n    nprec: \"\\u2280\",\n    npreceq: \"\\u2aaf\\u0338\",\n    npre: \"\\u2aaf\\u0338\",\n    nrarrc: \"\\u2933\\u0338\",\n    nrarr: \"\\u219b\",\n    nrArr: \"\\u21cf\",\n    nrarrw: \"\\u219d\\u0338\",\n    nrightarrow: \"\\u219b\",\n    nRightarrow: \"\\u21cf\",\n    nrtri: \"\\u22eb\",\n    nrtrie: \"\\u22ed\",\n    nsc: \"\\u2281\",\n    nsccue: \"\\u22e1\",\n    nsce: \"\\u2ab0\\u0338\",\n    Nscr: \"\\ud835\\udca9\",\n    nscr: \"\\ud835\\udcc3\",\n    nshortmid: \"\\u2224\",\n    nshortparallel: \"\\u2226\",\n    nsim: \"\\u2241\",\n    nsime: \"\\u2244\",\n    nsimeq: \"\\u2244\",\n    nsmid: \"\\u2224\",\n    nspar: \"\\u2226\",\n    nsqsube: \"\\u22e2\",\n    nsqsupe: \"\\u22e3\",\n    nsub: \"\\u2284\",\n    nsubE: \"\\u2ac5\\u0338\",\n    nsube: \"\\u2288\",\n    nsubset: \"\\u2282\\u20d2\",\n    nsubseteq: \"\\u2288\",\n    nsubseteqq: \"\\u2ac5\\u0338\",\n    nsucc: \"\\u2281\",\n    nsucceq: \"\\u2ab0\\u0338\",\n    nsup: \"\\u2285\",\n    nsupE: \"\\u2ac6\\u0338\",\n    nsupe: \"\\u2289\",\n    nsupset: \"\\u2283\\u20d2\",\n    nsupseteq: \"\\u2289\",\n    nsupseteqq: \"\\u2ac6\\u0338\",\n    ntgl: \"\\u2279\",\n    Ntilde: \"\\xd1\",\n    ntilde: \"\\xf1\",\n    ntlg: \"\\u2278\",\n    ntriangleleft: \"\\u22ea\",\n    ntrianglelefteq: \"\\u22ec\",\n    ntriangleright: \"\\u22eb\",\n    ntrianglerighteq: \"\\u22ed\",\n    Nu: \"\\u039d\",\n    nu: \"\\u03bd\",\n    num: \"#\",\n    numero: \"\\u2116\",\n    numsp: \"\\u2007\",\n    nvap: \"\\u224d\\u20d2\",\n    nvdash: \"\\u22ac\",\n    nvDash: \"\\u22ad\",\n    nVdash: \"\\u22ae\",\n    nVDash: \"\\u22af\",\n    nvge: \"\\u2265\\u20d2\",\n    nvgt: \">\\u20d2\",\n    nvHarr: \"\\u2904\",\n    nvinfin: \"\\u29de\",\n    nvlArr: \"\\u2902\",\n    nvle: \"\\u2264\\u20d2\",\n    nvlt: \"<\\u20d2\",\n    nvltrie: \"\\u22b4\\u20d2\",\n    nvrArr: \"\\u2903\",\n    nvrtrie: \"\\u22b5\\u20d2\",\n    nvsim: \"\\u223c\\u20d2\",\n    nwarhk: \"\\u2923\",\n    nwarr: \"\\u2196\",\n    nwArr: \"\\u21d6\",\n    nwarrow: \"\\u2196\",\n    nwnear: \"\\u2927\",\n    Oacute: \"\\xd3\",\n    oacute: \"\\xf3\",\n    oast: \"\\u229b\",\n    Ocirc: \"\\xd4\",\n    ocirc: \"\\xf4\",\n    ocir: \"\\u229a\",\n    Ocy: \"\\u041e\",\n    ocy: \"\\u043e\",\n    odash: \"\\u229d\",\n    Odblac: \"\\u0150\",\n    odblac: \"\\u0151\",\n    odiv: \"\\u2a38\",\n    odot: \"\\u2299\",\n    odsold: \"\\u29bc\",\n    OElig: \"\\u0152\",\n    oelig: \"\\u0153\",\n    ofcir: \"\\u29bf\",\n    Ofr: \"\\ud835\\udd12\",\n    ofr: \"\\ud835\\udd2c\",\n    ogon: \"\\u02db\",\n    Ograve: \"\\xd2\",\n    ograve: \"\\xf2\",\n    ogt: \"\\u29c1\",\n    ohbar: \"\\u29b5\",\n    ohm: \"\\u03a9\",\n    oint: \"\\u222e\",\n    olarr: \"\\u21ba\",\n    olcir: \"\\u29be\",\n    olcross: \"\\u29bb\",\n    oline: \"\\u203e\",\n    olt: \"\\u29c0\",\n    Omacr: \"\\u014c\",\n    omacr: \"\\u014d\",\n    Omega: \"\\u03a9\",\n    omega: \"\\u03c9\",\n    Omicron: \"\\u039f\",\n    omicron: \"\\u03bf\",\n    omid: \"\\u29b6\",\n    ominus: \"\\u2296\",\n    Oopf: \"\\ud835\\udd46\",\n    oopf: \"\\ud835\\udd60\",\n    opar: \"\\u29b7\",\n    OpenCurlyDoubleQuote: \"\\u201c\",\n    OpenCurlyQuote: \"\\u2018\",\n    operp: \"\\u29b9\",\n    oplus: \"\\u2295\",\n    orarr: \"\\u21bb\",\n    Or: \"\\u2a54\",\n    or: \"\\u2228\",\n    ord: \"\\u2a5d\",\n    order: \"\\u2134\",\n    orderof: \"\\u2134\",\n    ordf: \"\\xaa\",\n    ordm: \"\\xba\",\n    origof: \"\\u22b6\",\n    oror: \"\\u2a56\",\n    orslope: \"\\u2a57\",\n    orv: \"\\u2a5b\",\n    oS: \"\\u24c8\",\n    Oscr: \"\\ud835\\udcaa\",\n    oscr: \"\\u2134\",\n    Oslash: \"\\xd8\",\n    oslash: \"\\xf8\",\n    osol: \"\\u2298\",\n    Otilde: \"\\xd5\",\n    otilde: \"\\xf5\",\n    otimesas: \"\\u2a36\",\n    Otimes: \"\\u2a37\",\n    otimes: \"\\u2297\",\n    Ouml: \"\\xd6\",\n    ouml: \"\\xf6\",\n    ovbar: \"\\u233d\",\n    OverBar: \"\\u203e\",\n    OverBrace: \"\\u23de\",\n    OverBracket: \"\\u23b4\",\n    OverParenthesis: \"\\u23dc\",\n    para: \"\\xb6\",\n    parallel: \"\\u2225\",\n    par: \"\\u2225\",\n    parsim: \"\\u2af3\",\n    parsl: \"\\u2afd\",\n    part: \"\\u2202\",\n    PartialD: \"\\u2202\",\n    Pcy: \"\\u041f\",\n    pcy: \"\\u043f\",\n    percnt: \"%\",\n    period: \".\",\n    permil: \"\\u2030\",\n    perp: \"\\u22a5\",\n    pertenk: \"\\u2031\",\n    Pfr: \"\\ud835\\udd13\",\n    pfr: \"\\ud835\\udd2d\",\n    Phi: \"\\u03a6\",\n    phi: \"\\u03c6\",\n    phiv: \"\\u03d5\",\n    phmmat: \"\\u2133\",\n    phone: \"\\u260e\",\n    Pi: \"\\u03a0\",\n    pi: \"\\u03c0\",\n    pitchfork: \"\\u22d4\",\n    piv: \"\\u03d6\",\n    planck: \"\\u210f\",\n    planckh: \"\\u210e\",\n    plankv: \"\\u210f\",\n    plusacir: \"\\u2a23\",\n    plusb: \"\\u229e\",\n    pluscir: \"\\u2a22\",\n    plus: \"+\",\n    plusdo: \"\\u2214\",\n    plusdu: \"\\u2a25\",\n    pluse: \"\\u2a72\",\n    PlusMinus: \"\\xb1\",\n    plusmn: \"\\xb1\",\n    plussim: \"\\u2a26\",\n    plustwo: \"\\u2a27\",\n    pm: \"\\xb1\",\n    Poincareplane: \"\\u210c\",\n    pointint: \"\\u2a15\",\n    popf: \"\\ud835\\udd61\",\n    Popf: \"\\u2119\",\n    pound: \"\\xa3\",\n    prap: \"\\u2ab7\",\n    Pr: \"\\u2abb\",\n    pr: \"\\u227a\",\n    prcue: \"\\u227c\",\n    precapprox: \"\\u2ab7\",\n    prec: \"\\u227a\",\n    preccurlyeq: \"\\u227c\",\n    Precedes: \"\\u227a\",\n    PrecedesEqual: \"\\u2aaf\",\n    PrecedesSlantEqual: \"\\u227c\",\n    PrecedesTilde: \"\\u227e\",\n    preceq: \"\\u2aaf\",\n    precnapprox: \"\\u2ab9\",\n    precneqq: \"\\u2ab5\",\n    precnsim: \"\\u22e8\",\n    pre: \"\\u2aaf\",\n    prE: \"\\u2ab3\",\n    precsim: \"\\u227e\",\n    prime: \"\\u2032\",\n    Prime: \"\\u2033\",\n    primes: \"\\u2119\",\n    prnap: \"\\u2ab9\",\n    prnE: \"\\u2ab5\",\n    prnsim: \"\\u22e8\",\n    prod: \"\\u220f\",\n    Product: \"\\u220f\",\n    profalar: \"\\u232e\",\n    profline: \"\\u2312\",\n    profsurf: \"\\u2313\",\n    prop: \"\\u221d\",\n    Proportional: \"\\u221d\",\n    Proportion: \"\\u2237\",\n    propto: \"\\u221d\",\n    prsim: \"\\u227e\",\n    prurel: \"\\u22b0\",\n    Pscr: \"\\ud835\\udcab\",\n    pscr: \"\\ud835\\udcc5\",\n    Psi: \"\\u03a8\",\n    psi: \"\\u03c8\",\n    puncsp: \"\\u2008\",\n    Qfr: \"\\ud835\\udd14\",\n    qfr: \"\\ud835\\udd2e\",\n    qint: \"\\u2a0c\",\n    qopf: \"\\ud835\\udd62\",\n    Qopf: \"\\u211a\",\n    qprime: \"\\u2057\",\n    Qscr: \"\\ud835\\udcac\",\n    qscr: \"\\ud835\\udcc6\",\n    quaternions: \"\\u210d\",\n    quatint: \"\\u2a16\",\n    quest: \"?\",\n    questeq: \"\\u225f\",\n    quot: '\"',\n    QUOT: '\"',\n    rAarr: \"\\u21db\",\n    race: \"\\u223d\\u0331\",\n    Racute: \"\\u0154\",\n    racute: \"\\u0155\",\n    radic: \"\\u221a\",\n    raemptyv: \"\\u29b3\",\n    rang: \"\\u27e9\",\n    Rang: \"\\u27eb\",\n    rangd: \"\\u2992\",\n    range: \"\\u29a5\",\n    rangle: \"\\u27e9\",\n    raquo: \"\\xbb\",\n    rarrap: \"\\u2975\",\n    rarrb: \"\\u21e5\",\n    rarrbfs: \"\\u2920\",\n    rarrc: \"\\u2933\",\n    rarr: \"\\u2192\",\n    Rarr: \"\\u21a0\",\n    rArr: \"\\u21d2\",\n    rarrfs: \"\\u291e\",\n    rarrhk: \"\\u21aa\",\n    rarrlp: \"\\u21ac\",\n    rarrpl: \"\\u2945\",\n    rarrsim: \"\\u2974\",\n    Rarrtl: \"\\u2916\",\n    rarrtl: \"\\u21a3\",\n    rarrw: \"\\u219d\",\n    ratail: \"\\u291a\",\n    rAtail: \"\\u291c\",\n    ratio: \"\\u2236\",\n    rationals: \"\\u211a\",\n    rbarr: \"\\u290d\",\n    rBarr: \"\\u290f\",\n    RBarr: \"\\u2910\",\n    rbbrk: \"\\u2773\",\n    rbrace: \"}\",\n    rbrack: \"]\",\n    rbrke: \"\\u298c\",\n    rbrksld: \"\\u298e\",\n    rbrkslu: \"\\u2990\",\n    Rcaron: \"\\u0158\",\n    rcaron: \"\\u0159\",\n    Rcedil: \"\\u0156\",\n    rcedil: \"\\u0157\",\n    rceil: \"\\u2309\",\n    rcub: \"}\",\n    Rcy: \"\\u0420\",\n    rcy: \"\\u0440\",\n    rdca: \"\\u2937\",\n    rdldhar: \"\\u2969\",\n    rdquo: \"\\u201d\",\n    rdquor: \"\\u201d\",\n    rdsh: \"\\u21b3\",\n    real: \"\\u211c\",\n    realine: \"\\u211b\",\n    realpart: \"\\u211c\",\n    reals: \"\\u211d\",\n    Re: \"\\u211c\",\n    rect: \"\\u25ad\",\n    reg: \"\\xae\",\n    REG: \"\\xae\",\n    ReverseElement: \"\\u220b\",\n    ReverseEquilibrium: \"\\u21cb\",\n    ReverseUpEquilibrium: \"\\u296f\",\n    rfisht: \"\\u297d\",\n    rfloor: \"\\u230b\",\n    rfr: \"\\ud835\\udd2f\",\n    Rfr: \"\\u211c\",\n    rHar: \"\\u2964\",\n    rhard: \"\\u21c1\",\n    rharu: \"\\u21c0\",\n    rharul: \"\\u296c\",\n    Rho: \"\\u03a1\",\n    rho: \"\\u03c1\",\n    rhov: \"\\u03f1\",\n    RightAngleBracket: \"\\u27e9\",\n    RightArrowBar: \"\\u21e5\",\n    rightarrow: \"\\u2192\",\n    RightArrow: \"\\u2192\",\n    Rightarrow: \"\\u21d2\",\n    RightArrowLeftArrow: \"\\u21c4\",\n    rightarrowtail: \"\\u21a3\",\n    RightCeiling: \"\\u2309\",\n    RightDoubleBracket: \"\\u27e7\",\n    RightDownTeeVector: \"\\u295d\",\n    RightDownVectorBar: \"\\u2955\",\n    RightDownVector: \"\\u21c2\",\n    RightFloor: \"\\u230b\",\n    rightharpoondown: \"\\u21c1\",\n    rightharpoonup: \"\\u21c0\",\n    rightleftarrows: \"\\u21c4\",\n    rightleftharpoons: \"\\u21cc\",\n    rightrightarrows: \"\\u21c9\",\n    rightsquigarrow: \"\\u219d\",\n    RightTeeArrow: \"\\u21a6\",\n    RightTee: \"\\u22a2\",\n    RightTeeVector: \"\\u295b\",\n    rightthreetimes: \"\\u22cc\",\n    RightTriangleBar: \"\\u29d0\",\n    RightTriangle: \"\\u22b3\",\n    RightTriangleEqual: \"\\u22b5\",\n    RightUpDownVector: \"\\u294f\",\n    RightUpTeeVector: \"\\u295c\",\n    RightUpVectorBar: \"\\u2954\",\n    RightUpVector: \"\\u21be\",\n    RightVectorBar: \"\\u2953\",\n    RightVector: \"\\u21c0\",\n    ring: \"\\u02da\",\n    risingdotseq: \"\\u2253\",\n    rlarr: \"\\u21c4\",\n    rlhar: \"\\u21cc\",\n    rlm: \"\\u200f\",\n    rmoustache: \"\\u23b1\",\n    rmoust: \"\\u23b1\",\n    rnmid: \"\\u2aee\",\n    roang: \"\\u27ed\",\n    roarr: \"\\u21fe\",\n    robrk: \"\\u27e7\",\n    ropar: \"\\u2986\",\n    ropf: \"\\ud835\\udd63\",\n    Ropf: \"\\u211d\",\n    roplus: \"\\u2a2e\",\n    rotimes: \"\\u2a35\",\n    RoundImplies: \"\\u2970\",\n    rpar: \")\",\n    rpargt: \"\\u2994\",\n    rppolint: \"\\u2a12\",\n    rrarr: \"\\u21c9\",\n    Rrightarrow: \"\\u21db\",\n    rsaquo: \"\\u203a\",\n    rscr: \"\\ud835\\udcc7\",\n    Rscr: \"\\u211b\",\n    rsh: \"\\u21b1\",\n    Rsh: \"\\u21b1\",\n    rsqb: \"]\",\n    rsquo: \"\\u2019\",\n    rsquor: \"\\u2019\",\n    rthree: \"\\u22cc\",\n    rtimes: \"\\u22ca\",\n    rtri: \"\\u25b9\",\n    rtrie: \"\\u22b5\",\n    rtrif: \"\\u25b8\",\n    rtriltri: \"\\u29ce\",\n    RuleDelayed: \"\\u29f4\",\n    ruluhar: \"\\u2968\",\n    rx: \"\\u211e\",\n    Sacute: \"\\u015a\",\n    sacute: \"\\u015b\",\n    sbquo: \"\\u201a\",\n    scap: \"\\u2ab8\",\n    Scaron: \"\\u0160\",\n    scaron: \"\\u0161\",\n    Sc: \"\\u2abc\",\n    sc: \"\\u227b\",\n    sccue: \"\\u227d\",\n    sce: \"\\u2ab0\",\n    scE: \"\\u2ab4\",\n    Scedil: \"\\u015e\",\n    scedil: \"\\u015f\",\n    Scirc: \"\\u015c\",\n    scirc: \"\\u015d\",\n    scnap: \"\\u2aba\",\n    scnE: \"\\u2ab6\",\n    scnsim: \"\\u22e9\",\n    scpolint: \"\\u2a13\",\n    scsim: \"\\u227f\",\n    Scy: \"\\u0421\",\n    scy: \"\\u0441\",\n    sdotb: \"\\u22a1\",\n    sdot: \"\\u22c5\",\n    sdote: \"\\u2a66\",\n    searhk: \"\\u2925\",\n    searr: \"\\u2198\",\n    seArr: \"\\u21d8\",\n    searrow: \"\\u2198\",\n    sect: \"\\xa7\",\n    semi: \";\",\n    seswar: \"\\u2929\",\n    setminus: \"\\u2216\",\n    setmn: \"\\u2216\",\n    sext: \"\\u2736\",\n    Sfr: \"\\ud835\\udd16\",\n    sfr: \"\\ud835\\udd30\",\n    sfrown: \"\\u2322\",\n    sharp: \"\\u266f\",\n    SHCHcy: \"\\u0429\",\n    shchcy: \"\\u0449\",\n    SHcy: \"\\u0428\",\n    shcy: \"\\u0448\",\n    ShortDownArrow: \"\\u2193\",\n    ShortLeftArrow: \"\\u2190\",\n    shortmid: \"\\u2223\",\n    shortparallel: \"\\u2225\",\n    ShortRightArrow: \"\\u2192\",\n    ShortUpArrow: \"\\u2191\",\n    shy: \"\\xad\",\n    Sigma: \"\\u03a3\",\n    sigma: \"\\u03c3\",\n    sigmaf: \"\\u03c2\",\n    sigmav: \"\\u03c2\",\n    sim: \"\\u223c\",\n    simdot: \"\\u2a6a\",\n    sime: \"\\u2243\",\n    simeq: \"\\u2243\",\n    simg: \"\\u2a9e\",\n    simgE: \"\\u2aa0\",\n    siml: \"\\u2a9d\",\n    simlE: \"\\u2a9f\",\n    simne: \"\\u2246\",\n    simplus: \"\\u2a24\",\n    simrarr: \"\\u2972\",\n    slarr: \"\\u2190\",\n    SmallCircle: \"\\u2218\",\n    smallsetminus: \"\\u2216\",\n    smashp: \"\\u2a33\",\n    smeparsl: \"\\u29e4\",\n    smid: \"\\u2223\",\n    smile: \"\\u2323\",\n    smt: \"\\u2aaa\",\n    smte: \"\\u2aac\",\n    smtes: \"\\u2aac\\ufe00\",\n    SOFTcy: \"\\u042c\",\n    softcy: \"\\u044c\",\n    solbar: \"\\u233f\",\n    solb: \"\\u29c4\",\n    sol: \"/\",\n    Sopf: \"\\ud835\\udd4a\",\n    sopf: \"\\ud835\\udd64\",\n    spades: \"\\u2660\",\n    spadesuit: \"\\u2660\",\n    spar: \"\\u2225\",\n    sqcap: \"\\u2293\",\n    sqcaps: \"\\u2293\\ufe00\",\n    sqcup: \"\\u2294\",\n    sqcups: \"\\u2294\\ufe00\",\n    Sqrt: \"\\u221a\",\n    sqsub: \"\\u228f\",\n    sqsube: \"\\u2291\",\n    sqsubset: \"\\u228f\",\n    sqsubseteq: \"\\u2291\",\n    sqsup: \"\\u2290\",\n    sqsupe: \"\\u2292\",\n    sqsupset: \"\\u2290\",\n    sqsupseteq: \"\\u2292\",\n    square: \"\\u25a1\",\n    Square: \"\\u25a1\",\n    SquareIntersection: \"\\u2293\",\n    SquareSubset: \"\\u228f\",\n    SquareSubsetEqual: \"\\u2291\",\n    SquareSuperset: \"\\u2290\",\n    SquareSupersetEqual: \"\\u2292\",\n    SquareUnion: \"\\u2294\",\n    squarf: \"\\u25aa\",\n    squ: \"\\u25a1\",\n    squf: \"\\u25aa\",\n    srarr: \"\\u2192\",\n    Sscr: \"\\ud835\\udcae\",\n    sscr: \"\\ud835\\udcc8\",\n    ssetmn: \"\\u2216\",\n    ssmile: \"\\u2323\",\n    sstarf: \"\\u22c6\",\n    Star: \"\\u22c6\",\n    star: \"\\u2606\",\n    starf: \"\\u2605\",\n    straightepsilon: \"\\u03f5\",\n    straightphi: \"\\u03d5\",\n    strns: \"\\xaf\",\n    sub: \"\\u2282\",\n    Sub: \"\\u22d0\",\n    subdot: \"\\u2abd\",\n    subE: \"\\u2ac5\",\n    sube: \"\\u2286\",\n    subedot: \"\\u2ac3\",\n    submult: \"\\u2ac1\",\n    subnE: \"\\u2acb\",\n    subne: \"\\u228a\",\n    subplus: \"\\u2abf\",\n    subrarr: \"\\u2979\",\n    subset: \"\\u2282\",\n    Subset: \"\\u22d0\",\n    subseteq: \"\\u2286\",\n    subseteqq: \"\\u2ac5\",\n    SubsetEqual: \"\\u2286\",\n    subsetneq: \"\\u228a\",\n    subsetneqq: \"\\u2acb\",\n    subsim: \"\\u2ac7\",\n    subsub: \"\\u2ad5\",\n    subsup: \"\\u2ad3\",\n    succapprox: \"\\u2ab8\",\n    succ: \"\\u227b\",\n    succcurlyeq: \"\\u227d\",\n    Succeeds: \"\\u227b\",\n    SucceedsEqual: \"\\u2ab0\",\n    SucceedsSlantEqual: \"\\u227d\",\n    SucceedsTilde: \"\\u227f\",\n    succeq: \"\\u2ab0\",\n    succnapprox: \"\\u2aba\",\n    succneqq: \"\\u2ab6\",\n    succnsim: \"\\u22e9\",\n    succsim: \"\\u227f\",\n    SuchThat: \"\\u220b\",\n    sum: \"\\u2211\",\n    Sum: \"\\u2211\",\n    sung: \"\\u266a\",\n    sup1: \"\\xb9\",\n    sup2: \"\\xb2\",\n    sup3: \"\\xb3\",\n    sup: \"\\u2283\",\n    Sup: \"\\u22d1\",\n    supdot: \"\\u2abe\",\n    supdsub: \"\\u2ad8\",\n    supE: \"\\u2ac6\",\n    supe: \"\\u2287\",\n    supedot: \"\\u2ac4\",\n    Superset: \"\\u2283\",\n    SupersetEqual: \"\\u2287\",\n    suphsol: \"\\u27c9\",\n    suphsub: \"\\u2ad7\",\n    suplarr: \"\\u297b\",\n    supmult: \"\\u2ac2\",\n    supnE: \"\\u2acc\",\n    supne: \"\\u228b\",\n    supplus: \"\\u2ac0\",\n    supset: \"\\u2283\",\n    Supset: \"\\u22d1\",\n    supseteq: \"\\u2287\",\n    supseteqq: \"\\u2ac6\",\n    supsetneq: \"\\u228b\",\n    supsetneqq: \"\\u2acc\",\n    supsim: \"\\u2ac8\",\n    supsub: \"\\u2ad4\",\n    supsup: \"\\u2ad6\",\n    swarhk: \"\\u2926\",\n    swarr: \"\\u2199\",\n    swArr: \"\\u21d9\",\n    swarrow: \"\\u2199\",\n    swnwar: \"\\u292a\",\n    szlig: \"\\xdf\",\n    Tab: \"\\t\",\n    target: \"\\u2316\",\n    Tau: \"\\u03a4\",\n    tau: \"\\u03c4\",\n    tbrk: \"\\u23b4\",\n    Tcaron: \"\\u0164\",\n    tcaron: \"\\u0165\",\n    Tcedil: \"\\u0162\",\n    tcedil: \"\\u0163\",\n    Tcy: \"\\u0422\",\n    tcy: \"\\u0442\",\n    tdot: \"\\u20db\",\n    telrec: \"\\u2315\",\n    Tfr: \"\\ud835\\udd17\",\n    tfr: \"\\ud835\\udd31\",\n    there4: \"\\u2234\",\n    therefore: \"\\u2234\",\n    Therefore: \"\\u2234\",\n    Theta: \"\\u0398\",\n    theta: \"\\u03b8\",\n    thetasym: \"\\u03d1\",\n    thetav: \"\\u03d1\",\n    thickapprox: \"\\u2248\",\n    thicksim: \"\\u223c\",\n    ThickSpace: \"\\u205f\\u200a\",\n    ThinSpace: \"\\u2009\",\n    thinsp: \"\\u2009\",\n    thkap: \"\\u2248\",\n    thksim: \"\\u223c\",\n    THORN: \"\\xde\",\n    thorn: \"\\xfe\",\n    tilde: \"\\u02dc\",\n    Tilde: \"\\u223c\",\n    TildeEqual: \"\\u2243\",\n    TildeFullEqual: \"\\u2245\",\n    TildeTilde: \"\\u2248\",\n    timesbar: \"\\u2a31\",\n    timesb: \"\\u22a0\",\n    times: \"\\xd7\",\n    timesd: \"\\u2a30\",\n    tint: \"\\u222d\",\n    toea: \"\\u2928\",\n    topbot: \"\\u2336\",\n    topcir: \"\\u2af1\",\n    top: \"\\u22a4\",\n    Topf: \"\\ud835\\udd4b\",\n    topf: \"\\ud835\\udd65\",\n    topfork: \"\\u2ada\",\n    tosa: \"\\u2929\",\n    tprime: \"\\u2034\",\n    trade: \"\\u2122\",\n    TRADE: \"\\u2122\",\n    triangle: \"\\u25b5\",\n    triangledown: \"\\u25bf\",\n    triangleleft: \"\\u25c3\",\n    trianglelefteq: \"\\u22b4\",\n    triangleq: \"\\u225c\",\n    triangleright: \"\\u25b9\",\n    trianglerighteq: \"\\u22b5\",\n    tridot: \"\\u25ec\",\n    trie: \"\\u225c\",\n    triminus: \"\\u2a3a\",\n    TripleDot: \"\\u20db\",\n    triplus: \"\\u2a39\",\n    trisb: \"\\u29cd\",\n    tritime: \"\\u2a3b\",\n    trpezium: \"\\u23e2\",\n    Tscr: \"\\ud835\\udcaf\",\n    tscr: \"\\ud835\\udcc9\",\n    TScy: \"\\u0426\",\n    tscy: \"\\u0446\",\n    TSHcy: \"\\u040b\",\n    tshcy: \"\\u045b\",\n    Tstrok: \"\\u0166\",\n    tstrok: \"\\u0167\",\n    twixt: \"\\u226c\",\n    twoheadleftarrow: \"\\u219e\",\n    twoheadrightarrow: \"\\u21a0\",\n    Uacute: \"\\xda\",\n    uacute: \"\\xfa\",\n    uarr: \"\\u2191\",\n    Uarr: \"\\u219f\",\n    uArr: \"\\u21d1\",\n    Uarrocir: \"\\u2949\",\n    Ubrcy: \"\\u040e\",\n    ubrcy: \"\\u045e\",\n    Ubreve: \"\\u016c\",\n    ubreve: \"\\u016d\",\n    Ucirc: \"\\xdb\",\n    ucirc: \"\\xfb\",\n    Ucy: \"\\u0423\",\n    ucy: \"\\u0443\",\n    udarr: \"\\u21c5\",\n    Udblac: \"\\u0170\",\n    udblac: \"\\u0171\",\n    udhar: \"\\u296e\",\n    ufisht: \"\\u297e\",\n    Ufr: \"\\ud835\\udd18\",\n    ufr: \"\\ud835\\udd32\",\n    Ugrave: \"\\xd9\",\n    ugrave: \"\\xf9\",\n    uHar: \"\\u2963\",\n    uharl: \"\\u21bf\",\n    uharr: \"\\u21be\",\n    uhblk: \"\\u2580\",\n    ulcorn: \"\\u231c\",\n    ulcorner: \"\\u231c\",\n    ulcrop: \"\\u230f\",\n    ultri: \"\\u25f8\",\n    Umacr: \"\\u016a\",\n    umacr: \"\\u016b\",\n    uml: \"\\xa8\",\n    UnderBar: \"_\",\n    UnderBrace: \"\\u23df\",\n    UnderBracket: \"\\u23b5\",\n    UnderParenthesis: \"\\u23dd\",\n    Union: \"\\u22c3\",\n    UnionPlus: \"\\u228e\",\n    Uogon: \"\\u0172\",\n    uogon: \"\\u0173\",\n    Uopf: \"\\ud835\\udd4c\",\n    uopf: \"\\ud835\\udd66\",\n    UpArrowBar: \"\\u2912\",\n    uparrow: \"\\u2191\",\n    UpArrow: \"\\u2191\",\n    Uparrow: \"\\u21d1\",\n    UpArrowDownArrow: \"\\u21c5\",\n    updownarrow: \"\\u2195\",\n    UpDownArrow: \"\\u2195\",\n    Updownarrow: \"\\u21d5\",\n    UpEquilibrium: \"\\u296e\",\n    upharpoonleft: \"\\u21bf\",\n    upharpoonright: \"\\u21be\",\n    uplus: \"\\u228e\",\n    UpperLeftArrow: \"\\u2196\",\n    UpperRightArrow: \"\\u2197\",\n    upsi: \"\\u03c5\",\n    Upsi: \"\\u03d2\",\n    upsih: \"\\u03d2\",\n    Upsilon: \"\\u03a5\",\n    upsilon: \"\\u03c5\",\n    UpTeeArrow: \"\\u21a5\",\n    UpTee: \"\\u22a5\",\n    upuparrows: \"\\u21c8\",\n    urcorn: \"\\u231d\",\n    urcorner: \"\\u231d\",\n    urcrop: \"\\u230e\",\n    Uring: \"\\u016e\",\n    uring: \"\\u016f\",\n    urtri: \"\\u25f9\",\n    Uscr: \"\\ud835\\udcb0\",\n    uscr: \"\\ud835\\udcca\",\n    utdot: \"\\u22f0\",\n    Utilde: \"\\u0168\",\n    utilde: \"\\u0169\",\n    utri: \"\\u25b5\",\n    utrif: \"\\u25b4\",\n    uuarr: \"\\u21c8\",\n    Uuml: \"\\xdc\",\n    uuml: \"\\xfc\",\n    uwangle: \"\\u29a7\",\n    vangrt: \"\\u299c\",\n    varepsilon: \"\\u03f5\",\n    varkappa: \"\\u03f0\",\n    varnothing: \"\\u2205\",\n    varphi: \"\\u03d5\",\n    varpi: \"\\u03d6\",\n    varpropto: \"\\u221d\",\n    varr: \"\\u2195\",\n    vArr: \"\\u21d5\",\n    varrho: \"\\u03f1\",\n    varsigma: \"\\u03c2\",\n    varsubsetneq: \"\\u228a\\ufe00\",\n    varsubsetneqq: \"\\u2acb\\ufe00\",\n    varsupsetneq: \"\\u228b\\ufe00\",\n    varsupsetneqq: \"\\u2acc\\ufe00\",\n    vartheta: \"\\u03d1\",\n    vartriangleleft: \"\\u22b2\",\n    vartriangleright: \"\\u22b3\",\n    vBar: \"\\u2ae8\",\n    Vbar: \"\\u2aeb\",\n    vBarv: \"\\u2ae9\",\n    Vcy: \"\\u0412\",\n    vcy: \"\\u0432\",\n    vdash: \"\\u22a2\",\n    vDash: \"\\u22a8\",\n    Vdash: \"\\u22a9\",\n    VDash: \"\\u22ab\",\n    Vdashl: \"\\u2ae6\",\n    veebar: \"\\u22bb\",\n    vee: \"\\u2228\",\n    Vee: \"\\u22c1\",\n    veeeq: \"\\u225a\",\n    vellip: \"\\u22ee\",\n    verbar: \"|\",\n    Verbar: \"\\u2016\",\n    vert: \"|\",\n    Vert: \"\\u2016\",\n    VerticalBar: \"\\u2223\",\n    VerticalLine: \"|\",\n    VerticalSeparator: \"\\u2758\",\n    VerticalTilde: \"\\u2240\",\n    VeryThinSpace: \"\\u200a\",\n    Vfr: \"\\ud835\\udd19\",\n    vfr: \"\\ud835\\udd33\",\n    vltri: \"\\u22b2\",\n    vnsub: \"\\u2282\\u20d2\",\n    vnsup: \"\\u2283\\u20d2\",\n    Vopf: \"\\ud835\\udd4d\",\n    vopf: \"\\ud835\\udd67\",\n    vprop: \"\\u221d\",\n    vrtri: \"\\u22b3\",\n    Vscr: \"\\ud835\\udcb1\",\n    vscr: \"\\ud835\\udccb\",\n    vsubnE: \"\\u2acb\\ufe00\",\n    vsubne: \"\\u228a\\ufe00\",\n    vsupnE: \"\\u2acc\\ufe00\",\n    vsupne: \"\\u228b\\ufe00\",\n    Vvdash: \"\\u22aa\",\n    vzigzag: \"\\u299a\",\n    Wcirc: \"\\u0174\",\n    wcirc: \"\\u0175\",\n    wedbar: \"\\u2a5f\",\n    wedge: \"\\u2227\",\n    Wedge: \"\\u22c0\",\n    wedgeq: \"\\u2259\",\n    weierp: \"\\u2118\",\n    Wfr: \"\\ud835\\udd1a\",\n    wfr: \"\\ud835\\udd34\",\n    Wopf: \"\\ud835\\udd4e\",\n    wopf: \"\\ud835\\udd68\",\n    wp: \"\\u2118\",\n    wr: \"\\u2240\",\n    wreath: \"\\u2240\",\n    Wscr: \"\\ud835\\udcb2\",\n    wscr: \"\\ud835\\udccc\",\n    xcap: \"\\u22c2\",\n    xcirc: \"\\u25ef\",\n    xcup: \"\\u22c3\",\n    xdtri: \"\\u25bd\",\n    Xfr: \"\\ud835\\udd1b\",\n    xfr: \"\\ud835\\udd35\",\n    xharr: \"\\u27f7\",\n    xhArr: \"\\u27fa\",\n    Xi: \"\\u039e\",\n    xi: \"\\u03be\",\n    xlarr: \"\\u27f5\",\n    xlArr: \"\\u27f8\",\n    xmap: \"\\u27fc\",\n    xnis: \"\\u22fb\",\n    xodot: \"\\u2a00\",\n    Xopf: \"\\ud835\\udd4f\",\n    xopf: \"\\ud835\\udd69\",\n    xoplus: \"\\u2a01\",\n    xotime: \"\\u2a02\",\n    xrarr: \"\\u27f6\",\n    xrArr: \"\\u27f9\",\n    Xscr: \"\\ud835\\udcb3\",\n    xscr: \"\\ud835\\udccd\",\n    xsqcup: \"\\u2a06\",\n    xuplus: \"\\u2a04\",\n    xutri: \"\\u25b3\",\n    xvee: \"\\u22c1\",\n    xwedge: \"\\u22c0\",\n    Yacute: \"\\xdd\",\n    yacute: \"\\xfd\",\n    YAcy: \"\\u042f\",\n    yacy: \"\\u044f\",\n    Ycirc: \"\\u0176\",\n    ycirc: \"\\u0177\",\n    Ycy: \"\\u042b\",\n    ycy: \"\\u044b\",\n    yen: \"\\xa5\",\n    Yfr: \"\\ud835\\udd1c\",\n    yfr: \"\\ud835\\udd36\",\n    YIcy: \"\\u0407\",\n    yicy: \"\\u0457\",\n    Yopf: \"\\ud835\\udd50\",\n    yopf: \"\\ud835\\udd6a\",\n    Yscr: \"\\ud835\\udcb4\",\n    yscr: \"\\ud835\\udcce\",\n    YUcy: \"\\u042e\",\n    yucy: \"\\u044e\",\n    yuml: \"\\xff\",\n    Yuml: \"\\u0178\",\n    Zacute: \"\\u0179\",\n    zacute: \"\\u017a\",\n    Zcaron: \"\\u017d\",\n    zcaron: \"\\u017e\",\n    Zcy: \"\\u0417\",\n    zcy: \"\\u0437\",\n    Zdot: \"\\u017b\",\n    zdot: \"\\u017c\",\n    zeetrf: \"\\u2128\",\n    ZeroWidthSpace: \"\\u200b\",\n    Zeta: \"\\u0396\",\n    zeta: \"\\u03b6\",\n    zfr: \"\\ud835\\udd37\",\n    Zfr: \"\\u2128\",\n    ZHcy: \"\\u0416\",\n    zhcy: \"\\u0436\",\n    zigrarr: \"\\u21dd\",\n    zopf: \"\\ud835\\udd6b\",\n    Zopf: \"\\u2124\",\n    Zscr: \"\\ud835\\udcb5\",\n    zscr: \"\\ud835\\udccf\",\n    zwj: \"\\u200d\",\n    zwnj: \"\\u200c\"\n  };\n  /*eslint quotes:0*/  var entities = require$$0;\n  var regex$4 = /[!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4E\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD803[\\uDF55-\\uDF59]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDC4B-\\uDC4F\\uDC5B\\uDC5D\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDE60-\\uDE6C\\uDF3C-\\uDF3E]|\\uD806[\\uDC3B\\uDE3F-\\uDE46\\uDE9A-\\uDE9C\\uDE9E-\\uDEA2]|\\uD807[\\uDC41-\\uDC45\\uDC70\\uDC71\\uDEF7\\uDEF8]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD81B[\\uDE97-\\uDE9A]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]|\\uD83A[\\uDD5E\\uDD5F]/;\n  var encodeCache = {};\n  // Create a lookup array where anything but characters in `chars` string\n  // and alphanumeric chars is percent-encoded.\n  \n    function getEncodeCache(exclude) {\n    var i, ch, cache = encodeCache[exclude];\n    if (cache) {\n      return cache;\n    }\n    cache = encodeCache[exclude] = [];\n    for (i = 0; i < 128; i++) {\n      ch = String.fromCharCode(i);\n      if (/^[0-9a-z]$/i.test(ch)) {\n        // always allow unencoded alphanumeric characters\n        cache.push(ch);\n      } else {\n        cache.push(\"%\" + (\"0\" + i.toString(16).toUpperCase()).slice(-2));\n      }\n    }\n    for (i = 0; i < exclude.length; i++) {\n      cache[exclude.charCodeAt(i)] = exclude[i];\n    }\n    return cache;\n  }\n  // Encode unsafe characters with percent-encoding, skipping already\n  // encoded sequences.\n  \n  //  - string       - string to encode\n  //  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n  //  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n  \n    function encode$2(string, exclude, keepEscaped) {\n    var i, l, code, nextCode, cache, result = \"\";\n    if (typeof exclude !== \"string\") {\n      // encode(string, keepEscaped)\n      keepEscaped = exclude;\n      exclude = encode$2.defaultChars;\n    }\n    if (typeof keepEscaped === \"undefined\") {\n      keepEscaped = true;\n    }\n    cache = getEncodeCache(exclude);\n    for (i = 0, l = string.length; i < l; i++) {\n      code = string.charCodeAt(i);\n      if (keepEscaped && code === 37 /* % */ && i + 2 < l) {\n        if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n          result += string.slice(i, i + 3);\n          i += 2;\n          continue;\n        }\n      }\n      if (code < 128) {\n        result += cache[code];\n        continue;\n      }\n      if (code >= 55296 && code <= 57343) {\n        if (code >= 55296 && code <= 56319 && i + 1 < l) {\n          nextCode = string.charCodeAt(i + 1);\n          if (nextCode >= 56320 && nextCode <= 57343) {\n            result += encodeURIComponent(string[i] + string[i + 1]);\n            i++;\n            continue;\n          }\n        }\n        result += \"%EF%BF%BD\";\n        continue;\n      }\n      result += encodeURIComponent(string[i]);\n    }\n    return result;\n  }\n  encode$2.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\n  encode$2.componentChars = \"-_.!~*'()\";\n  var encode_1 = encode$2;\n  /* eslint-disable no-bitwise */  var decodeCache = {};\n  function getDecodeCache(exclude) {\n    var i, ch, cache = decodeCache[exclude];\n    if (cache) {\n      return cache;\n    }\n    cache = decodeCache[exclude] = [];\n    for (i = 0; i < 128; i++) {\n      ch = String.fromCharCode(i);\n      cache.push(ch);\n    }\n    for (i = 0; i < exclude.length; i++) {\n      ch = exclude.charCodeAt(i);\n      cache[ch] = \"%\" + (\"0\" + ch.toString(16).toUpperCase()).slice(-2);\n    }\n    return cache;\n  }\n  // Decode percent-encoded string.\n  \n    function decode$2(string, exclude) {\n    var cache;\n    if (typeof exclude !== \"string\") {\n      exclude = decode$2.defaultChars;\n    }\n    cache = getDecodeCache(exclude);\n    return string.replace(/(%[a-f0-9]{2})+/gi, (function(seq) {\n      var i, l, b1, b2, b3, b4, chr, result = \"\";\n      for (i = 0, l = seq.length; i < l; i += 3) {\n        b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n        if (b1 < 128) {\n          result += cache[b1];\n          continue;\n        }\n        if ((b1 & 224) === 192 && i + 3 < l) {\n          // 110xxxxx 10xxxxxx\n          b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n          if ((b2 & 192) === 128) {\n            chr = b1 << 6 & 1984 | b2 & 63;\n            if (chr < 128) {\n              result += \"\\ufffd\\ufffd\";\n            } else {\n              result += String.fromCharCode(chr);\n            }\n            i += 3;\n            continue;\n          }\n        }\n        if ((b1 & 240) === 224 && i + 6 < l) {\n          // 1110xxxx 10xxxxxx 10xxxxxx\n          b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n          b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n          if ((b2 & 192) === 128 && (b3 & 192) === 128) {\n            chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;\n            if (chr < 2048 || chr >= 55296 && chr <= 57343) {\n              result += \"\\ufffd\\ufffd\\ufffd\";\n            } else {\n              result += String.fromCharCode(chr);\n            }\n            i += 6;\n            continue;\n          }\n        }\n        if ((b1 & 248) === 240 && i + 9 < l) {\n          // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n          b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n          b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n          b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n          if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {\n            chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;\n            if (chr < 65536 || chr > 1114111) {\n              result += \"\\ufffd\\ufffd\\ufffd\\ufffd\";\n            } else {\n              chr -= 65536;\n              result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));\n            }\n            i += 9;\n            continue;\n          }\n        }\n        result += \"\\ufffd\";\n      }\n      return result;\n    }));\n  }\n  decode$2.defaultChars = \";/?:@&=+$,#\";\n  decode$2.componentChars = \"\";\n  var decode_1 = decode$2;\n  var format$1 = function format(url) {\n    var result = \"\";\n    result += url.protocol || \"\";\n    result += url.slashes ? \"//\" : \"\";\n    result += url.auth ? url.auth + \"@\" : \"\";\n    if (url.hostname && url.hostname.indexOf(\":\") !== -1) {\n      // ipv6 address\n      result += \"[\" + url.hostname + \"]\";\n    } else {\n      result += url.hostname || \"\";\n    }\n    result += url.port ? \":\" + url.port : \"\";\n    result += url.pathname || \"\";\n    result += url.search || \"\";\n    result += url.hash || \"\";\n    return result;\n  };\n  // Copyright Joyent, Inc. and other Node contributors.\n  \n  // Changes from joyent/node:\n  \n  // 1. No leading slash in paths,\n  //    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n  \n  // 2. Backslashes are not replaced with slashes,\n  //    so `http:\\\\example.org\\` is treated like a relative path\n  \n  // 3. Trailing colon is treated like a part of the path,\n  //    i.e. in `http://example.org:foo` pathname is `:foo`\n  \n  // 4. Nothing is URL-encoded in the resulting object,\n  //    (in joyent/node some chars in auth and paths are encoded)\n  \n  // 5. `url.parse()` does not have `parseQueryString` argument\n  \n  // 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n  //    which can be constructed using other parts of the url.\n  \n    function Url() {\n    this.protocol = null;\n    this.slashes = null;\n    this.auth = null;\n    this.port = null;\n    this.hostname = null;\n    this.hash = null;\n    this.search = null;\n    this.pathname = null;\n  }\n  // Reference: RFC 3986, RFC 1808, RFC 2396\n  // define these here so at least they only have to be\n  // compiled once on the first module load.\n    var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, \n  // Special case for a simple path URL\n  simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/, \n  // RFC 2396: characters reserved for delimiting URLs.\n  // We actually just auto-escape these.\n  delims = [ \"<\", \">\", '\"', \"`\", \" \", \"\\r\", \"\\n\", \"\\t\" ], \n  // RFC 2396: characters not allowed for various reasons.\n  unwise = [ \"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\" ].concat(delims), \n  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n  autoEscape = [ \"'\" ].concat(unwise), \n  // Characters that are never ever allowed in a hostname.\n  // Note that any invalid chars are also handled, but these\n  // are the ones that are *expected* to be seen, so we fast-path\n  // them.\n  nonHostChars = [ \"%\", \"/\", \"?\", \";\", \"#\" ].concat(autoEscape), hostEndingChars = [ \"/\", \"?\", \"#\" ], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, \n  // protocols that can allow \"unsafe\" and \"unwise\" chars.\n  /* eslint-disable no-script-url */\n  // protocols that never have a hostname.\n  hostlessProtocol = {\n    javascript: true,\n    \"javascript:\": true\n  }, \n  // protocols that always contain a // bit.\n  slashedProtocol = {\n    http: true,\n    https: true,\n    ftp: true,\n    gopher: true,\n    file: true,\n    \"http:\": true,\n    \"https:\": true,\n    \"ftp:\": true,\n    \"gopher:\": true,\n    \"file:\": true\n  };\n  /* eslint-enable no-script-url */  function urlParse(url, slashesDenoteHost) {\n    if (url && url instanceof Url) {\n      return url;\n    }\n    var u = new Url;\n    u.parse(url, slashesDenoteHost);\n    return u;\n  }\n  Url.prototype.parse = function(url, slashesDenoteHost) {\n    var i, l, lowerProto, hec, slashes, rest = url;\n    // trim before proceeding.\n    // This is to support parse stuff like \"  http://foo.com  \\n\"\n        rest = rest.trim();\n    if (!slashesDenoteHost && url.split(\"#\").length === 1) {\n      // Try fast path regexp\n      var simplePath = simplePathPattern.exec(rest);\n      if (simplePath) {\n        this.pathname = simplePath[1];\n        if (simplePath[2]) {\n          this.search = simplePath[2];\n        }\n        return this;\n      }\n    }\n    var proto = protocolPattern.exec(rest);\n    if (proto) {\n      proto = proto[0];\n      lowerProto = proto.toLowerCase();\n      this.protocol = proto;\n      rest = rest.substr(proto.length);\n    }\n    // figure out if it's got a host\n    // user@server is *always* interpreted as a hostname, and url\n    // resolution will treat //foo/bar as host=foo,path=bar because that's\n    // how the browser resolves relative URLs.\n        if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n      slashes = rest.substr(0, 2) === \"//\";\n      if (slashes && !(proto && hostlessProtocol[proto])) {\n        rest = rest.substr(2);\n        this.slashes = true;\n      }\n    }\n    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n      // there's a hostname.\n      // the first instance of /, ?, ;, or # ends the host.\n      // If there is an @ in the hostname, then non-host chars *are* allowed\n      // to the left of the last @ sign, unless some host-ending character\n      // comes *before* the @-sign.\n      // URLs are obnoxious.\n      // ex:\n      // http://a@b@c/ => user:a@b host:c\n      // http://a@b?@c => user:a host:c path:/?@c\n      // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n      // Review our test case against browsers more comprehensively.\n      // find the first instance of any hostEndingChars\n      var hostEnd = -1;\n      for (i = 0; i < hostEndingChars.length; i++) {\n        hec = rest.indexOf(hostEndingChars[i]);\n        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n          hostEnd = hec;\n        }\n      }\n      // at this point, either we have an explicit point where the\n      // auth portion cannot go past, or the last @ char is the decider.\n            var auth, atSign;\n      if (hostEnd === -1) {\n        // atSign can be anywhere.\n        atSign = rest.lastIndexOf(\"@\");\n      } else {\n        // atSign must be in auth portion.\n        // http://a@b/c@d => host:b auth:a path:/c@d\n        atSign = rest.lastIndexOf(\"@\", hostEnd);\n      }\n      // Now we have a portion which is definitely the auth.\n      // Pull that off.\n            if (atSign !== -1) {\n        auth = rest.slice(0, atSign);\n        rest = rest.slice(atSign + 1);\n        this.auth = auth;\n      }\n      // the host is the remaining to the left of the first non-host char\n            hostEnd = -1;\n      for (i = 0; i < nonHostChars.length; i++) {\n        hec = rest.indexOf(nonHostChars[i]);\n        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n          hostEnd = hec;\n        }\n      }\n      // if we still have not hit it, then the entire thing is a host.\n            if (hostEnd === -1) {\n        hostEnd = rest.length;\n      }\n      if (rest[hostEnd - 1] === \":\") {\n        hostEnd--;\n      }\n      var host = rest.slice(0, hostEnd);\n      rest = rest.slice(hostEnd);\n      // pull out port.\n            this.parseHost(host);\n      // we've indicated that there is a hostname,\n      // so even if it's empty, it has to be present.\n            this.hostname = this.hostname || \"\";\n      // if hostname begins with [ and ends with ]\n      // assume that it's an IPv6 address.\n            var ipv6Hostname = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n      // validate a little.\n            if (!ipv6Hostname) {\n        var hostparts = this.hostname.split(/\\./);\n        for (i = 0, l = hostparts.length; i < l; i++) {\n          var part = hostparts[i];\n          if (!part) {\n            continue;\n          }\n          if (!part.match(hostnamePartPattern)) {\n            var newpart = \"\";\n            for (var j = 0, k = part.length; j < k; j++) {\n              if (part.charCodeAt(j) > 127) {\n                // we replace non-ASCII char with a temporary placeholder\n                // we need this to make sure size of hostname is not\n                // broken by replacing non-ASCII by nothing\n                newpart += \"x\";\n              } else {\n                newpart += part[j];\n              }\n            }\n            // we test again with ASCII char only\n                        if (!newpart.match(hostnamePartPattern)) {\n              var validParts = hostparts.slice(0, i);\n              var notHost = hostparts.slice(i + 1);\n              var bit = part.match(hostnamePartStart);\n              if (bit) {\n                validParts.push(bit[1]);\n                notHost.unshift(bit[2]);\n              }\n              if (notHost.length) {\n                rest = notHost.join(\".\") + rest;\n              }\n              this.hostname = validParts.join(\".\");\n              break;\n            }\n          }\n        }\n      }\n      if (this.hostname.length > hostnameMaxLen) {\n        this.hostname = \"\";\n      }\n      // strip [ and ] from the hostname\n      // the host field still retains them, though\n            if (ipv6Hostname) {\n        this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      }\n    }\n    // chop off from the tail first.\n        var hash = rest.indexOf(\"#\");\n    if (hash !== -1) {\n      // got a fragment string.\n      this.hash = rest.substr(hash);\n      rest = rest.slice(0, hash);\n    }\n    var qm = rest.indexOf(\"?\");\n    if (qm !== -1) {\n      this.search = rest.substr(qm);\n      rest = rest.slice(0, qm);\n    }\n    if (rest) {\n      this.pathname = rest;\n    }\n    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n      this.pathname = \"\";\n    }\n    return this;\n  };\n  Url.prototype.parseHost = function(host) {\n    var port = portPattern.exec(host);\n    if (port) {\n      port = port[0];\n      if (port !== \":\") {\n        this.port = port.substr(1);\n      }\n      host = host.substr(0, host.length - port.length);\n    }\n    if (host) {\n      this.hostname = host;\n    }\n  };\n  var parse$1 = urlParse;\n  var encode$1 = encode_1;\n  var decode$1 = decode_1;\n  var format = format$1;\n  var parse = parse$1;\n  var mdurl = {\n    encode: encode$1,\n    decode: decode$1,\n    format: format,\n    parse: parse\n  };\n  var regex$3 = /[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n  var regex$2 = /[\\0-\\x1F\\x7F-\\x9F]/;\n  var regex$1 = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/;\n  var regex = /[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/;\n  var Any = regex$3;\n  var Cc = regex$2;\n  var Cf = regex$1;\n  var P = regex$4;\n  var Z = regex;\n  var uc_micro = {\n    Any: Any,\n    Cc: Cc,\n    Cf: Cf,\n    P: P,\n    Z: Z\n  };\n  var utils = createCommonjsModule((function(module, exports) {\n    function _class(obj) {\n      return Object.prototype.toString.call(obj);\n    }\n    function isString(obj) {\n      return _class(obj) === \"[object String]\";\n    }\n    var _hasOwnProperty = Object.prototype.hasOwnProperty;\n    function has(object, key) {\n      return _hasOwnProperty.call(object, key);\n    }\n    // Merge objects\n    \n        function assign(obj /*from1, from2, from3, ...*/) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n      sources.forEach((function(source) {\n        if (!source) {\n          return;\n        }\n        if (typeof source !== \"object\") {\n          throw new TypeError(source + \"must be object\");\n        }\n        Object.keys(source).forEach((function(key) {\n          obj[key] = source[key];\n        }));\n      }));\n      return obj;\n    }\n    // Remove element from array and put another array at those position.\n    // Useful for some operations with tokens\n        function arrayReplaceAt(src, pos, newElements) {\n      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n        function isValidEntityCode(c) {\n      /*eslint no-bitwise:0*/\n      // broken sequence\n      if (c >= 55296 && c <= 57343) {\n        return false;\n      }\n      // never used\n            if (c >= 64976 && c <= 65007) {\n        return false;\n      }\n      if ((c & 65535) === 65535 || (c & 65535) === 65534) {\n        return false;\n      }\n      // control codes\n            if (c >= 0 && c <= 8) {\n        return false;\n      }\n      if (c === 11) {\n        return false;\n      }\n      if (c >= 14 && c <= 31) {\n        return false;\n      }\n      if (c >= 127 && c <= 159) {\n        return false;\n      }\n      // out of range\n            if (c > 1114111) {\n        return false;\n      }\n      return true;\n    }\n    function fromCodePoint(c) {\n      /*eslint no-bitwise:0*/\n      if (c > 65535) {\n        c -= 65536;\n        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);\n        return String.fromCharCode(surrogate1, surrogate2);\n      }\n      return String.fromCharCode(c);\n    }\n    var UNESCAPE_MD_RE = /\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g;\n    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;\n    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + \"|\" + ENTITY_RE.source, \"gi\");\n    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n    function replaceEntityPattern(match, name) {\n      var code = 0;\n      if (has(entities, name)) {\n        return entities[name];\n      }\n      if (name.charCodeAt(0) === 35 /* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n        code = name[1].toLowerCase() === \"x\" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);\n        if (isValidEntityCode(code)) {\n          return fromCodePoint(code);\n        }\n      }\n      return match;\n    }\n    /*function replaceEntities(str) {\n\t  if (str.indexOf('&') < 0) { return str; }\n\n\t  return str.replace(ENTITY_RE, replaceEntityPattern);\n\t}*/    function unescapeMd(str) {\n      if (str.indexOf(\"\\\\\") < 0) {\n        return str;\n      }\n      return str.replace(UNESCAPE_MD_RE, \"$1\");\n    }\n    function unescapeAll(str) {\n      if (str.indexOf(\"\\\\\") < 0 && str.indexOf(\"&\") < 0) {\n        return str;\n      }\n      return str.replace(UNESCAPE_ALL_RE, (function(match, escaped, entity) {\n        if (escaped) {\n          return escaped;\n        }\n        return replaceEntityPattern(match, entity);\n      }));\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n        var HTML_ESCAPE_TEST_RE = /[&<>\"]/;\n    var HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\n    var HTML_REPLACEMENTS = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\"\n    };\n    function replaceUnsafeChar(ch) {\n      return HTML_REPLACEMENTS[ch];\n    }\n    function escapeHtml(str) {\n      if (HTML_ESCAPE_TEST_RE.test(str)) {\n        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n      }\n      return str;\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n        var REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g;\n    function escapeRE(str) {\n      return str.replace(REGEXP_ESCAPE_RE, \"\\\\$&\");\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n        function isSpace(code) {\n      switch (code) {\n       case 9:\n       case 32:\n        return true;\n      }\n      return false;\n    }\n    // Zs (unicode class) || [\\t\\f\\v\\r\\n]\n        function isWhiteSpace(code) {\n      if (code >= 8192 && code <= 8202) {\n        return true;\n      }\n      switch (code) {\n       case 9:\n // \\t\n               case 10:\n // \\n\n               case 11:\n // \\v\n               case 12:\n // \\f\n               case 13:\n // \\r\n               case 32:\n       case 160:\n       case 5760:\n       case 8239:\n       case 8287:\n       case 12288:\n        return true;\n      }\n      return false;\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n    /*eslint-disable max-len*/\n    // Currently without astral characters support.\n        function isPunctChar(ch) {\n      return regex$4.test(ch);\n    }\n    // Markdown ASCII punctuation characters.\n    \n    // !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n    // http://spec.commonmark.org/0.15/#ascii-punctuation-character\n    \n    // Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n    \n        function isMdAsciiPunct(ch) {\n      switch (ch) {\n       case 33 /* ! */ :\n       case 34 /* \" */ :\n       case 35 /* # */ :\n       case 36 /* $ */ :\n       case 37 /* % */ :\n       case 38 /* & */ :\n       case 39 /* ' */ :\n       case 40 /* ( */ :\n       case 41 /* ) */ :\n       case 42 /* * */ :\n       case 43 /* + */ :\n       case 44 /* , */ :\n       case 45 /* - */ :\n       case 46 /* . */ :\n       case 47 /* / */ :\n       case 58 /* : */ :\n       case 59 /* ; */ :\n       case 60 /* < */ :\n       case 61 /* = */ :\n       case 62 /* > */ :\n       case 63 /* ? */ :\n       case 64 /* @ */ :\n       case 91 /* [ */ :\n       case 92 /* \\ */ :\n       case 93 /* ] */ :\n       case 94 /* ^ */ :\n       case 95 /* _ */ :\n       case 96 /* ` */ :\n       case 123 /* { */ :\n       case 124 /* | */ :\n       case 125 /* } */ :\n       case 126 /* ~ */ :\n        return true;\n\n       default:\n        return false;\n      }\n    }\n    // Hepler to unify [reference labels].\n    \n        function normalizeReference(str) {\n      // Trim and collapse whitespace\n      str = str.trim().replace(/\\s+/g, \" \");\n      // In node v10 ''.toLowerCase() === '', which is presumed to be a bug\n      // fixed in v12 (couldn't find any details).\n      \n      // So treat this one as a special case\n      // (remove this when node v10 is no longer supported).\n      \n            if (\"\\u1e9e\".toLowerCase() === \"\\u1e7e\") {\n        str = str.replace(/\\u1e9e/g, \"\\xdf\");\n      }\n      // .toLowerCase().toUpperCase() should get rid of all differences\n      // between letter variants.\n      \n      // Simple .toLowerCase() doesn't normalize 125 code points correctly,\n      // and .toUpperCase doesn't normalize 6 of them (list of exceptions:\n      // , , , , ,  - those are already uppercased, but have differently\n      // uppercased versions).\n      \n      // Here's an example showing how it happens. Lets take greek letter omega:\n      // uppercase U+0398 (), U+03f4 () and lowercase U+03b8 (), U+03d1 ()\n      \n      // Unicode entries:\n      // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;\n      // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398\n      // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398\n      // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;\n      \n      // Case-insensitive comparison should treat all of them as equivalent.\n      \n      // But .toLowerCase() doesn't change  (it's already lowercase),\n      // and .toUpperCase() doesn't change  (already uppercase).\n      \n      // Applying first lower then upper case normalizes any character:\n      // '\\u0398\\u03f4\\u03b8\\u03d1'.toLowerCase().toUpperCase() === '\\u0398\\u0398\\u0398\\u0398'\n      \n      // Note: this is equivalent to unicode case folding; unicode normalization\n      // is a different step that is not required here.\n      \n      // Final result should be uppercased, because it's later stored in an object\n      // (this avoid a conflict with Object.prototype members,\n      // most notably, `__proto__`)\n      \n            return str.toLowerCase().toUpperCase();\n    }\n    ////////////////////////////////////////////////////////////////////////////////\n    // Re-export libraries commonly used in both markdown-it and its plugins,\n    // so plugins won't have to depend on them explicitly, which reduces their\n    // bundled size (e.g. a browser build).\n    \n        exports.lib = {};\n    exports.lib.mdurl = mdurl;\n    exports.lib.ucmicro = uc_micro;\n    exports.assign = assign;\n    exports.isString = isString;\n    exports.has = has;\n    exports.unescapeMd = unescapeMd;\n    exports.unescapeAll = unescapeAll;\n    exports.isValidEntityCode = isValidEntityCode;\n    exports.fromCodePoint = fromCodePoint;\n    // exports.replaceEntities     = replaceEntities;\n        exports.escapeHtml = escapeHtml;\n    exports.arrayReplaceAt = arrayReplaceAt;\n    exports.isSpace = isSpace;\n    exports.isWhiteSpace = isWhiteSpace;\n    exports.isMdAsciiPunct = isMdAsciiPunct;\n    exports.isPunctChar = isPunctChar;\n    exports.escapeRE = escapeRE;\n    exports.normalizeReference = normalizeReference;\n  }));\n  // Parse link label\n    var parse_link_label = function parseLinkLabel(state, start, disableNested) {\n    var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;\n    state.pos = start + 1;\n    level = 1;\n    while (state.pos < max) {\n      marker = state.src.charCodeAt(state.pos);\n      if (marker === 93 /* ] */) {\n        level--;\n        if (level === 0) {\n          found = true;\n          break;\n        }\n      }\n      prevPos = state.pos;\n      state.md.inline.skipToken(state);\n      if (marker === 91 /* [ */) {\n        if (prevPos === state.pos - 1) {\n          // increase level if we find text `[`, which is not a part of any token\n          level++;\n        } else if (disableNested) {\n          state.pos = oldPos;\n          return -1;\n        }\n      }\n    }\n    if (found) {\n      labelEnd = state.pos;\n    }\n    // restore old state\n        state.pos = oldPos;\n    return labelEnd;\n  };\n  var unescapeAll$2 = utils.unescapeAll;\n  var parse_link_destination = function parseLinkDestination(str, pos, max) {\n    var code, level, lines = 0, start = pos, result = {\n      ok: false,\n      pos: 0,\n      lines: 0,\n      str: \"\"\n    };\n    if (str.charCodeAt(pos) === 60 /* < */) {\n      pos++;\n      while (pos < max) {\n        code = str.charCodeAt(pos);\n        if (code === 10 /* \\n */) {\n          return result;\n        }\n        if (code === 60 /* < */) {\n          return result;\n        }\n        if (code === 62 /* > */) {\n          result.pos = pos + 1;\n          result.str = unescapeAll$2(str.slice(start + 1, pos));\n          result.ok = true;\n          return result;\n        }\n        if (code === 92 /* \\ */ && pos + 1 < max) {\n          pos += 2;\n          continue;\n        }\n        pos++;\n      }\n      // no closing '>'\n            return result;\n    }\n    // this should be ... } else { ... branch\n        level = 0;\n    while (pos < max) {\n      code = str.charCodeAt(pos);\n      if (code === 32) {\n        break;\n      }\n      // ascii control characters\n            if (code < 32 || code === 127) {\n        break;\n      }\n      if (code === 92 /* \\ */ && pos + 1 < max) {\n        if (str.charCodeAt(pos + 1) === 32) {\n          break;\n        }\n        pos += 2;\n        continue;\n      }\n      if (code === 40 /* ( */) {\n        level++;\n        if (level > 32) {\n          return result;\n        }\n      }\n      if (code === 41 /* ) */) {\n        if (level === 0) {\n          break;\n        }\n        level--;\n      }\n      pos++;\n    }\n    if (start === pos) {\n      return result;\n    }\n    if (level !== 0) {\n      return result;\n    }\n    result.str = unescapeAll$2(str.slice(start, pos));\n    result.lines = lines;\n    result.pos = pos;\n    result.ok = true;\n    return result;\n  };\n  var unescapeAll$1 = utils.unescapeAll;\n  var parse_link_title = function parseLinkTitle(str, pos, max) {\n    var code, marker, lines = 0, start = pos, result = {\n      ok: false,\n      pos: 0,\n      lines: 0,\n      str: \"\"\n    };\n    if (pos >= max) {\n      return result;\n    }\n    marker = str.charCodeAt(pos);\n    if (marker !== 34 /* \" */ && marker !== 39 /* ' */ && marker !== 40 /* ( */) {\n      return result;\n    }\n    pos++;\n    // if opening marker is \"(\", switch it to closing marker \")\"\n        if (marker === 40) {\n      marker = 41;\n    }\n    while (pos < max) {\n      code = str.charCodeAt(pos);\n      if (code === marker) {\n        result.pos = pos + 1;\n        result.lines = lines;\n        result.str = unescapeAll$1(str.slice(start + 1, pos));\n        result.ok = true;\n        return result;\n      } else if (code === 40 /* ( */ && marker === 41 /* ) */) {\n        return result;\n      } else if (code === 10) {\n        lines++;\n      } else if (code === 92 /* \\ */ && pos + 1 < max) {\n        pos++;\n        if (str.charCodeAt(pos) === 10) {\n          lines++;\n        }\n      }\n      pos++;\n    }\n    return result;\n  };\n  var parseLinkLabel = parse_link_label;\n  var parseLinkDestination = parse_link_destination;\n  var parseLinkTitle = parse_link_title;\n  var helpers = {\n    parseLinkLabel: parseLinkLabel,\n    parseLinkDestination: parseLinkDestination,\n    parseLinkTitle: parseLinkTitle\n  };\n  var assign$1 = utils.assign;\n  var unescapeAll = utils.unescapeAll;\n  var escapeHtml = utils.escapeHtml;\n  ////////////////////////////////////////////////////////////////////////////////\n    var default_rules = {};\n  default_rules.code_inline = function(tokens, idx, options, env, slf) {\n    var token = tokens[idx];\n    return \"<code\" + slf.renderAttrs(token) + \">\" + escapeHtml(tokens[idx].content) + \"</code>\";\n  };\n  default_rules.code_block = function(tokens, idx, options, env, slf) {\n    var token = tokens[idx];\n    return \"<pre\" + slf.renderAttrs(token) + \"><code>\" + escapeHtml(tokens[idx].content) + \"</code></pre>\\n\";\n  };\n  default_rules.fence = function(tokens, idx, options, env, slf) {\n    var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : \"\", langName = \"\", langAttrs = \"\", highlighted, i, arr, tmpAttrs, tmpToken;\n    if (info) {\n      arr = info.split(/(\\s+)/g);\n      langName = arr[0];\n      langAttrs = arr.slice(2).join(\"\");\n    }\n    if (options.highlight) {\n      highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);\n    } else {\n      highlighted = escapeHtml(token.content);\n    }\n    if (highlighted.indexOf(\"<pre\") === 0) {\n      return highlighted + \"\\n\";\n    }\n    // If language exists, inject class gently, without modifying original token.\n    // May be, one day we will add .deepClone() for token and simplify this part, but\n    // now we prefer to keep things local.\n        if (info) {\n      i = token.attrIndex(\"class\");\n      tmpAttrs = token.attrs ? token.attrs.slice() : [];\n      if (i < 0) {\n        tmpAttrs.push([ \"class\", options.langPrefix + langName ]);\n      } else {\n        tmpAttrs[i] = tmpAttrs[i].slice();\n        tmpAttrs[i][1] += \" \" + options.langPrefix + langName;\n      }\n      // Fake token just to render attributes\n            tmpToken = {\n        attrs: tmpAttrs\n      };\n      return \"<pre><code\" + slf.renderAttrs(tmpToken) + \">\" + highlighted + \"</code></pre>\\n\";\n    }\n    return \"<pre><code\" + slf.renderAttrs(token) + \">\" + highlighted + \"</code></pre>\\n\";\n  };\n  default_rules.image = function(tokens, idx, options, env, slf) {\n    var token = tokens[idx];\n    // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n    // should be placed on proper position for tests.\n    \n    // Replace content with actual value\n        token.attrs[token.attrIndex(\"alt\")][1] = slf.renderInlineAsText(token.children, options, env);\n    return slf.renderToken(tokens, idx, options);\n  };\n  default_rules.hardbreak = function(tokens, idx, options /*, env */) {\n    return options.xhtmlOut ? \"<br />\\n\" : \"<br>\\n\";\n  };\n  default_rules.softbreak = function(tokens, idx, options /*, env */) {\n    return options.breaks ? options.xhtmlOut ? \"<br />\\n\" : \"<br>\\n\" : \"\\n\";\n  };\n  default_rules.text = function(tokens, idx /*, options, env */) {\n    return escapeHtml(tokens[idx].content);\n  };\n  default_rules.html_block = function(tokens, idx /*, options, env */) {\n    return tokens[idx].content;\n  };\n  default_rules.html_inline = function(tokens, idx /*, options, env */) {\n    return tokens[idx].content;\n  };\n  /**\n\t * new Renderer()\n\t *\n\t * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n\t **/  function Renderer() {\n    /**\n\t   * Renderer#rules -> Object\n\t   *\n\t   * Contains render rules for tokens. Can be updated and extended.\n\t   *\n\t   * ##### Example\n\t   *\n\t   * ```javascript\n\t   * var md = require('markdown-it')();\n\t   *\n\t   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n\t   * md.renderer.rules.strong_close = function () { return '</b>'; };\n\t   *\n\t   * var result = md.renderInline(...);\n\t   * ```\n\t   *\n\t   * Each rule is called as independent static function with fixed signature:\n\t   *\n\t   * ```javascript\n\t   * function my_token_render(tokens, idx, options, env, renderer) {\n\t   *   // ...\n\t   *   return renderedHTML;\n\t   * }\n\t   * ```\n\t   *\n\t   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n\t   * for more details and examples.\n\t   **/\n    this.rules = assign$1({}, default_rules);\n  }\n  /**\n\t * Renderer.renderAttrs(token) -> String\n\t *\n\t * Render token attributes to string.\n\t **/  Renderer.prototype.renderAttrs = function renderAttrs(token) {\n    var i, l, result;\n    if (!token.attrs) {\n      return \"\";\n    }\n    result = \"\";\n    for (i = 0, l = token.attrs.length; i < l; i++) {\n      result += \" \" + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n    }\n    return result;\n  };\n  /**\n\t * Renderer.renderToken(tokens, idx, options) -> String\n\t * - tokens (Array): list of tokens\n\t * - idx (Numbed): token index to render\n\t * - options (Object): params of parser instance\n\t *\n\t * Default token renderer. Can be overriden by custom function\n\t * in [[Renderer#rules]].\n\t **/  Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n    var nextToken, result = \"\", needLf = false, token = tokens[idx];\n    // Tight list paragraphs\n        if (token.hidden) {\n      return \"\";\n    }\n    // Insert a newline between hidden paragraph and subsequent opening\n    // block-level tag.\n    \n    // For example, here we should insert a newline before blockquote:\n    //  - a\n    //    >\n    \n        if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n      result += \"\\n\";\n    }\n    // Add token name, e.g. `<img`\n        result += (token.nesting === -1 ? \"</\" : \"<\") + token.tag;\n    // Encode attributes, e.g. `<img src=\"foo\"`\n        result += this.renderAttrs(token);\n    // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n        if (token.nesting === 0 && options.xhtmlOut) {\n      result += \" /\";\n    }\n    // Check if we need to add a newline after this tag\n        if (token.block) {\n      needLf = true;\n      if (token.nesting === 1) {\n        if (idx + 1 < tokens.length) {\n          nextToken = tokens[idx + 1];\n          if (nextToken.type === \"inline\" || nextToken.hidden) {\n            // Block-level tag containing an inline tag.\n            needLf = false;\n          } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n            // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n            needLf = false;\n          }\n        }\n      }\n    }\n    result += needLf ? \">\\n\" : \">\";\n    return result;\n  };\n  /**\n\t * Renderer.renderInline(tokens, options, env) -> String\n\t * - tokens (Array): list on block tokens to render\n\t * - options (Object): params of parser instance\n\t * - env (Object): additional data from parsed input (references, for example)\n\t *\n\t * The same as [[Renderer.render]], but for single token of `inline` type.\n\t **/  Renderer.prototype.renderInline = function(tokens, options, env) {\n    var type, result = \"\", rules = this.rules;\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      type = tokens[i].type;\n      if (typeof rules[type] !== \"undefined\") {\n        result += rules[type](tokens, i, options, env, this);\n      } else {\n        result += this.renderToken(tokens, i, options);\n      }\n    }\n    return result;\n  };\n  /** internal\n\t * Renderer.renderInlineAsText(tokens, options, env) -> String\n\t * - tokens (Array): list on block tokens to render\n\t * - options (Object): params of parser instance\n\t * - env (Object): additional data from parsed input (references, for example)\n\t *\n\t * Special kludge for image `alt` attributes to conform CommonMark spec.\n\t * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n\t * instead of simple escaping.\n\t **/  Renderer.prototype.renderInlineAsText = function(tokens, options, env) {\n    var result = \"\";\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      if (tokens[i].type === \"text\") {\n        result += tokens[i].content;\n      } else if (tokens[i].type === \"image\") {\n        result += this.renderInlineAsText(tokens[i].children, options, env);\n      } else if (tokens[i].type === \"softbreak\") {\n        result += \"\\n\";\n      }\n    }\n    return result;\n  };\n  /**\n\t * Renderer.render(tokens, options, env) -> String\n\t * - tokens (Array): list on block tokens to render\n\t * - options (Object): params of parser instance\n\t * - env (Object): additional data from parsed input (references, for example)\n\t *\n\t * Takes token stream and generates HTML. Probably, you will never need to call\n\t * this method directly.\n\t **/  Renderer.prototype.render = function(tokens, options, env) {\n    var i, len, type, result = \"\", rules = this.rules;\n    for (i = 0, len = tokens.length; i < len; i++) {\n      type = tokens[i].type;\n      if (type === \"inline\") {\n        result += this.renderInline(tokens[i].children, options, env);\n      } else if (typeof rules[type] !== \"undefined\") {\n        result += rules[tokens[i].type](tokens, i, options, env, this);\n      } else {\n        result += this.renderToken(tokens, i, options, env);\n      }\n    }\n    return result;\n  };\n  var renderer = Renderer;\n  /**\n\t * class Ruler\n\t *\n\t * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\n\t * [[MarkdownIt#inline]] to manage sequences of functions (rules):\n\t *\n\t * - keep rules in defined order\n\t * - assign the name to each rule\n\t * - enable/disable rules\n\t * - add/replace rules\n\t * - allow assign rules to additional named chains (in the same)\n\t * - cacheing lists of active rules\n\t *\n\t * You will not need use this class directly until write plugins. For simple\n\t * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\n\t * [[MarkdownIt.use]].\n\t **/\n  /**\n\t * new Ruler()\n\t **/  function Ruler() {\n    // List of added rules. Each element is:\n    // {\n    //   name: XXX,\n    //   enabled: Boolean,\n    //   fn: Function(),\n    //   alt: [ name2, name3 ]\n    // }\n    this.__rules__ = [];\n    // Cached rule chains.\n    \n    // First level - chain name, '' for default.\n    // Second level - diginal anchor for fast filtering by charcodes.\n    \n        this.__cache__ = null;\n  }\n  ////////////////////////////////////////////////////////////////////////////////\n  // Helper methods, should not be used directly\n  // Find rule index by name\n  \n    Ruler.prototype.__find__ = function(name) {\n    for (var i = 0; i < this.__rules__.length; i++) {\n      if (this.__rules__[i].name === name) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  // Build rules lookup cache\n  \n    Ruler.prototype.__compile__ = function() {\n    var self = this;\n    var chains = [ \"\" ];\n    // collect unique names\n        self.__rules__.forEach((function(rule) {\n      if (!rule.enabled) {\n        return;\n      }\n      rule.alt.forEach((function(altName) {\n        if (chains.indexOf(altName) < 0) {\n          chains.push(altName);\n        }\n      }));\n    }));\n    self.__cache__ = {};\n    chains.forEach((function(chain) {\n      self.__cache__[chain] = [];\n      self.__rules__.forEach((function(rule) {\n        if (!rule.enabled) {\n          return;\n        }\n        if (chain && rule.alt.indexOf(chain) < 0) {\n          return;\n        }\n        self.__cache__[chain].push(rule.fn);\n      }));\n    }));\n  };\n  /**\n\t * Ruler.at(name, fn [, options])\n\t * - name (String): rule name to replace.\n\t * - fn (Function): new rule function.\n\t * - options (Object): new rule options (not mandatory).\n\t *\n\t * Replace rule by name with new function & options. Throws error if name not\n\t * found.\n\t *\n\t * ##### Options:\n\t *\n\t * - __alt__ - array with names of \"alternate\" chains.\n\t *\n\t * ##### Example\n\t *\n\t * Replace existing typographer replacement rule with new one:\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')();\n\t *\n\t * md.core.ruler.at('replacements', function replace(state) {\n\t *   //...\n\t * });\n\t * ```\n\t **/  Ruler.prototype.at = function(name, fn, options) {\n    var index = this.__find__(name);\n    var opt = options || {};\n    if (index === -1) {\n      throw new Error(\"Parser rule not found: \" + name);\n    }\n    this.__rules__[index].fn = fn;\n    this.__rules__[index].alt = opt.alt || [];\n    this.__cache__ = null;\n  };\n  /**\n\t * Ruler.before(beforeName, ruleName, fn [, options])\n\t * - beforeName (String): new rule will be added before this one.\n\t * - ruleName (String): name of added rule.\n\t * - fn (Function): rule function.\n\t * - options (Object): rule options (not mandatory).\n\t *\n\t * Add new rule to chain before one with given name. See also\n\t * [[Ruler.after]], [[Ruler.push]].\n\t *\n\t * ##### Options:\n\t *\n\t * - __alt__ - array with names of \"alternate\" chains.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')();\n\t *\n\t * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n\t *   //...\n\t * });\n\t * ```\n\t **/  Ruler.prototype.before = function(beforeName, ruleName, fn, options) {\n    var index = this.__find__(beforeName);\n    var opt = options || {};\n    if (index === -1) {\n      throw new Error(\"Parser rule not found: \" + beforeName);\n    }\n    this.__rules__.splice(index, 0, {\n      name: ruleName,\n      enabled: true,\n      fn: fn,\n      alt: opt.alt || []\n    });\n    this.__cache__ = null;\n  };\n  /**\n\t * Ruler.after(afterName, ruleName, fn [, options])\n\t * - afterName (String): new rule will be added after this one.\n\t * - ruleName (String): name of added rule.\n\t * - fn (Function): rule function.\n\t * - options (Object): rule options (not mandatory).\n\t *\n\t * Add new rule to chain after one with given name. See also\n\t * [[Ruler.before]], [[Ruler.push]].\n\t *\n\t * ##### Options:\n\t *\n\t * - __alt__ - array with names of \"alternate\" chains.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')();\n\t *\n\t * md.inline.ruler.after('text', 'my_rule', function replace(state) {\n\t *   //...\n\t * });\n\t * ```\n\t **/  Ruler.prototype.after = function(afterName, ruleName, fn, options) {\n    var index = this.__find__(afterName);\n    var opt = options || {};\n    if (index === -1) {\n      throw new Error(\"Parser rule not found: \" + afterName);\n    }\n    this.__rules__.splice(index + 1, 0, {\n      name: ruleName,\n      enabled: true,\n      fn: fn,\n      alt: opt.alt || []\n    });\n    this.__cache__ = null;\n  };\n  /**\n\t * Ruler.push(ruleName, fn [, options])\n\t * - ruleName (String): name of added rule.\n\t * - fn (Function): rule function.\n\t * - options (Object): rule options (not mandatory).\n\t *\n\t * Push new rule to the end of chain. See also\n\t * [[Ruler.before]], [[Ruler.after]].\n\t *\n\t * ##### Options:\n\t *\n\t * - __alt__ - array with names of \"alternate\" chains.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')();\n\t *\n\t * md.core.ruler.push('my_rule', function replace(state) {\n\t *   //...\n\t * });\n\t * ```\n\t **/  Ruler.prototype.push = function(ruleName, fn, options) {\n    var opt = options || {};\n    this.__rules__.push({\n      name: ruleName,\n      enabled: true,\n      fn: fn,\n      alt: opt.alt || []\n    });\n    this.__cache__ = null;\n  };\n  /**\n\t * Ruler.enable(list [, ignoreInvalid]) -> Array\n\t * - list (String|Array): list of rule names to enable.\n\t * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n\t *\n\t * Enable rules with given names. If any rule name not found - throw Error.\n\t * Errors can be disabled by second param.\n\t *\n\t * Returns list of found rule names (if no exception happened).\n\t *\n\t * See also [[Ruler.disable]], [[Ruler.enableOnly]].\n\t **/  Ruler.prototype.enable = function(list, ignoreInvalid) {\n    if (!Array.isArray(list)) {\n      list = [ list ];\n    }\n    var result = [];\n    // Search by name and enable\n        list.forEach((function(name) {\n      var idx = this.__find__(name);\n      if (idx < 0) {\n        if (ignoreInvalid) {\n          return;\n        }\n        throw new Error(\"Rules manager: invalid rule name \" + name);\n      }\n      this.__rules__[idx].enabled = true;\n      result.push(name);\n    }), this);\n    this.__cache__ = null;\n    return result;\n  };\n  /**\n\t * Ruler.enableOnly(list [, ignoreInvalid])\n\t * - list (String|Array): list of rule names to enable (whitelist).\n\t * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n\t *\n\t * Enable rules with given names, and disable everything else. If any rule name\n\t * not found - throw Error. Errors can be disabled by second param.\n\t *\n\t * See also [[Ruler.disable]], [[Ruler.enable]].\n\t **/  Ruler.prototype.enableOnly = function(list, ignoreInvalid) {\n    if (!Array.isArray(list)) {\n      list = [ list ];\n    }\n    this.__rules__.forEach((function(rule) {\n      rule.enabled = false;\n    }));\n    this.enable(list, ignoreInvalid);\n  };\n  /**\n\t * Ruler.disable(list [, ignoreInvalid]) -> Array\n\t * - list (String|Array): list of rule names to disable.\n\t * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n\t *\n\t * Disable rules with given names. If any rule name not found - throw Error.\n\t * Errors can be disabled by second param.\n\t *\n\t * Returns list of found rule names (if no exception happened).\n\t *\n\t * See also [[Ruler.enable]], [[Ruler.enableOnly]].\n\t **/  Ruler.prototype.disable = function(list, ignoreInvalid) {\n    if (!Array.isArray(list)) {\n      list = [ list ];\n    }\n    var result = [];\n    // Search by name and disable\n        list.forEach((function(name) {\n      var idx = this.__find__(name);\n      if (idx < 0) {\n        if (ignoreInvalid) {\n          return;\n        }\n        throw new Error(\"Rules manager: invalid rule name \" + name);\n      }\n      this.__rules__[idx].enabled = false;\n      result.push(name);\n    }), this);\n    this.__cache__ = null;\n    return result;\n  };\n  /**\n\t * Ruler.getRules(chainName) -> Array\n\t *\n\t * Return array of active functions (rules) for given chain name. It analyzes\n\t * rules configuration, compiles caches if not exists and returns result.\n\t *\n\t * Default chain name is `''` (empty string). It can't be skipped. That's\n\t * done intentionally, to keep signature monomorphic for high speed.\n\t **/  Ruler.prototype.getRules = function(chainName) {\n    if (this.__cache__ === null) {\n      this.__compile__();\n    }\n    // Chain can be empty, if rules disabled. But we still have to return Array.\n        return this.__cache__[chainName] || [];\n  };\n  var ruler = Ruler;\n  // Normalize input string\n  // https://spec.commonmark.org/0.29/#line-ending\n    var NEWLINES_RE = /\\r\\n?|\\n/g;\n  var NULL_RE = /\\0/g;\n  var normalize = function normalize(state) {\n    var str;\n    // Normalize newlines\n        str = state.src.replace(NEWLINES_RE, \"\\n\");\n    // Replace NULL characters\n        str = str.replace(NULL_RE, \"\\ufffd\");\n    state.src = str;\n  };\n  var block = function block(state) {\n    var token;\n    if (state.inlineMode) {\n      token = new state.Token(\"inline\", \"\", 0);\n      token.content = state.src;\n      token.map = [ 0, 1 ];\n      token.children = [];\n      state.tokens.push(token);\n    } else {\n      state.md.block.parse(state.src, state.md, state.env, state.tokens);\n    }\n  };\n  var inline = function inline(state) {\n    var tokens = state.tokens, tok, i, l;\n    // Parse inlines\n        for (i = 0, l = tokens.length; i < l; i++) {\n      tok = tokens[i];\n      if (tok.type === \"inline\") {\n        state.md.inline.parse(tok.content, state.md, state.env, tok.children);\n      }\n    }\n  };\n  var arrayReplaceAt = utils.arrayReplaceAt;\n  function isLinkOpen$1(str) {\n    return /^<a[>\\s]/i.test(str);\n  }\n  function isLinkClose$1(str) {\n    return /^<\\/a\\s*>/i.test(str);\n  }\n  var linkify$1 = function linkify(state) {\n    var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;\n    if (!state.md.options.linkify) {\n      return;\n    }\n    for (j = 0, l = blockTokens.length; j < l; j++) {\n      if (blockTokens[j].type !== \"inline\" || !state.md.linkify.pretest(blockTokens[j].content)) {\n        continue;\n      }\n      tokens = blockTokens[j].children;\n      htmlLinkLevel = 0;\n      // We scan from the end, to keep position when new tags added.\n      // Use reversed logic in links start/end match\n            for (i = tokens.length - 1; i >= 0; i--) {\n        currentToken = tokens[i];\n        // Skip content of markdown links\n                if (currentToken.type === \"link_close\") {\n          i--;\n          while (tokens[i].level !== currentToken.level && tokens[i].type !== \"link_open\") {\n            i--;\n          }\n          continue;\n        }\n        // Skip content of html tag links\n                if (currentToken.type === \"html_inline\") {\n          if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {\n            htmlLinkLevel--;\n          }\n          if (isLinkClose$1(currentToken.content)) {\n            htmlLinkLevel++;\n          }\n        }\n        if (htmlLinkLevel > 0) {\n          continue;\n        }\n        if (currentToken.type === \"text\" && state.md.linkify.test(currentToken.content)) {\n          text = currentToken.content;\n          links = state.md.linkify.match(text);\n          // Now split string to nodes\n                    nodes = [];\n          level = currentToken.level;\n          lastPos = 0;\n          // forbid escape sequence at the start of the string,\n          // this avoids http\\://example.com/ from being linkified as\n          // http:<a href=\"//example.com/\">//example.com/</a>\n                    if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === \"text_special\") {\n            links = links.slice(1);\n          }\n          for (ln = 0; ln < links.length; ln++) {\n            url = links[ln].url;\n            fullUrl = state.md.normalizeLink(url);\n            if (!state.md.validateLink(fullUrl)) {\n              continue;\n            }\n            urlText = links[ln].text;\n            // Linkifier might send raw hostnames like \"example.com\", where url\n            // starts with domain name. So we prepend http:// in those cases,\n            // and remove it afterwards.\n            \n                        if (!links[ln].schema) {\n              urlText = state.md.normalizeLinkText(\"http://\" + urlText).replace(/^http:\\/\\//, \"\");\n            } else if (links[ln].schema === \"mailto:\" && !/^mailto:/i.test(urlText)) {\n              urlText = state.md.normalizeLinkText(\"mailto:\" + urlText).replace(/^mailto:/, \"\");\n            } else {\n              urlText = state.md.normalizeLinkText(urlText);\n            }\n            pos = links[ln].index;\n            if (pos > lastPos) {\n              token = new state.Token(\"text\", \"\", 0);\n              token.content = text.slice(lastPos, pos);\n              token.level = level;\n              nodes.push(token);\n            }\n            token = new state.Token(\"link_open\", \"a\", 1);\n            token.attrs = [ [ \"href\", fullUrl ] ];\n            token.level = level++;\n            token.markup = \"linkify\";\n            token.info = \"auto\";\n            nodes.push(token);\n            token = new state.Token(\"text\", \"\", 0);\n            token.content = urlText;\n            token.level = level;\n            nodes.push(token);\n            token = new state.Token(\"link_close\", \"a\", -1);\n            token.level = --level;\n            token.markup = \"linkify\";\n            token.info = \"auto\";\n            nodes.push(token);\n            lastPos = links[ln].lastIndex;\n          }\n          if (lastPos < text.length) {\n            token = new state.Token(\"text\", \"\", 0);\n            token.content = text.slice(lastPos);\n            token.level = level;\n            nodes.push(token);\n          }\n          // replace current node\n                    blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n        }\n      }\n    }\n  };\n  // Simple typographic replacements\n  // TODO:\n  // - fractionals 1/2, 1/4, 3/4 -> , , \n  // - multiplications 2 x 4 -> 2  4\n    var RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n  // Workaround for phantomjs - need regex without /g flag,\n  // or root check will fail every second time\n    var SCOPED_ABBR_TEST_RE = /\\((c|tm|r)\\)/i;\n  var SCOPED_ABBR_RE = /\\((c|tm|r)\\)/gi;\n  var SCOPED_ABBR = {\n    c: \"\\xa9\",\n    r: \"\\xae\",\n    tm: \"\\u2122\"\n  };\n  function replaceFn(match, name) {\n    return SCOPED_ABBR[name.toLowerCase()];\n  }\n  function replace_scoped(inlineTokens) {\n    var i, token, inside_autolink = 0;\n    for (i = inlineTokens.length - 1; i >= 0; i--) {\n      token = inlineTokens[i];\n      if (token.type === \"text\" && !inside_autolink) {\n        token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);\n      }\n      if (token.type === \"link_open\" && token.info === \"auto\") {\n        inside_autolink--;\n      }\n      if (token.type === \"link_close\" && token.info === \"auto\") {\n        inside_autolink++;\n      }\n    }\n  }\n  function replace_rare(inlineTokens) {\n    var i, token, inside_autolink = 0;\n    for (i = inlineTokens.length - 1; i >= 0; i--) {\n      token = inlineTokens[i];\n      if (token.type === \"text\" && !inside_autolink) {\n        if (RARE_RE.test(token.content)) {\n          token.content = token.content.replace(/\\+-/g, \"\\xb1\").replace(/\\.{2,}/g, \"\\u2026\").replace(/([?!])\\u2026/g, \"$1..\").replace(/([?!]){4,}/g, \"$1$1$1\").replace(/,{2,}/g, \",\").replace(/(^|[^-])---(?=[^-]|$)/gm, \"$1\\u2014\").replace(/(^|\\s)--(?=\\s|$)/gm, \"$1\\u2013\").replace(/(^|[^-\\s])--(?=[^-\\s]|$)/gm, \"$1\\u2013\");\n        }\n      }\n      if (token.type === \"link_open\" && token.info === \"auto\") {\n        inside_autolink--;\n      }\n      if (token.type === \"link_close\" && token.info === \"auto\") {\n        inside_autolink++;\n      }\n    }\n  }\n  var replacements = function replace(state) {\n    var blkIdx;\n    if (!state.md.options.typographer) {\n      return;\n    }\n    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n      if (state.tokens[blkIdx].type !== \"inline\") {\n        continue;\n      }\n      if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\n        replace_scoped(state.tokens[blkIdx].children);\n      }\n      if (RARE_RE.test(state.tokens[blkIdx].content)) {\n        replace_rare(state.tokens[blkIdx].children);\n      }\n    }\n  };\n  var isWhiteSpace$1 = utils.isWhiteSpace;\n  var isPunctChar$1 = utils.isPunctChar;\n  var isMdAsciiPunct$1 = utils.isMdAsciiPunct;\n  var QUOTE_TEST_RE = /['\"]/;\n  var QUOTE_RE = /['\"]/g;\n  var APOSTROPHE = \"\\u2019\";\n /*  */  function replaceAt(str, index, ch) {\n    return str.slice(0, index) + ch + str.slice(index + 1);\n  }\n  function process_inlines(tokens, state) {\n    var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n    stack = [];\n    for (i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n      thisLevel = tokens[i].level;\n      for (j = stack.length - 1; j >= 0; j--) {\n        if (stack[j].level <= thisLevel) {\n          break;\n        }\n      }\n      stack.length = j + 1;\n      if (token.type !== \"text\") {\n        continue;\n      }\n      text = token.content;\n      pos = 0;\n      max = text.length;\n      /*eslint no-labels:0,block-scoped-var:0*/      OUTER: while (pos < max) {\n        QUOTE_RE.lastIndex = pos;\n        t = QUOTE_RE.exec(text);\n        if (!t) {\n          break;\n        }\n        canOpen = canClose = true;\n        pos = t.index + 1;\n        isSingle = t[0] === \"'\";\n        // Find previous character,\n        // default to space if it's the beginning of the line\n        \n                lastChar = 32;\n        if (t.index - 1 >= 0) {\n          lastChar = text.charCodeAt(t.index - 1);\n        } else {\n          for (j = i - 1; j >= 0; j--) {\n            if (tokens[j].type === \"softbreak\" || tokens[j].type === \"hardbreak\") break;\n // lastChar defaults to 0x20\n                        if (!tokens[j].content) continue;\n // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n                        lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n            break;\n          }\n        }\n        // Find next character,\n        // default to space if it's the end of the line\n        \n                nextChar = 32;\n        if (pos < max) {\n          nextChar = text.charCodeAt(pos);\n        } else {\n          for (j = i + 1; j < tokens.length; j++) {\n            if (tokens[j].type === \"softbreak\" || tokens[j].type === \"hardbreak\") break;\n // nextChar defaults to 0x20\n                        if (!tokens[j].content) continue;\n // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n                        nextChar = tokens[j].content.charCodeAt(0);\n            break;\n          }\n        }\n        isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));\n        isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));\n        isLastWhiteSpace = isWhiteSpace$1(lastChar);\n        isNextWhiteSpace = isWhiteSpace$1(nextChar);\n        if (isNextWhiteSpace) {\n          canOpen = false;\n        } else if (isNextPunctChar) {\n          if (!(isLastWhiteSpace || isLastPunctChar)) {\n            canOpen = false;\n          }\n        }\n        if (isLastWhiteSpace) {\n          canClose = false;\n        } else if (isLastPunctChar) {\n          if (!(isNextWhiteSpace || isNextPunctChar)) {\n            canClose = false;\n          }\n        }\n        if (nextChar === 34 /* \" */ && t[0] === '\"') {\n          if (lastChar >= 48 /* 0 */ && lastChar <= 57 /* 9 */) {\n            // special case: 1\"\" - count first quote as an inch\n            canClose = canOpen = false;\n          }\n        }\n        if (canOpen && canClose) {\n          // Replace quotes in the middle of punctuation sequence, but not\n          // in the middle of the words, i.e.:\n          // 1. foo \" bar \" baz - not replaced\n          // 2. foo-\"-bar-\"-baz - replaced\n          // 3. foo\"bar\"baz     - not replaced\n          canOpen = isLastPunctChar;\n          canClose = isNextPunctChar;\n        }\n        if (!canOpen && !canClose) {\n          // middle of word\n          if (isSingle) {\n            token.content = replaceAt(token.content, t.index, APOSTROPHE);\n          }\n          continue;\n        }\n        if (canClose) {\n          // this could be a closing quote, rewind the stack to get a match\n          for (j = stack.length - 1; j >= 0; j--) {\n            item = stack[j];\n            if (stack[j].level < thisLevel) {\n              break;\n            }\n            if (item.single === isSingle && stack[j].level === thisLevel) {\n              item = stack[j];\n              if (isSingle) {\n                openQuote = state.md.options.quotes[2];\n                closeQuote = state.md.options.quotes[3];\n              } else {\n                openQuote = state.md.options.quotes[0];\n                closeQuote = state.md.options.quotes[1];\n              }\n              // replace token.content *before* tokens[item.token].content,\n              // because, if they are pointing at the same token, replaceAt\n              // could mess up indices when quote length != 1\n                            token.content = replaceAt(token.content, t.index, closeQuote);\n              tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);\n              pos += closeQuote.length - 1;\n              if (item.token === i) {\n                pos += openQuote.length - 1;\n              }\n              text = token.content;\n              max = text.length;\n              stack.length = j;\n              continue OUTER;\n            }\n          }\n        }\n        if (canOpen) {\n          stack.push({\n            token: i,\n            pos: t.index,\n            single: isSingle,\n            level: thisLevel\n          });\n        } else if (canClose && isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n      }\n    }\n  }\n  var smartquotes = function smartquotes(state) {\n    /*eslint max-depth:0*/\n    var blkIdx;\n    if (!state.md.options.typographer) {\n      return;\n    }\n    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n      if (state.tokens[blkIdx].type !== \"inline\" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n        continue;\n      }\n      process_inlines(state.tokens[blkIdx].children, state);\n    }\n  };\n  // Join raw text tokens with the rest of the text\n    var text_join = function text_join(state) {\n    var j, l, tokens, curr, max, last, blockTokens = state.tokens;\n    for (j = 0, l = blockTokens.length; j < l; j++) {\n      if (blockTokens[j].type !== \"inline\") continue;\n      tokens = blockTokens[j].children;\n      max = tokens.length;\n      for (curr = 0; curr < max; curr++) {\n        if (tokens[curr].type === \"text_special\") {\n          tokens[curr].type = \"text\";\n        }\n      }\n      for (curr = last = 0; curr < max; curr++) {\n        if (tokens[curr].type === \"text\" && curr + 1 < max && tokens[curr + 1].type === \"text\") {\n          // collapse two adjacent text nodes\n          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n        } else {\n          if (curr !== last) {\n            tokens[last] = tokens[curr];\n          }\n          last++;\n        }\n      }\n      if (curr !== last) {\n        tokens.length = last;\n      }\n    }\n  };\n  // Token class\n  /**\n\t * class Token\n\t **/\n  /**\n\t * new Token(type, tag, nesting)\n\t *\n\t * Create new token and fill passed properties.\n\t **/  function Token(type, tag, nesting) {\n    /**\n\t   * Token#type -> String\n\t   *\n\t   * Type of the token (string, e.g. \"paragraph_open\")\n\t   **/\n    this.type = type;\n    /**\n\t   * Token#tag -> String\n\t   *\n\t   * html tag name, e.g. \"p\"\n\t   **/    this.tag = tag;\n    /**\n\t   * Token#attrs -> Array\n\t   *\n\t   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`\n\t   **/    this.attrs = null;\n    /**\n\t   * Token#map -> Array\n\t   *\n\t   * Source map info. Format: `[ line_begin, line_end ]`\n\t   **/    this.map = null;\n    /**\n\t   * Token#nesting -> Number\n\t   *\n\t   * Level change (number in {-1, 0, 1} set), where:\n\t   *\n\t   * -  `1` means the tag is opening\n\t   * -  `0` means the tag is self-closing\n\t   * - `-1` means the tag is closing\n\t   **/    this.nesting = nesting;\n    /**\n\t   * Token#level -> Number\n\t   *\n\t   * nesting level, the same as `state.level`\n\t   **/    this.level = 0;\n    /**\n\t   * Token#children -> Array\n\t   *\n\t   * An array of child nodes (inline and img tokens)\n\t   **/    this.children = null;\n    /**\n\t   * Token#content -> String\n\t   *\n\t   * In a case of self-closing tag (code, html, fence, etc.),\n\t   * it has contents of this tag.\n\t   **/    this.content = \"\";\n    /**\n\t   * Token#markup -> String\n\t   *\n\t   * '*' or '_' for emphasis, fence string for fence, etc.\n\t   **/    this.markup = \"\";\n    /**\n\t   * Token#info -> String\n\t   *\n\t   * Additional information:\n\t   *\n\t   * - Info string for \"fence\" tokens\n\t   * - The value \"auto\" for autolink \"link_open\" and \"link_close\" tokens\n\t   * - The string value of the item marker for ordered-list \"list_item_open\" tokens\n\t   **/    this.info = \"\";\n    /**\n\t   * Token#meta -> Object\n\t   *\n\t   * A place for plugins to store an arbitrary data\n\t   **/    this.meta = null;\n    /**\n\t   * Token#block -> Boolean\n\t   *\n\t   * True for block-level tokens, false for inline tokens.\n\t   * Used in renderer to calculate line breaks\n\t   **/    this.block = false;\n    /**\n\t   * Token#hidden -> Boolean\n\t   *\n\t   * If it's true, ignore this element when rendering. Used for tight lists\n\t   * to hide paragraphs.\n\t   **/    this.hidden = false;\n  }\n  /**\n\t * Token.attrIndex(name) -> Number\n\t *\n\t * Search attribute index by name.\n\t **/  Token.prototype.attrIndex = function attrIndex(name) {\n    var attrs, i, len;\n    if (!this.attrs) {\n      return -1;\n    }\n    attrs = this.attrs;\n    for (i = 0, len = attrs.length; i < len; i++) {\n      if (attrs[i][0] === name) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  /**\n\t * Token.attrPush(attrData)\n\t *\n\t * Add `[ name, value ]` attribute to list. Init attrs if necessary\n\t **/  Token.prototype.attrPush = function attrPush(attrData) {\n    if (this.attrs) {\n      this.attrs.push(attrData);\n    } else {\n      this.attrs = [ attrData ];\n    }\n  };\n  /**\n\t * Token.attrSet(name, value)\n\t *\n\t * Set `name` attribute to `value`. Override old value if exists.\n\t **/  Token.prototype.attrSet = function attrSet(name, value) {\n    var idx = this.attrIndex(name), attrData = [ name, value ];\n    if (idx < 0) {\n      this.attrPush(attrData);\n    } else {\n      this.attrs[idx] = attrData;\n    }\n  };\n  /**\n\t * Token.attrGet(name)\n\t *\n\t * Get the value of attribute `name`, or null if it does not exist.\n\t **/  Token.prototype.attrGet = function attrGet(name) {\n    var idx = this.attrIndex(name), value = null;\n    if (idx >= 0) {\n      value = this.attrs[idx][1];\n    }\n    return value;\n  };\n  /**\n\t * Token.attrJoin(name, value)\n\t *\n\t * Join value to existing attribute via space. Or create new attribute if not\n\t * exists. Useful to operate with token classes.\n\t **/  Token.prototype.attrJoin = function attrJoin(name, value) {\n    var idx = this.attrIndex(name);\n    if (idx < 0) {\n      this.attrPush([ name, value ]);\n    } else {\n      this.attrs[idx][1] = this.attrs[idx][1] + \" \" + value;\n    }\n  };\n  var token = Token;\n  function StateCore(src, md, env) {\n    this.src = src;\n    this.env = env;\n    this.tokens = [];\n    this.inlineMode = false;\n    this.md = md;\n // link to parser instance\n    }\n  // re-export Token class to use in core rules\n    StateCore.prototype.Token = token;\n  var state_core = StateCore;\n  var _rules$2 = [ [ \"normalize\", normalize ], [ \"block\", block ], [ \"inline\", inline ], [ \"linkify\", linkify$1 ], [ \"replacements\", replacements ], [ \"smartquotes\", smartquotes ], \n  // `text_join` finds `text_special` tokens (for escape sequences)\n  // and joins them with the rest of the text\n  [ \"text_join\", text_join ] ];\n  /**\n\t * new Core()\n\t **/  function Core() {\n    /**\n\t   * Core#ruler -> Ruler\n\t   *\n\t   * [[Ruler]] instance. Keep configuration of core rules.\n\t   **/\n    this.ruler = new ruler;\n    for (var i = 0; i < _rules$2.length; i++) {\n      this.ruler.push(_rules$2[i][0], _rules$2[i][1]);\n    }\n  }\n  /**\n\t * Core.process(state)\n\t *\n\t * Executes core chain rules.\n\t **/  Core.prototype.process = function(state) {\n    var i, l, rules;\n    rules = this.ruler.getRules(\"\");\n    for (i = 0, l = rules.length; i < l; i++) {\n      rules[i](state);\n    }\n  };\n  Core.prototype.State = state_core;\n  var parser_core = Core;\n  var isSpace$a = utils.isSpace;\n  function getLine(state, line) {\n    var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];\n    return state.src.slice(pos, max);\n  }\n  function escapedSplit(str) {\n    var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = \"\";\n    ch = str.charCodeAt(pos);\n    while (pos < max) {\n      if (ch === 124 /* | */) {\n        if (!isEscaped) {\n          // pipe separating cells, '|'\n          result.push(current + str.substring(lastPos, pos));\n          current = \"\";\n          lastPos = pos + 1;\n        } else {\n          // escaped pipe, '\\|'\n          current += str.substring(lastPos, pos - 1);\n          lastPos = pos;\n        }\n      }\n      isEscaped = ch === 92 /* \\ */;\n      pos++;\n      ch = str.charCodeAt(pos);\n    }\n    result.push(current + str.substring(lastPos));\n    return result;\n  }\n  var table = function table(state, startLine, endLine, silent) {\n    var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;\n    // should have at least two lines\n        if (startLine + 2 > endLine) {\n      return false;\n    }\n    nextLine = startLine + 1;\n    if (state.sCount[nextLine] < state.blkIndent) {\n      return false;\n    }\n    // if it's indented more than 3 spaces, it should be a code block\n        if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      return false;\n    }\n    // first character of the second line should be '|', '-', ':',\n    // and no other characters are allowed but spaces;\n    // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    if (pos >= state.eMarks[nextLine]) {\n      return false;\n    }\n    firstCh = state.src.charCodeAt(pos++);\n    if (firstCh !== 124 /* | */ && firstCh !== 45 /* - */ && firstCh !== 58 /* : */) {\n      return false;\n    }\n    if (pos >= state.eMarks[nextLine]) {\n      return false;\n    }\n    secondCh = state.src.charCodeAt(pos++);\n    if (secondCh !== 124 /* | */ && secondCh !== 45 /* - */ && secondCh !== 58 /* : */ && !isSpace$a(secondCh)) {\n      return false;\n    }\n    // if first character is '-', then second character must not be a space\n    // (due to parsing ambiguity with list)\n        if (firstCh === 45 /* - */ && isSpace$a(secondCh)) {\n      return false;\n    }\n    while (pos < state.eMarks[nextLine]) {\n      ch = state.src.charCodeAt(pos);\n      if (ch !== 124 /* | */ && ch !== 45 /* - */ && ch !== 58 /* : */ && !isSpace$a(ch)) {\n        return false;\n      }\n      pos++;\n    }\n    lineText = getLine(state, startLine + 1);\n    columns = lineText.split(\"|\");\n    aligns = [];\n    for (i = 0; i < columns.length; i++) {\n      t = columns[i].trim();\n      if (!t) {\n        // allow empty columns before and after table, but not in between columns;\n        // e.g. allow ` |---| `, disallow ` ---||--- `\n        if (i === 0 || i === columns.length - 1) {\n          continue;\n        } else {\n          return false;\n        }\n      }\n      if (!/^:?-+:?$/.test(t)) {\n        return false;\n      }\n      if (t.charCodeAt(t.length - 1) === 58 /* : */) {\n        aligns.push(t.charCodeAt(0) === 58 /* : */ ? \"center\" : \"right\");\n      } else if (t.charCodeAt(0) === 58 /* : */) {\n        aligns.push(\"left\");\n      } else {\n        aligns.push(\"\");\n      }\n    }\n    lineText = getLine(state, startLine).trim();\n    if (lineText.indexOf(\"|\") === -1) {\n      return false;\n    }\n    if (state.sCount[startLine] - state.blkIndent >= 4) {\n      return false;\n    }\n    columns = escapedSplit(lineText);\n    if (columns.length && columns[0] === \"\") columns.shift();\n    if (columns.length && columns[columns.length - 1] === \"\") columns.pop();\n    // header row will define an amount of columns in the entire table,\n    // and align row should be exactly the same (the rest of the rows can differ)\n        columnCount = columns.length;\n    if (columnCount === 0 || columnCount !== aligns.length) {\n      return false;\n    }\n    if (silent) {\n      return true;\n    }\n    oldParentType = state.parentType;\n    state.parentType = \"table\";\n    // use 'blockquote' lists for termination because it's\n    // the most similar to tables\n        terminatorRules = state.md.block.ruler.getRules(\"blockquote\");\n    token = state.push(\"table_open\", \"table\", 1);\n    token.map = tableLines = [ startLine, 0 ];\n    token = state.push(\"thead_open\", \"thead\", 1);\n    token.map = [ startLine, startLine + 1 ];\n    token = state.push(\"tr_open\", \"tr\", 1);\n    token.map = [ startLine, startLine + 1 ];\n    for (i = 0; i < columns.length; i++) {\n      token = state.push(\"th_open\", \"th\", 1);\n      if (aligns[i]) {\n        token.attrs = [ [ \"style\", \"text-align:\" + aligns[i] ] ];\n      }\n      token = state.push(\"inline\", \"\", 0);\n      token.content = columns[i].trim();\n      token.children = [];\n      token = state.push(\"th_close\", \"th\", -1);\n    }\n    token = state.push(\"tr_close\", \"tr\", -1);\n    token = state.push(\"thead_close\", \"thead\", -1);\n    for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) {\n        break;\n      }\n      terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) {\n        break;\n      }\n      lineText = getLine(state, nextLine).trim();\n      if (!lineText) {\n        break;\n      }\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        break;\n      }\n      columns = escapedSplit(lineText);\n      if (columns.length && columns[0] === \"\") columns.shift();\n      if (columns.length && columns[columns.length - 1] === \"\") columns.pop();\n      if (nextLine === startLine + 2) {\n        token = state.push(\"tbody_open\", \"tbody\", 1);\n        token.map = tbodyLines = [ startLine + 2, 0 ];\n      }\n      token = state.push(\"tr_open\", \"tr\", 1);\n      token.map = [ nextLine, nextLine + 1 ];\n      for (i = 0; i < columnCount; i++) {\n        token = state.push(\"td_open\", \"td\", 1);\n        if (aligns[i]) {\n          token.attrs = [ [ \"style\", \"text-align:\" + aligns[i] ] ];\n        }\n        token = state.push(\"inline\", \"\", 0);\n        token.content = columns[i] ? columns[i].trim() : \"\";\n        token.children = [];\n        token = state.push(\"td_close\", \"td\", -1);\n      }\n      token = state.push(\"tr_close\", \"tr\", -1);\n    }\n    if (tbodyLines) {\n      token = state.push(\"tbody_close\", \"tbody\", -1);\n      tbodyLines[1] = nextLine;\n    }\n    token = state.push(\"table_close\", \"table\", -1);\n    tableLines[1] = nextLine;\n    state.parentType = oldParentType;\n    state.line = nextLine;\n    return true;\n  };\n  // Code block (4 spaces padded)\n    var code = function code(state, startLine, endLine /*, silent*/) {\n    var nextLine, last, token;\n    if (state.sCount[startLine] - state.blkIndent < 4) {\n      return false;\n    }\n    last = nextLine = startLine + 1;\n    while (nextLine < endLine) {\n      if (state.isEmpty(nextLine)) {\n        nextLine++;\n        continue;\n      }\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        nextLine++;\n        last = nextLine;\n        continue;\n      }\n      break;\n    }\n    state.line = last;\n    token = state.push(\"code_block\", \"code\", 0);\n    token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + \"\\n\";\n    token.map = [ startLine, state.line ];\n    return true;\n  };\n  // fences (``` lang, ~~~ lang)\n    var fence = function fence(state, startLine, endLine, silent) {\n    var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\n    // if it's indented more than 3 spaces, it should be a code block\n        if (state.sCount[startLine] - state.blkIndent >= 4) {\n      return false;\n    }\n    if (pos + 3 > max) {\n      return false;\n    }\n    marker = state.src.charCodeAt(pos);\n    if (marker !== 126 /* ~ */ && marker !== 96 /* ` */) {\n      return false;\n    }\n    // scan marker length\n        mem = pos;\n    pos = state.skipChars(pos, marker);\n    len = pos - mem;\n    if (len < 3) {\n      return false;\n    }\n    markup = state.src.slice(mem, pos);\n    params = state.src.slice(pos, max);\n    if (marker === 96 /* ` */) {\n      if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n        return false;\n      }\n    }\n    // Since start is found, we can report success here in validation mode\n        if (silent) {\n      return true;\n    }\n    // search end of block\n        nextLine = startLine;\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n      if (state.src.charCodeAt(pos) !== marker) {\n        continue;\n      }\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n      pos = state.skipChars(pos, marker);\n      // closing code fence must be at least as long as the opening one\n            if (pos - mem < len) {\n        continue;\n      }\n      // make sure tail has spaces only\n            pos = state.skipSpaces(pos);\n      if (pos < max) {\n        continue;\n      }\n      haveEndMarker = true;\n      // found!\n            break;\n    }\n    // If a fence has heading spaces, they should be removed from its inner block\n        len = state.sCount[startLine];\n    state.line = nextLine + (haveEndMarker ? 1 : 0);\n    token = state.push(\"fence\", \"code\", 0);\n    token.info = params;\n    token.content = state.getLines(startLine + 1, nextLine, len, true);\n    token.markup = markup;\n    token.map = [ startLine, state.line ];\n    return true;\n  };\n  var isSpace$9 = utils.isSpace;\n  var blockquote = function blockquote(state, startLine, endLine, silent) {\n    var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\n    // if it's indented more than 3 spaces, it should be a code block\n        if (state.sCount[startLine] - state.blkIndent >= 4) {\n      return false;\n    }\n    // check the block quote marker\n        if (state.src.charCodeAt(pos++) !== 62 /* > */) {\n      return false;\n    }\n    // we know that it's going to be a valid blockquote,\n    // so no point trying to find the end of it in silent mode\n        if (silent) {\n      return true;\n    }\n    // set offset past spaces and \">\"\n        initial = offset = state.sCount[startLine] + 1;\n    // skip one optional space after '>'\n        if (state.src.charCodeAt(pos) === 32 /* space */) {\n      // ' >   test '\n      //     ^ -- position start of line here:\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n      spaceAfterMarker = true;\n    } else if (state.src.charCodeAt(pos) === 9 /* tab */) {\n      spaceAfterMarker = true;\n      if ((state.bsCount[startLine] + offset) % 4 === 3) {\n        // '  >\\t  test '\n        //       ^ -- position start of line here (tab has width===1)\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n      } else {\n        // ' >\\t  test '\n        //    ^ -- position start of line here + shift bsCount slightly\n        //         to make extra space appear\n        adjustTab = true;\n      }\n    } else {\n      spaceAfterMarker = false;\n    }\n    oldBMarks = [ state.bMarks[startLine] ];\n    state.bMarks[startLine] = pos;\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n      if (isSpace$9(ch)) {\n        if (ch === 9) {\n          offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n        } else {\n          offset++;\n        }\n      } else {\n        break;\n      }\n      pos++;\n    }\n    oldBSCount = [ state.bsCount[startLine] ];\n    state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n    lastLineEmpty = pos >= max;\n    oldSCount = [ state.sCount[startLine] ];\n    state.sCount[startLine] = offset - initial;\n    oldTShift = [ state.tShift[startLine] ];\n    state.tShift[startLine] = pos - state.bMarks[startLine];\n    terminatorRules = state.md.block.ruler.getRules(\"blockquote\");\n    oldParentType = state.parentType;\n    state.parentType = \"blockquote\";\n    // Search the end of the block\n    \n    // Block ends with either:\n    //  1. an empty line outside:\n    //     ```\n    //     > test\n    \n    //     ```\n    //  2. an empty line inside:\n    //     ```\n    //     >\n    //     test\n    //     ```\n    //  3. another tag:\n    //     ```\n    //     > test\n    //      - - -\n    //     ```\n        for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n      // check if it's outdented, i.e. it's inside list item and indented\n      // less than said list item:\n      // ```\n      // 1. anything\n      //    > current blockquote\n      // 2. checking this line\n      // ```\n      isOutdented = state.sCount[nextLine] < state.blkIndent;\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      if (pos >= max) {\n        // Case 1: line is not inside the blockquote, and this line is empty.\n        break;\n      }\n      if (state.src.charCodeAt(pos++) === 62 /* > */ && !isOutdented) {\n        // This line is inside the blockquote.\n        // set offset past spaces and \">\"\n        initial = offset = state.sCount[nextLine] + 1;\n        // skip one optional space after '>'\n                if (state.src.charCodeAt(pos) === 32 /* space */) {\n          // ' >   test '\n          //     ^ -- position start of line here:\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n          spaceAfterMarker = true;\n        } else if (state.src.charCodeAt(pos) === 9 /* tab */) {\n          spaceAfterMarker = true;\n          if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n            // '  >\\t  test '\n            //       ^ -- position start of line here (tab has width===1)\n            pos++;\n            initial++;\n            offset++;\n            adjustTab = false;\n          } else {\n            // ' >\\t  test '\n            //    ^ -- position start of line here + shift bsCount slightly\n            //         to make extra space appear\n            adjustTab = true;\n          }\n        } else {\n          spaceAfterMarker = false;\n        }\n        oldBMarks.push(state.bMarks[nextLine]);\n        state.bMarks[nextLine] = pos;\n        while (pos < max) {\n          ch = state.src.charCodeAt(pos);\n          if (isSpace$9(ch)) {\n            if (ch === 9) {\n              offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n            } else {\n              offset++;\n            }\n          } else {\n            break;\n          }\n          pos++;\n        }\n        lastLineEmpty = pos >= max;\n        oldBSCount.push(state.bsCount[nextLine]);\n        state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] = offset - initial;\n        oldTShift.push(state.tShift[nextLine]);\n        state.tShift[nextLine] = pos - state.bMarks[nextLine];\n        continue;\n      }\n      // Case 2: line is not inside the blockquote, and the last line was empty.\n            if (lastLineEmpty) {\n        break;\n      }\n      // Case 3: another tag found.\n            terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) {\n        // Quirk to enforce \"hard termination mode\" for paragraphs;\n        // normally if you call `tokenize(state, startLine, nextLine)`,\n        // paragraphs will look below nextLine for paragraph continuation,\n        // but if blockquote is terminated by another tag, they shouldn't\n        state.lineMax = nextLine;\n        if (state.blkIndent !== 0) {\n          // state.blkIndent was non-zero, we now set it to zero,\n          // so we need to re-calculate all offsets to appear as\n          // if indent wasn't changed\n          oldBMarks.push(state.bMarks[nextLine]);\n          oldBSCount.push(state.bsCount[nextLine]);\n          oldTShift.push(state.tShift[nextLine]);\n          oldSCount.push(state.sCount[nextLine]);\n          state.sCount[nextLine] -= state.blkIndent;\n        }\n        break;\n      }\n      oldBMarks.push(state.bMarks[nextLine]);\n      oldBSCount.push(state.bsCount[nextLine]);\n      oldTShift.push(state.tShift[nextLine]);\n      oldSCount.push(state.sCount[nextLine]);\n      // A negative indentation means that this is a paragraph continuation\n      \n            state.sCount[nextLine] = -1;\n    }\n    oldIndent = state.blkIndent;\n    state.blkIndent = 0;\n    token = state.push(\"blockquote_open\", \"blockquote\", 1);\n    token.markup = \">\";\n    token.map = lines = [ startLine, 0 ];\n    state.md.block.tokenize(state, startLine, nextLine);\n    token = state.push(\"blockquote_close\", \"blockquote\", -1);\n    token.markup = \">\";\n    state.lineMax = oldLineMax;\n    state.parentType = oldParentType;\n    lines[1] = state.line;\n    // Restore original tShift; this might not be necessary since the parser\n    // has already been here, but just to make sure we can do that.\n        for (i = 0; i < oldTShift.length; i++) {\n      state.bMarks[i + startLine] = oldBMarks[i];\n      state.tShift[i + startLine] = oldTShift[i];\n      state.sCount[i + startLine] = oldSCount[i];\n      state.bsCount[i + startLine] = oldBSCount[i];\n    }\n    state.blkIndent = oldIndent;\n    return true;\n  };\n  var isSpace$8 = utils.isSpace;\n  var hr = function hr(state, startLine, endLine, silent) {\n    var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\n    // if it's indented more than 3 spaces, it should be a code block\n        if (state.sCount[startLine] - state.blkIndent >= 4) {\n      return false;\n    }\n    marker = state.src.charCodeAt(pos++);\n    // Check hr marker\n        if (marker !== 42 /* * */ && marker !== 45 /* - */ && marker !== 95 /* _ */) {\n      return false;\n    }\n    // markers can be mixed with spaces, but there should be at least 3 of them\n        cnt = 1;\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos++);\n      if (ch !== marker && !isSpace$8(ch)) {\n        return false;\n      }\n      if (ch === marker) {\n        cnt++;\n      }\n    }\n    if (cnt < 3) {\n      return false;\n    }\n    if (silent) {\n      return true;\n    }\n    state.line = startLine + 1;\n    token = state.push(\"hr\", \"hr\", 0);\n    token.map = [ startLine, state.line ];\n    token.markup = Array(cnt + 1).join(String.fromCharCode(marker));\n    return true;\n  };\n  var isSpace$7 = utils.isSpace;\n  // Search `[-+*][\\n ]`, returns next pos after marker on success\n  // or -1 on fail.\n    function skipBulletListMarker(state, startLine) {\n    var marker, pos, max, ch;\n    pos = state.bMarks[startLine] + state.tShift[startLine];\n    max = state.eMarks[startLine];\n    marker = state.src.charCodeAt(pos++);\n    // Check bullet\n        if (marker !== 42 /* * */ && marker !== 45 /* - */ && marker !== 43 /* + */) {\n      return -1;\n    }\n    if (pos < max) {\n      ch = state.src.charCodeAt(pos);\n      if (!isSpace$7(ch)) {\n        // \" -test \" - is not a list item\n        return -1;\n      }\n    }\n    return pos;\n  }\n  // Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n  // or -1 on fail.\n    function skipOrderedListMarker(state, startLine) {\n    var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];\n    // List marker should have at least 2 chars (digit + dot)\n        if (pos + 1 >= max) {\n      return -1;\n    }\n    ch = state.src.charCodeAt(pos++);\n    if (ch < 48 /* 0 */ || ch > 57 /* 9 */) {\n      return -1;\n    }\n    for (;;) {\n      // EOL -> fail\n      if (pos >= max) {\n        return -1;\n      }\n      ch = state.src.charCodeAt(pos++);\n      if (ch >= 48 /* 0 */ && ch <= 57 /* 9 */) {\n        // List marker should have no more than 9 digits\n        // (prevents integer overflow in browsers)\n        if (pos - start >= 10) {\n          return -1;\n        }\n        continue;\n      }\n      // found valid marker\n            if (ch === 41 /* ) */ || ch === 46 /* . */) {\n        break;\n      }\n      return -1;\n    }\n    if (pos < max) {\n      ch = state.src.charCodeAt(pos);\n      if (!isSpace$7(ch)) {\n        // \" 1.test \" - is not a list item\n        return -1;\n      }\n    }\n    return pos;\n  }\n  function markTightParagraphs(state, idx) {\n    var i, l, level = state.level + 2;\n    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n      if (state.tokens[i].level === level && state.tokens[i].type === \"paragraph_open\") {\n        state.tokens[i + 2].hidden = true;\n        state.tokens[i].hidden = true;\n        i += 2;\n      }\n    }\n  }\n  var list = function list(state, startLine, endLine, silent) {\n    var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;\n    // if it's indented more than 3 spaces, it should be a code block\n        if (state.sCount[startLine] - state.blkIndent >= 4) {\n      return false;\n    }\n    // Special case:\n    //  - item 1\n    //   - item 2\n    //    - item 3\n    //     - item 4\n    //      - this one is a paragraph continuation\n        if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {\n      return false;\n    }\n    // limit conditions when list can interrupt\n    // a paragraph (validation mode only)\n        if (silent && state.parentType === \"paragraph\") {\n      // Next list item should still terminate previous list item;\n      // This code can fail if plugins use blkIndent as well as lists,\n      // but I hope the spec gets fixed long before that happens.\n      if (state.sCount[startLine] >= state.blkIndent) {\n        isTerminatingParagraph = true;\n      }\n    }\n    // Detect list type and position after marker\n        if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n      isOrdered = true;\n      start = state.bMarks[startLine] + state.tShift[startLine];\n      markerValue = Number(state.src.slice(start, posAfterMarker - 1));\n      // If we're starting a new ordered list right after\n      // a paragraph, it should start with 1.\n            if (isTerminatingParagraph && markerValue !== 1) return false;\n    } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n      isOrdered = false;\n    } else {\n      return false;\n    }\n    // If we're starting a new unordered list right after\n    // a paragraph, first line should not be empty.\n        if (isTerminatingParagraph) {\n      if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\n    }\n    // We should terminate list on style change. Remember first one to compare.\n        markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n    // For validation mode we can terminate immediately\n        if (silent) {\n      return true;\n    }\n    // Start list\n        listTokIdx = state.tokens.length;\n    if (isOrdered) {\n      token = state.push(\"ordered_list_open\", \"ol\", 1);\n      if (markerValue !== 1) {\n        token.attrs = [ [ \"start\", markerValue ] ];\n      }\n    } else {\n      token = state.push(\"bullet_list_open\", \"ul\", 1);\n    }\n    token.map = listLines = [ startLine, 0 ];\n    token.markup = String.fromCharCode(markerCharCode);\n    \n    // Iterate list items\n    \n        nextLine = startLine;\n    prevEmptyEnd = false;\n    terminatorRules = state.md.block.ruler.getRules(\"list\");\n    oldParentType = state.parentType;\n    state.parentType = \"list\";\n    while (nextLine < endLine) {\n      pos = posAfterMarker;\n      max = state.eMarks[nextLine];\n      initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n        if (ch === 9) {\n          offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n        } else if (ch === 32) {\n          offset++;\n        } else {\n          break;\n        }\n        pos++;\n      }\n      contentStart = pos;\n      if (contentStart >= max) {\n        // trimming space in \"-    \\n  3\" case, indent is 1 here\n        indentAfterMarker = 1;\n      } else {\n        indentAfterMarker = offset - initial;\n      }\n      // If we have more than 4 spaces, the indent is 1\n      // (the rest is just indented code block)\n            if (indentAfterMarker > 4) {\n        indentAfterMarker = 1;\n      }\n      // \"  -  test\"\n      //  ^^^^^ - calculating total length of this thing\n            indent = initial + indentAfterMarker;\n      // Run subparser & write tokens\n            token = state.push(\"list_item_open\", \"li\", 1);\n      token.markup = String.fromCharCode(markerCharCode);\n      token.map = itemLines = [ startLine, 0 ];\n      if (isOrdered) {\n        token.info = state.src.slice(start, posAfterMarker - 1);\n      }\n      // change current state, then restore it after parser subcall\n            oldTight = state.tight;\n      oldTShift = state.tShift[startLine];\n      oldSCount = state.sCount[startLine];\n      //  - example list\n      // ^ listIndent position will be here\n      //   ^ blkIndent position will be here\n      \n            oldListIndent = state.listIndent;\n      state.listIndent = state.blkIndent;\n      state.blkIndent = indent;\n      state.tight = true;\n      state.tShift[startLine] = contentStart - state.bMarks[startLine];\n      state.sCount[startLine] = offset;\n      if (contentStart >= max && state.isEmpty(startLine + 1)) {\n        // workaround for this case\n        // (list item is empty, list terminates before \"foo\"):\n        // ~~~~~~~~\n        //   -\n        //     foo\n        // ~~~~~~~~\n        state.line = Math.min(state.line + 2, endLine);\n      } else {\n        state.md.block.tokenize(state, startLine, endLine, true);\n      }\n      // If any of list item is tight, mark list as tight\n            if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      }\n      // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n            prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n      state.blkIndent = state.listIndent;\n      state.listIndent = oldListIndent;\n      state.tShift[startLine] = oldTShift;\n      state.sCount[startLine] = oldSCount;\n      state.tight = oldTight;\n      token = state.push(\"list_item_close\", \"li\", -1);\n      token.markup = String.fromCharCode(markerCharCode);\n      nextLine = startLine = state.line;\n      itemLines[1] = nextLine;\n      contentStart = state.bMarks[startLine];\n      if (nextLine >= endLine) {\n        break;\n      }\n      \n      // Try to check if list is terminated or continued.\n      \n            if (state.sCount[nextLine] < state.blkIndent) {\n        break;\n      }\n      // if it's indented more than 3 spaces, it should be a code block\n            if (state.sCount[startLine] - state.blkIndent >= 4) {\n        break;\n      }\n      // fail if terminating block found\n            terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) {\n        break;\n      }\n      // fail if list has another type\n            if (isOrdered) {\n        posAfterMarker = skipOrderedListMarker(state, nextLine);\n        if (posAfterMarker < 0) {\n          break;\n        }\n        start = state.bMarks[nextLine] + state.tShift[nextLine];\n      } else {\n        posAfterMarker = skipBulletListMarker(state, nextLine);\n        if (posAfterMarker < 0) {\n          break;\n        }\n      }\n      if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n        break;\n      }\n    }\n    // Finalize list\n        if (isOrdered) {\n      token = state.push(\"ordered_list_close\", \"ol\", -1);\n    } else {\n      token = state.push(\"bullet_list_close\", \"ul\", -1);\n    }\n    token.markup = String.fromCharCode(markerCharCode);\n    listLines[1] = nextLine;\n    state.line = nextLine;\n    state.parentType = oldParentType;\n    // mark paragraphs tight if needed\n        if (tight) {\n      markTightParagraphs(state, listTokIdx);\n    }\n    return true;\n  };\n  var normalizeReference$2 = utils.normalizeReference;\n  var isSpace$6 = utils.isSpace;\n  var reference = function reference(state, startLine, _endLine, silent) {\n    var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;\n    // if it's indented more than 3 spaces, it should be a code block\n        if (state.sCount[startLine] - state.blkIndent >= 4) {\n      return false;\n    }\n    if (state.src.charCodeAt(pos) !== 91 /* [ */) {\n      return false;\n    }\n    // Simple check to quickly interrupt scan on [link](url) at the start of line.\n    // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n        while (++pos < max) {\n      if (state.src.charCodeAt(pos) === 93 /* ] */ && state.src.charCodeAt(pos - 1) !== 92 /* \\ */) {\n        if (pos + 1 === max) {\n          return false;\n        }\n        if (state.src.charCodeAt(pos + 1) !== 58 /* : */) {\n          return false;\n        }\n        break;\n      }\n    }\n    endLine = state.lineMax;\n    // jump line-by-line until empty one or EOF\n        terminatorRules = state.md.block.ruler.getRules(\"reference\");\n    oldParentType = state.parentType;\n    state.parentType = \"reference\";\n    for (;nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.sCount[nextLine] - state.blkIndent > 3) {\n        continue;\n      }\n      // quirk for blockquotes, this line should already be checked by that rule\n            if (state.sCount[nextLine] < 0) {\n        continue;\n      }\n      // Some tags can terminate paragraph without empty line.\n            terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) {\n        break;\n      }\n    }\n    str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n    max = str.length;\n    for (pos = 1; pos < max; pos++) {\n      ch = str.charCodeAt(pos);\n      if (ch === 91 /* [ */) {\n        return false;\n      } else if (ch === 93 /* ] */) {\n        labelEnd = pos;\n        break;\n      } else if (ch === 10 /* \\n */) {\n        lines++;\n      } else if (ch === 92 /* \\ */) {\n        pos++;\n        if (pos < max && str.charCodeAt(pos) === 10) {\n          lines++;\n        }\n      }\n    }\n    if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58 /* : */) {\n      return false;\n    }\n    // [label]:   destination   'title'\n    //         ^^^ skip optional whitespace here\n        for (pos = labelEnd + 2; pos < max; pos++) {\n      ch = str.charCodeAt(pos);\n      if (ch === 10) {\n        lines++;\n      } else if (isSpace$6(ch)) ; else {\n        break;\n      }\n    }\n    // [label]:   destination   'title'\n    //            ^^^^^^^^^^^ parse this\n        res = state.md.helpers.parseLinkDestination(str, pos, max);\n    if (!res.ok) {\n      return false;\n    }\n    href = state.md.normalizeLink(res.str);\n    if (!state.md.validateLink(href)) {\n      return false;\n    }\n    pos = res.pos;\n    lines += res.lines;\n    // save cursor state, we could require to rollback later\n        destEndPos = pos;\n    destEndLineNo = lines;\n    // [label]:   destination   'title'\n    //                       ^^^ skipping those spaces\n        start = pos;\n    for (;pos < max; pos++) {\n      ch = str.charCodeAt(pos);\n      if (ch === 10) {\n        lines++;\n      } else if (isSpace$6(ch)) ; else {\n        break;\n      }\n    }\n    // [label]:   destination   'title'\n    //                          ^^^^^^^ parse this\n        res = state.md.helpers.parseLinkTitle(str, pos, max);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n      lines += res.lines;\n    } else {\n      title = \"\";\n      pos = destEndPos;\n      lines = destEndLineNo;\n    }\n    // skip trailing spaces until the rest of the line\n        while (pos < max) {\n      ch = str.charCodeAt(pos);\n      if (!isSpace$6(ch)) {\n        break;\n      }\n      pos++;\n    }\n    if (pos < max && str.charCodeAt(pos) !== 10) {\n      if (title) {\n        // garbage at the end of the line after title,\n        // but it could still be a valid reference if we roll back\n        title = \"\";\n        pos = destEndPos;\n        lines = destEndLineNo;\n        while (pos < max) {\n          ch = str.charCodeAt(pos);\n          if (!isSpace$6(ch)) {\n            break;\n          }\n          pos++;\n        }\n      }\n    }\n    if (pos < max && str.charCodeAt(pos) !== 10) {\n      // garbage at the end of the line\n      return false;\n    }\n    label = normalizeReference$2(str.slice(1, labelEnd));\n    if (!label) {\n      // CommonMark 0.20 disallows empty labels\n      return false;\n    }\n    // Reference can not terminate anything. This check is for safety only.\n    /*istanbul ignore if*/    if (silent) {\n      return true;\n    }\n    if (typeof state.env.references === \"undefined\") {\n      state.env.references = {};\n    }\n    if (typeof state.env.references[label] === \"undefined\") {\n      state.env.references[label] = {\n        title: title,\n        href: href\n      };\n    }\n    state.parentType = oldParentType;\n    state.line = startLine + lines + 1;\n    return true;\n  };\n  // List of valid html blocks names, accorting to commonmark spec\n    var html_blocks = [ \"address\", \"article\", \"aside\", \"base\", \"basefont\", \"blockquote\", \"body\", \"caption\", \"center\", \"col\", \"colgroup\", \"dd\", \"details\", \"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hr\", \"html\", \"iframe\", \"legend\", \"li\", \"link\", \"main\", \"menu\", \"menuitem\", \"nav\", \"noframes\", \"ol\", \"optgroup\", \"option\", \"p\", \"param\", \"section\", \"source\", \"summary\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"track\", \"ul\" ];\n  // Regexps to match html elements\n    var attr_name = \"[a-zA-Z_:][a-zA-Z0-9:._-]*\";\n  var unquoted = \"[^\\\"'=<>`\\\\x00-\\\\x20]+\";\n  var single_quoted = \"'[^']*'\";\n  var double_quoted = '\"[^\"]*\"';\n  var attr_value = \"(?:\" + unquoted + \"|\" + single_quoted + \"|\" + double_quoted + \")\";\n  var attribute = \"(?:\\\\s+\" + attr_name + \"(?:\\\\s*=\\\\s*\" + attr_value + \")?)\";\n  var open_tag = \"<[A-Za-z][A-Za-z0-9\\\\-]*\" + attribute + \"*\\\\s*\\\\/?>\";\n  var close_tag = \"<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>\";\n  var comment = \"\\x3c!----\\x3e|\\x3c!--(?:-?[^>-])(?:-?[^-])*--\\x3e\";\n  var processing = \"<[?][\\\\s\\\\S]*?[?]>\";\n  var declaration = \"<![A-Z]+\\\\s+[^>]*>\";\n  var cdata = \"<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\";\n  var HTML_TAG_RE$1 = new RegExp(\"^(?:\" + open_tag + \"|\" + close_tag + \"|\" + comment + \"|\" + processing + \"|\" + declaration + \"|\" + cdata + \")\");\n  var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp(\"^(?:\" + open_tag + \"|\" + close_tag + \")\");\n  var HTML_TAG_RE_1 = HTML_TAG_RE$1;\n  var HTML_OPEN_CLOSE_TAG_RE_1 = HTML_OPEN_CLOSE_TAG_RE$1;\n  var html_re = {\n    HTML_TAG_RE: HTML_TAG_RE_1,\n    HTML_OPEN_CLOSE_TAG_RE: HTML_OPEN_CLOSE_TAG_RE_1\n  };\n  var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;\n  // An array of opening and corresponding closing sequences for html tags,\n  // last argument defines whether it can terminate a paragraph or not\n  \n    var HTML_SEQUENCES = [ [ /^<(script|pre|style|textarea)(?=(\\s|>|$))/i, /<\\/(script|pre|style|textarea)>/i, true ], [ /^<!--/, /-->/, true ], [ /^<\\?/, /\\?>/, true ], [ /^<![A-Z]/, />/, true ], [ /^<!\\[CDATA\\[/, /\\]\\]>/, true ], [ new RegExp(\"^</?(\" + html_blocks.join(\"|\") + \")(?=(\\\\s|/?>|$))\", \"i\"), /^$/, true ], [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + \"\\\\s*$\"), /^$/, false ] ];\n  var html_block = function html_block(state, startLine, endLine, silent) {\n    var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\n    // if it's indented more than 3 spaces, it should be a code block\n        if (state.sCount[startLine] - state.blkIndent >= 4) {\n      return false;\n    }\n    if (!state.md.options.html) {\n      return false;\n    }\n    if (state.src.charCodeAt(pos) !== 60 /* < */) {\n      return false;\n    }\n    lineText = state.src.slice(pos, max);\n    for (i = 0; i < HTML_SEQUENCES.length; i++) {\n      if (HTML_SEQUENCES[i][0].test(lineText)) {\n        break;\n      }\n    }\n    if (i === HTML_SEQUENCES.length) {\n      return false;\n    }\n    if (silent) {\n      // true if this sequence can be a terminator, false otherwise\n      return HTML_SEQUENCES[i][2];\n    }\n    nextLine = startLine + 1;\n    // If we are here - we detected HTML block.\n    // Let's roll down till block end.\n        if (!HTML_SEQUENCES[i][1].test(lineText)) {\n      for (;nextLine < endLine; nextLine++) {\n        if (state.sCount[nextLine] < state.blkIndent) {\n          break;\n        }\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\n        max = state.eMarks[nextLine];\n        lineText = state.src.slice(pos, max);\n        if (HTML_SEQUENCES[i][1].test(lineText)) {\n          if (lineText.length !== 0) {\n            nextLine++;\n          }\n          break;\n        }\n      }\n    }\n    state.line = nextLine;\n    token = state.push(\"html_block\", \"\", 0);\n    token.map = [ startLine, nextLine ];\n    token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n    return true;\n  };\n  var isSpace$5 = utils.isSpace;\n  var heading = function heading(state, startLine, endLine, silent) {\n    var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\n    // if it's indented more than 3 spaces, it should be a code block\n        if (state.sCount[startLine] - state.blkIndent >= 4) {\n      return false;\n    }\n    ch = state.src.charCodeAt(pos);\n    if (ch !== 35 /* # */ || pos >= max) {\n      return false;\n    }\n    // count heading level\n        level = 1;\n    ch = state.src.charCodeAt(++pos);\n    while (ch === 35 /* # */ && pos < max && level <= 6) {\n      level++;\n      ch = state.src.charCodeAt(++pos);\n    }\n    if (level > 6 || pos < max && !isSpace$5(ch)) {\n      return false;\n    }\n    if (silent) {\n      return true;\n    }\n    // Let's cut tails like '    ###  ' from the end of string\n        max = state.skipSpacesBack(max, pos);\n    tmp = state.skipCharsBack(max, 35, pos);\n // #\n        if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {\n      max = tmp;\n    }\n    state.line = startLine + 1;\n    token = state.push(\"heading_open\", \"h\" + String(level), 1);\n    token.markup = \"########\".slice(0, level);\n    token.map = [ startLine, state.line ];\n    token = state.push(\"inline\", \"\", 0);\n    token.content = state.src.slice(pos, max).trim();\n    token.map = [ startLine, state.line ];\n    token.children = [];\n    token = state.push(\"heading_close\", \"h\" + String(level), -1);\n    token.markup = \"########\".slice(0, level);\n    return true;\n  };\n  // lheading (---, ===)\n    var lheading = function lheading(state, startLine, endLine /*, silent*/) {\n    var content, terminate, i, l, token, pos, max, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules(\"paragraph\");\n    // if it's indented more than 3 spaces, it should be a code block\n        if (state.sCount[startLine] - state.blkIndent >= 4) {\n      return false;\n    }\n    oldParentType = state.parentType;\n    state.parentType = \"paragraph\";\n // use paragraph to match terminatorRules\n    // jump line-by-line until empty one or EOF\n        for (;nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.sCount[nextLine] - state.blkIndent > 3) {\n        continue;\n      }\n      \n      // Check for underline in setext header\n      \n            if (state.sCount[nextLine] >= state.blkIndent) {\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\n        max = state.eMarks[nextLine];\n        if (pos < max) {\n          marker = state.src.charCodeAt(pos);\n          if (marker === 45 /* - */ || marker === 61 /* = */) {\n            pos = state.skipChars(pos, marker);\n            pos = state.skipSpaces(pos);\n            if (pos >= max) {\n              level = marker === 61 /* = */ ? 1 : 2;\n              break;\n            }\n          }\n        }\n      }\n      // quirk for blockquotes, this line should already be checked by that rule\n            if (state.sCount[nextLine] < 0) {\n        continue;\n      }\n      // Some tags can terminate paragraph without empty line.\n            terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) {\n        break;\n      }\n    }\n    if (!level) {\n      // Didn't find valid underline\n      return false;\n    }\n    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n    state.line = nextLine + 1;\n    token = state.push(\"heading_open\", \"h\" + String(level), 1);\n    token.markup = String.fromCharCode(marker);\n    token.map = [ startLine, state.line ];\n    token = state.push(\"inline\", \"\", 0);\n    token.content = content;\n    token.map = [ startLine, state.line - 1 ];\n    token.children = [];\n    token = state.push(\"heading_close\", \"h\" + String(level), -1);\n    token.markup = String.fromCharCode(marker);\n    state.parentType = oldParentType;\n    return true;\n  };\n  // Paragraph\n    var paragraph = function paragraph(state, startLine /*, endLine*/) {\n    var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules(\"paragraph\"), endLine = state.lineMax;\n    oldParentType = state.parentType;\n    state.parentType = \"paragraph\";\n    // jump line-by-line until empty one or EOF\n        for (;nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.sCount[nextLine] - state.blkIndent > 3) {\n        continue;\n      }\n      // quirk for blockquotes, this line should already be checked by that rule\n            if (state.sCount[nextLine] < 0) {\n        continue;\n      }\n      // Some tags can terminate paragraph without empty line.\n            terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) {\n        break;\n      }\n    }\n    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n    state.line = nextLine;\n    token = state.push(\"paragraph_open\", \"p\", 1);\n    token.map = [ startLine, state.line ];\n    token = state.push(\"inline\", \"\", 0);\n    token.content = content;\n    token.map = [ startLine, state.line ];\n    token.children = [];\n    token = state.push(\"paragraph_close\", \"p\", -1);\n    state.parentType = oldParentType;\n    return true;\n  };\n  var isSpace$4 = utils.isSpace;\n  function StateBlock(src, md, env, tokens) {\n    var ch, s, start, pos, len, indent, offset, indent_found;\n    this.src = src;\n    // link to parser instance\n        this.md = md;\n    this.env = env;\n    \n    // Internal state vartiables\n    \n        this.tokens = tokens;\n    this.bMarks = [];\n // line begin offsets for fast jumps\n        this.eMarks = [];\n // line end offsets for fast jumps\n        this.tShift = [];\n // offsets of the first non-space characters (tabs not expanded)\n        this.sCount = [];\n // indents for each line (tabs expanded)\n    // An amount of virtual spaces (tabs expanded) between beginning\n    // of each line (bMarks) and real beginning of that line.\n    \n    // It exists only as a hack because blockquotes override bMarks\n    // losing information in the process.\n    \n    // It's used only when expanding tabs, you can think about it as\n    // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n    // means first tab should be expanded to 4-21%4 === 3 spaces.\n    \n        this.bsCount = [];\n    // block parser variables\n        this.blkIndent = 0;\n // required block content indent (for example, if we are\n    // inside a list, it would be positioned after list marker)\n        this.line = 0;\n // line index in src\n        this.lineMax = 0;\n // lines count\n        this.tight = false;\n // loose/tight mode for lists\n        this.ddIndent = -1;\n // indent of the current dd block (-1 if there isn't any)\n        this.listIndent = -1;\n // indent of the current list block (-1 if there isn't any)\n    // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n    // used in lists to determine if they interrupt a paragraph\n        this.parentType = \"root\";\n    this.level = 0;\n    // renderer\n        this.result = \"\";\n    // Create caches\n    // Generate markers.\n        s = this.src;\n    indent_found = false;\n    for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {\n      ch = s.charCodeAt(pos);\n      if (!indent_found) {\n        if (isSpace$4(ch)) {\n          indent++;\n          if (ch === 9) {\n            offset += 4 - offset % 4;\n          } else {\n            offset++;\n          }\n          continue;\n        } else {\n          indent_found = true;\n        }\n      }\n      if (ch === 10 || pos === len - 1) {\n        if (ch !== 10) {\n          pos++;\n        }\n        this.bMarks.push(start);\n        this.eMarks.push(pos);\n        this.tShift.push(indent);\n        this.sCount.push(offset);\n        this.bsCount.push(0);\n        indent_found = false;\n        indent = 0;\n        offset = 0;\n        start = pos + 1;\n      }\n    }\n    // Push fake entry to simplify cache bounds checks\n        this.bMarks.push(s.length);\n    this.eMarks.push(s.length);\n    this.tShift.push(0);\n    this.sCount.push(0);\n    this.bsCount.push(0);\n    this.lineMax = this.bMarks.length - 1;\n // don't count last fake line\n    }\n  // Push new token to \"stream\".\n  \n    StateBlock.prototype.push = function(type, tag, nesting) {\n    var token$1 = new token(type, tag, nesting);\n    token$1.block = true;\n    if (nesting < 0) this.level--;\n // closing tag\n        token$1.level = this.level;\n    if (nesting > 0) this.level++;\n // opening tag\n        this.tokens.push(token$1);\n    return token$1;\n  };\n  StateBlock.prototype.isEmpty = function isEmpty(line) {\n    return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n  };\n  StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n    for (var max = this.lineMax; from < max; from++) {\n      if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n        break;\n      }\n    }\n    return from;\n  };\n  // Skip spaces from given position.\n    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n    var ch;\n    for (var max = this.src.length; pos < max; pos++) {\n      ch = this.src.charCodeAt(pos);\n      if (!isSpace$4(ch)) {\n        break;\n      }\n    }\n    return pos;\n  };\n  // Skip spaces from given position in reverse.\n    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n    if (pos <= min) {\n      return pos;\n    }\n    while (pos > min) {\n      if (!isSpace$4(this.src.charCodeAt(--pos))) {\n        return pos + 1;\n      }\n    }\n    return pos;\n  };\n  // Skip char codes from given position\n    StateBlock.prototype.skipChars = function skipChars(pos, code) {\n    for (var max = this.src.length; pos < max; pos++) {\n      if (this.src.charCodeAt(pos) !== code) {\n        break;\n      }\n    }\n    return pos;\n  };\n  // Skip char codes reverse from given position - 1\n    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n    if (pos <= min) {\n      return pos;\n    }\n    while (pos > min) {\n      if (code !== this.src.charCodeAt(--pos)) {\n        return pos + 1;\n      }\n    }\n    return pos;\n  };\n  // cut lines range from source.\n    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n    var i, lineIndent, ch, first, last, queue, lineStart, line = begin;\n    if (begin >= end) {\n      return \"\";\n    }\n    queue = new Array(end - begin);\n    for (i = 0; line < end; line++, i++) {\n      lineIndent = 0;\n      lineStart = first = this.bMarks[line];\n      if (line + 1 < end || keepLastLF) {\n        // No need for bounds check because we have fake entry on tail.\n        last = this.eMarks[line] + 1;\n      } else {\n        last = this.eMarks[line];\n      }\n      while (first < last && lineIndent < indent) {\n        ch = this.src.charCodeAt(first);\n        if (isSpace$4(ch)) {\n          if (ch === 9) {\n            lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n          } else {\n            lineIndent++;\n          }\n        } else if (first - lineStart < this.tShift[line]) {\n          // patched tShift masked characters to look like spaces (blockquotes, list markers)\n          lineIndent++;\n        } else {\n          break;\n        }\n        first++;\n      }\n      if (lineIndent > indent) {\n        // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n        // with indent=2 becomes '  \\tfoobar'\n        queue[i] = new Array(lineIndent - indent + 1).join(\" \") + this.src.slice(first, last);\n      } else {\n        queue[i] = this.src.slice(first, last);\n      }\n    }\n    return queue.join(\"\");\n  };\n  // re-export Token class to use in block rules\n    StateBlock.prototype.Token = token;\n  var state_block = StateBlock;\n  var _rules$1 = [ \n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  [ \"table\", table, [ \"paragraph\", \"reference\" ] ], [ \"code\", code ], [ \"fence\", fence, [ \"paragraph\", \"reference\", \"blockquote\", \"list\" ] ], [ \"blockquote\", blockquote, [ \"paragraph\", \"reference\", \"blockquote\", \"list\" ] ], [ \"hr\", hr, [ \"paragraph\", \"reference\", \"blockquote\", \"list\" ] ], [ \"list\", list, [ \"paragraph\", \"reference\", \"blockquote\" ] ], [ \"reference\", reference ], [ \"html_block\", html_block, [ \"paragraph\", \"reference\", \"blockquote\" ] ], [ \"heading\", heading, [ \"paragraph\", \"reference\", \"blockquote\" ] ], [ \"lheading\", lheading ], [ \"paragraph\", paragraph ] ];\n  /**\n\t * new ParserBlock()\n\t **/  function ParserBlock() {\n    /**\n\t   * ParserBlock#ruler -> Ruler\n\t   *\n\t   * [[Ruler]] instance. Keep configuration of block rules.\n\t   **/\n    this.ruler = new ruler;\n    for (var i = 0; i < _rules$1.length; i++) {\n      this.ruler.push(_rules$1[i][0], _rules$1[i][1], {\n        alt: (_rules$1[i][2] || []).slice()\n      });\n    }\n  }\n  // Generate tokens for input range\n  \n    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {\n    var ok, i, rules = this.ruler.getRules(\"\"), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;\n    while (line < endLine) {\n      state.line = line = state.skipEmptyLines(line);\n      if (line >= endLine) {\n        break;\n      }\n      // Termination condition for nested calls.\n      // Nested calls currently used for blockquotes & lists\n            if (state.sCount[line] < state.blkIndent) {\n        break;\n      }\n      // If nesting level exceeded - skip tail to the end. That's not ordinary\n      // situation and we should not care about content.\n            if (state.level >= maxNesting) {\n        state.line = endLine;\n        break;\n      }\n      // Try all possible rules.\n      // On success, rule should:\n      \n      // - update `state.line`\n      // - update `state.tokens`\n      // - return true\n            for (i = 0; i < len; i++) {\n        ok = rules[i](state, line, endLine, false);\n        if (ok) {\n          break;\n        }\n      }\n      // set state.tight if we had an empty line before current tag\n      // i.e. latest empty line should not count\n            state.tight = !hasEmptyLines;\n      // paragraph might \"eat\" one newline after it in nested lists\n            if (state.isEmpty(state.line - 1)) {\n        hasEmptyLines = true;\n      }\n      line = state.line;\n      if (line < endLine && state.isEmpty(line)) {\n        hasEmptyLines = true;\n        line++;\n        state.line = line;\n      }\n    }\n  };\n  /**\n\t * ParserBlock.parse(str, md, env, outTokens)\n\t *\n\t * Process input string and push block tokens into `outTokens`\n\t **/  ParserBlock.prototype.parse = function(src, md, env, outTokens) {\n    var state;\n    if (!src) {\n      return;\n    }\n    state = new this.State(src, md, env, outTokens);\n    this.tokenize(state, state.line, state.lineMax);\n  };\n  ParserBlock.prototype.State = state_block;\n  var parser_block = ParserBlock;\n  // Skip text characters for text token, place those to pending buffer\n  // Rule to skip pure text\n  // '{}$%@~+=:' reserved for extentions\n  // !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n  // !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\n  // http://spec.commonmark.org/0.15/#ascii-punctuation-character\n    function isTerminatorChar(ch) {\n    switch (ch) {\n     case 10 /* \\n */ :\n     case 33 /* ! */ :\n     case 35 /* # */ :\n     case 36 /* $ */ :\n     case 37 /* % */ :\n     case 38 /* & */ :\n     case 42 /* * */ :\n     case 43 /* + */ :\n     case 45 /* - */ :\n     case 58 /* : */ :\n     case 60 /* < */ :\n     case 61 /* = */ :\n     case 62 /* > */ :\n     case 64 /* @ */ :\n     case 91 /* [ */ :\n     case 92 /* \\ */ :\n     case 93 /* ] */ :\n     case 94 /* ^ */ :\n     case 95 /* _ */ :\n     case 96 /* ` */ :\n     case 123 /* { */ :\n     case 125 /* } */ :\n     case 126 /* ~ */ :\n      return true;\n\n     default:\n      return false;\n    }\n  }\n  var text = function text(state, silent) {\n    var pos = state.pos;\n    while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n      pos++;\n    }\n    if (pos === state.pos) {\n      return false;\n    }\n    if (!silent) {\n      state.pending += state.src.slice(state.pos, pos);\n    }\n    state.pos = pos;\n    return true;\n  };\n  // Process links like https://example.org/\n  // RFC3986: scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;\n  var linkify = function linkify(state, silent) {\n    var pos, max, match, proto, link, url, fullUrl, token;\n    if (!state.md.options.linkify) return false;\n    if (state.linkLevel > 0) return false;\n    pos = state.pos;\n    max = state.posMax;\n    if (pos + 3 > max) return false;\n    if (state.src.charCodeAt(pos) !== 58 /* : */) return false;\n    if (state.src.charCodeAt(pos + 1) !== 47 /* / */) return false;\n    if (state.src.charCodeAt(pos + 2) !== 47 /* / */) return false;\n    match = state.pending.match(SCHEME_RE);\n    if (!match) return false;\n    proto = match[1];\n    link = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));\n    if (!link) return false;\n    url = link.url;\n    // disallow '*' at the end of the link (conflicts with emphasis)\n        url = url.replace(/\\*+$/, \"\");\n    fullUrl = state.md.normalizeLink(url);\n    if (!state.md.validateLink(fullUrl)) return false;\n    if (!silent) {\n      state.pending = state.pending.slice(0, -proto.length);\n      token = state.push(\"link_open\", \"a\", 1);\n      token.attrs = [ [ \"href\", fullUrl ] ];\n      token.markup = \"linkify\";\n      token.info = \"auto\";\n      token = state.push(\"text\", \"\", 0);\n      token.content = state.md.normalizeLinkText(url);\n      token = state.push(\"link_close\", \"a\", -1);\n      token.markup = \"linkify\";\n      token.info = \"auto\";\n    }\n    state.pos += url.length - proto.length;\n    return true;\n  };\n  var isSpace$3 = utils.isSpace;\n  var newline = function newline(state, silent) {\n    var pmax, max, ws, pos = state.pos;\n    if (state.src.charCodeAt(pos) !== 10 /* \\n */) {\n      return false;\n    }\n    pmax = state.pending.length - 1;\n    max = state.posMax;\n    // '  \\n' -> hardbreak\n    // Lookup in pending chars is bad practice! Don't copy to other rules!\n    // Pending string is stored in concat mode, indexed lookups will cause\n    // convertion to flat mode.\n        if (!silent) {\n      if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {\n        if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {\n          // Find whitespaces tail of pending chars.\n          ws = pmax - 1;\n          while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32) ws--;\n          state.pending = state.pending.slice(0, ws);\n          state.push(\"hardbreak\", \"br\", 0);\n        } else {\n          state.pending = state.pending.slice(0, -1);\n          state.push(\"softbreak\", \"br\", 0);\n        }\n      } else {\n        state.push(\"softbreak\", \"br\", 0);\n      }\n    }\n    pos++;\n    // skip heading spaces for next line\n        while (pos < max && isSpace$3(state.src.charCodeAt(pos))) {\n      pos++;\n    }\n    state.pos = pos;\n    return true;\n  };\n  var isSpace$2 = utils.isSpace;\n  var ESCAPED = [];\n  for (var i = 0; i < 256; i++) {\n    ESCAPED.push(0);\n  }\n  \"\\\\!\\\"#$%&'()*+,./:;<=>?@[]^_`{|}~-\".split(\"\").forEach((function(ch) {\n    ESCAPED[ch.charCodeAt(0)] = 1;\n  }));\n  var _escape = function escape(state, silent) {\n    var ch1, ch2, origStr, escapedStr, token, pos = state.pos, max = state.posMax;\n    if (state.src.charCodeAt(pos) !== 92 /* \\ */) return false;\n    pos++;\n    // '\\' at the end of the inline block\n        if (pos >= max) return false;\n    ch1 = state.src.charCodeAt(pos);\n    if (ch1 === 10) {\n      if (!silent) {\n        state.push(\"hardbreak\", \"br\", 0);\n      }\n      pos++;\n      // skip leading whitespaces from next line\n            while (pos < max) {\n        ch1 = state.src.charCodeAt(pos);\n        if (!isSpace$2(ch1)) break;\n        pos++;\n      }\n      state.pos = pos;\n      return true;\n    }\n    escapedStr = state.src[pos];\n    if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {\n      ch2 = state.src.charCodeAt(pos + 1);\n      if (ch2 >= 56320 && ch2 <= 57343) {\n        escapedStr += state.src[pos + 1];\n        pos++;\n      }\n    }\n    origStr = \"\\\\\" + escapedStr;\n    if (!silent) {\n      token = state.push(\"text_special\", \"\", 0);\n      if (ch1 < 256 && ESCAPED[ch1] !== 0) {\n        token.content = escapedStr;\n      } else {\n        token.content = origStr;\n      }\n      token.markup = origStr;\n      token.info = \"escape\";\n    }\n    state.pos = pos + 1;\n    return true;\n  };\n  // Parse backticks\n    var backticks = function backtick(state, silent) {\n    var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);\n    if (ch !== 96 /* ` */) {\n      return false;\n    }\n    start = pos;\n    pos++;\n    max = state.posMax;\n    // scan marker length\n        while (pos < max && state.src.charCodeAt(pos) === 96 /* ` */) {\n      pos++;\n    }\n    marker = state.src.slice(start, pos);\n    openerLength = marker.length;\n    if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {\n      if (!silent) state.pending += marker;\n      state.pos += openerLength;\n      return true;\n    }\n    matchStart = matchEnd = pos;\n    // Nothing found in the cache, scan until the end of the line (or until marker is found)\n        while ((matchStart = state.src.indexOf(\"`\", matchEnd)) !== -1) {\n      matchEnd = matchStart + 1;\n      // scan marker length\n            while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96 /* ` */) {\n        matchEnd++;\n      }\n      closerLength = matchEnd - matchStart;\n      if (closerLength === openerLength) {\n        // Found matching closer length.\n        if (!silent) {\n          token = state.push(\"code_inline\", \"code\", 0);\n          token.markup = marker;\n          token.content = state.src.slice(pos, matchStart).replace(/\\n/g, \" \").replace(/^ (.+) $/, \"$1\");\n        }\n        state.pos = matchEnd;\n        return true;\n      }\n      // Some different length found, put it in cache as upper limit of where closer can be found\n            state.backticks[closerLength] = matchStart;\n    }\n    // Scanned through the end, didn't find anything\n        state.backticksScanned = true;\n    if (!silent) state.pending += marker;\n    state.pos += openerLength;\n    return true;\n  };\n  // ~~strike through~~\n  // Insert each marker as a separate text token, and add it to delimiter list\n  \n    var tokenize$1 = function strikethrough(state, silent) {\n    var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);\n    if (silent) {\n      return false;\n    }\n    if (marker !== 126 /* ~ */) {\n      return false;\n    }\n    scanned = state.scanDelims(state.pos, true);\n    len = scanned.length;\n    ch = String.fromCharCode(marker);\n    if (len < 2) {\n      return false;\n    }\n    if (len % 2) {\n      token = state.push(\"text\", \"\", 0);\n      token.content = ch;\n      len--;\n    }\n    for (i = 0; i < len; i += 2) {\n      token = state.push(\"text\", \"\", 0);\n      token.content = ch + ch;\n      state.delimiters.push({\n        marker: marker,\n        length: 0,\n        // disable \"rule of 3\" length checks meant for emphasis\n        token: state.tokens.length - 1,\n        end: -1,\n        open: scanned.can_open,\n        close: scanned.can_close\n      });\n    }\n    state.pos += scanned.length;\n    return true;\n  };\n  function postProcess$1(state, delimiters) {\n    var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;\n    for (i = 0; i < max; i++) {\n      startDelim = delimiters[i];\n      if (startDelim.marker !== 126 /* ~ */) {\n        continue;\n      }\n      if (startDelim.end === -1) {\n        continue;\n      }\n      endDelim = delimiters[startDelim.end];\n      token = state.tokens[startDelim.token];\n      token.type = \"s_open\";\n      token.tag = \"s\";\n      token.nesting = 1;\n      token.markup = \"~~\";\n      token.content = \"\";\n      token = state.tokens[endDelim.token];\n      token.type = \"s_close\";\n      token.tag = \"s\";\n      token.nesting = -1;\n      token.markup = \"~~\";\n      token.content = \"\";\n      if (state.tokens[endDelim.token - 1].type === \"text\" && state.tokens[endDelim.token - 1].content === \"~\") {\n        loneMarkers.push(endDelim.token - 1);\n      }\n    }\n    // If a marker sequence has an odd number of characters, it's splitted\n    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n    // start of the sequence.\n    \n    // So, we have to move all those markers after subsequent s_close tags.\n    \n        while (loneMarkers.length) {\n      i = loneMarkers.pop();\n      j = i + 1;\n      while (j < state.tokens.length && state.tokens[j].type === \"s_close\") {\n        j++;\n      }\n      j--;\n      if (i !== j) {\n        token = state.tokens[j];\n        state.tokens[j] = state.tokens[i];\n        state.tokens[i] = token;\n      }\n    }\n  }\n  // Walk through delimiter list and replace text tokens with tags\n  \n    var postProcess_1$1 = function strikethrough(state) {\n    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;\n    postProcess$1(state, state.delimiters);\n    for (curr = 0; curr < max; curr++) {\n      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n        postProcess$1(state, tokens_meta[curr].delimiters);\n      }\n    }\n  };\n  var strikethrough = {\n    tokenize: tokenize$1,\n    postProcess: postProcess_1$1\n  };\n  // Process *this* and _that_\n  // Insert each marker as a separate text token, and add it to delimiter list\n  \n    var tokenize = function emphasis(state, silent) {\n    var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);\n    if (silent) {\n      return false;\n    }\n    if (marker !== 95 /* _ */ && marker !== 42 /* * */) {\n      return false;\n    }\n    scanned = state.scanDelims(state.pos, marker === 42);\n    for (i = 0; i < scanned.length; i++) {\n      token = state.push(\"text\", \"\", 0);\n      token.content = String.fromCharCode(marker);\n      state.delimiters.push({\n        // Char code of the starting marker (number).\n        marker: marker,\n        // Total length of these series of delimiters.\n        length: scanned.length,\n        // A position of the token this delimiter corresponds to.\n        token: state.tokens.length - 1,\n        // If this delimiter is matched as a valid opener, `end` will be\n        // equal to its position, otherwise it's `-1`.\n        end: -1,\n        // Boolean flags that determine if this delimiter could open or close\n        // an emphasis.\n        open: scanned.can_open,\n        close: scanned.can_close\n      });\n    }\n    state.pos += scanned.length;\n    return true;\n  };\n  function postProcess(state, delimiters) {\n    var i, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;\n    for (i = max - 1; i >= 0; i--) {\n      startDelim = delimiters[i];\n      if (startDelim.marker !== 95 /* _ */ && startDelim.marker !== 42 /* * */) {\n        continue;\n      }\n      // Process only opening markers\n            if (startDelim.end === -1) {\n        continue;\n      }\n      endDelim = delimiters[startDelim.end];\n      // If the previous delimiter has the same marker and is adjacent to this one,\n      // merge those into one strong delimiter.\n      \n      // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n      \n            isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && \n      // check that first two markers match and adjacent\n      delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && \n      // check that last two markers are adjacent (we can safely assume they match)\n      delimiters[startDelim.end + 1].token === endDelim.token + 1;\n      ch = String.fromCharCode(startDelim.marker);\n      token = state.tokens[startDelim.token];\n      token.type = isStrong ? \"strong_open\" : \"em_open\";\n      token.tag = isStrong ? \"strong\" : \"em\";\n      token.nesting = 1;\n      token.markup = isStrong ? ch + ch : ch;\n      token.content = \"\";\n      token = state.tokens[endDelim.token];\n      token.type = isStrong ? \"strong_close\" : \"em_close\";\n      token.tag = isStrong ? \"strong\" : \"em\";\n      token.nesting = -1;\n      token.markup = isStrong ? ch + ch : ch;\n      token.content = \"\";\n      if (isStrong) {\n        state.tokens[delimiters[i - 1].token].content = \"\";\n        state.tokens[delimiters[startDelim.end + 1].token].content = \"\";\n        i--;\n      }\n    }\n  }\n  // Walk through delimiter list and replace text tokens with tags\n  \n    var postProcess_1 = function emphasis(state) {\n    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;\n    postProcess(state, state.delimiters);\n    for (curr = 0; curr < max; curr++) {\n      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n        postProcess(state, tokens_meta[curr].delimiters);\n      }\n    }\n  };\n  var emphasis = {\n    tokenize: tokenize,\n    postProcess: postProcess_1\n  };\n  var normalizeReference$1 = utils.normalizeReference;\n  var isSpace$1 = utils.isSpace;\n  var link = function link(state, silent) {\n    var attrs, code, label, labelEnd, labelStart, pos, res, ref, token, href = \"\", title = \"\", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;\n    if (state.src.charCodeAt(state.pos) !== 91 /* [ */) {\n      return false;\n    }\n    labelStart = state.pos + 1;\n    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);\n    // parser failed to find ']', so it's not a valid link\n        if (labelEnd < 0) {\n      return false;\n    }\n    pos = labelEnd + 1;\n    if (pos < max && state.src.charCodeAt(pos) === 40 /* ( */) {\n      // Inline link\n      // might have found a valid shortcut link, disable reference parsing\n      parseReference = false;\n      // [link](  <href>  \"title\"  )\n      //        ^^ skipping these spaces\n            pos++;\n      for (;pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace$1(code) && code !== 10) {\n          break;\n        }\n      }\n      if (pos >= max) {\n        return false;\n      }\n      // [link](  <href>  \"title\"  )\n      //          ^^^^^^ parsing link destination\n            start = pos;\n      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n      if (res.ok) {\n        href = state.md.normalizeLink(res.str);\n        if (state.md.validateLink(href)) {\n          pos = res.pos;\n        } else {\n          href = \"\";\n        }\n        // [link](  <href>  \"title\"  )\n        //                ^^ skipping these spaces\n                start = pos;\n        for (;pos < max; pos++) {\n          code = state.src.charCodeAt(pos);\n          if (!isSpace$1(code) && code !== 10) {\n            break;\n          }\n        }\n        // [link](  <href>  \"title\"  )\n        //                  ^^^^^^^ parsing link title\n                res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n        if (pos < max && start !== pos && res.ok) {\n          title = res.str;\n          pos = res.pos;\n          // [link](  <href>  \"title\"  )\n          //                         ^^ skipping these spaces\n                    for (;pos < max; pos++) {\n            code = state.src.charCodeAt(pos);\n            if (!isSpace$1(code) && code !== 10) {\n              break;\n            }\n          }\n        }\n      }\n      if (pos >= max || state.src.charCodeAt(pos) !== 41 /* ) */) {\n        // parsing a valid shortcut link failed, fallback to reference\n        parseReference = true;\n      }\n      pos++;\n    }\n    if (parseReference) {\n      // Link reference\n      if (typeof state.env.references === \"undefined\") {\n        return false;\n      }\n      if (pos < max && state.src.charCodeAt(pos) === 91 /* [ */) {\n        start = pos + 1;\n        pos = state.md.helpers.parseLinkLabel(state, pos);\n        if (pos >= 0) {\n          label = state.src.slice(start, pos++);\n        } else {\n          pos = labelEnd + 1;\n        }\n      } else {\n        pos = labelEnd + 1;\n      }\n      // covers label === '' and label === undefined\n      // (collapsed reference link and shortcut reference link respectively)\n            if (!label) {\n        label = state.src.slice(labelStart, labelEnd);\n      }\n      ref = state.env.references[normalizeReference$1(label)];\n      if (!ref) {\n        state.pos = oldPos;\n        return false;\n      }\n      href = ref.href;\n      title = ref.title;\n    }\n    \n    // We found the end of the link, and know for a fact it's a valid link;\n    // so all that's left to do is to call tokenizer.\n    \n        if (!silent) {\n      state.pos = labelStart;\n      state.posMax = labelEnd;\n      token = state.push(\"link_open\", \"a\", 1);\n      token.attrs = attrs = [ [ \"href\", href ] ];\n      if (title) {\n        attrs.push([ \"title\", title ]);\n      }\n      state.linkLevel++;\n      state.md.inline.tokenize(state);\n      state.linkLevel--;\n      token = state.push(\"link_close\", \"a\", -1);\n    }\n    state.pos = pos;\n    state.posMax = max;\n    return true;\n  };\n  var normalizeReference = utils.normalizeReference;\n  var isSpace = utils.isSpace;\n  var image = function image(state, silent) {\n    var attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = \"\", oldPos = state.pos, max = state.posMax;\n    if (state.src.charCodeAt(state.pos) !== 33 /* ! */) {\n      return false;\n    }\n    if (state.src.charCodeAt(state.pos + 1) !== 91 /* [ */) {\n      return false;\n    }\n    labelStart = state.pos + 2;\n    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n    // parser failed to find ']', so it's not a valid link\n        if (labelEnd < 0) {\n      return false;\n    }\n    pos = labelEnd + 1;\n    if (pos < max && state.src.charCodeAt(pos) === 40 /* ( */) {\n      // Inline link\n      // [link](  <href>  \"title\"  )\n      //        ^^ skipping these spaces\n      pos++;\n      for (;pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 10) {\n          break;\n        }\n      }\n      if (pos >= max) {\n        return false;\n      }\n      // [link](  <href>  \"title\"  )\n      //          ^^^^^^ parsing link destination\n            start = pos;\n      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n      if (res.ok) {\n        href = state.md.normalizeLink(res.str);\n        if (state.md.validateLink(href)) {\n          pos = res.pos;\n        } else {\n          href = \"\";\n        }\n      }\n      // [link](  <href>  \"title\"  )\n      //                ^^ skipping these spaces\n            start = pos;\n      for (;pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 10) {\n          break;\n        }\n      }\n      // [link](  <href>  \"title\"  )\n      //                  ^^^^^^^ parsing link title\n            res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n      if (pos < max && start !== pos && res.ok) {\n        title = res.str;\n        pos = res.pos;\n        // [link](  <href>  \"title\"  )\n        //                         ^^ skipping these spaces\n                for (;pos < max; pos++) {\n          code = state.src.charCodeAt(pos);\n          if (!isSpace(code) && code !== 10) {\n            break;\n          }\n        }\n      } else {\n        title = \"\";\n      }\n      if (pos >= max || state.src.charCodeAt(pos) !== 41 /* ) */) {\n        state.pos = oldPos;\n        return false;\n      }\n      pos++;\n    } else {\n      // Link reference\n      if (typeof state.env.references === \"undefined\") {\n        return false;\n      }\n      if (pos < max && state.src.charCodeAt(pos) === 91 /* [ */) {\n        start = pos + 1;\n        pos = state.md.helpers.parseLinkLabel(state, pos);\n        if (pos >= 0) {\n          label = state.src.slice(start, pos++);\n        } else {\n          pos = labelEnd + 1;\n        }\n      } else {\n        pos = labelEnd + 1;\n      }\n      // covers label === '' and label === undefined\n      // (collapsed reference link and shortcut reference link respectively)\n            if (!label) {\n        label = state.src.slice(labelStart, labelEnd);\n      }\n      ref = state.env.references[normalizeReference(label)];\n      if (!ref) {\n        state.pos = oldPos;\n        return false;\n      }\n      href = ref.href;\n      title = ref.title;\n    }\n    \n    // We found the end of the link, and know for a fact it's a valid link;\n    // so all that's left to do is to call tokenizer.\n    \n        if (!silent) {\n      content = state.src.slice(labelStart, labelEnd);\n      state.md.inline.parse(content, state.md, state.env, tokens = []);\n      token = state.push(\"image\", \"img\", 0);\n      token.attrs = attrs = [ [ \"src\", href ], [ \"alt\", \"\" ] ];\n      token.children = tokens;\n      token.content = content;\n      if (title) {\n        attrs.push([ \"title\", title ]);\n      }\n    }\n    state.pos = pos;\n    state.posMax = max;\n    return true;\n  };\n  // Process autolinks '<protocol:...>'\n  /*eslint max-len:0*/  var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;\n  var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\\-]{1,31}):([^<>\\x00-\\x20]*)$/;\n  var autolink = function autolink(state, silent) {\n    var url, fullUrl, token, ch, start, max, pos = state.pos;\n    if (state.src.charCodeAt(pos) !== 60 /* < */) {\n      return false;\n    }\n    start = state.pos;\n    max = state.posMax;\n    for (;;) {\n      if (++pos >= max) return false;\n      ch = state.src.charCodeAt(pos);\n      if (ch === 60 /* < */) return false;\n      if (ch === 62 /* > */) break;\n    }\n    url = state.src.slice(start + 1, pos);\n    if (AUTOLINK_RE.test(url)) {\n      fullUrl = state.md.normalizeLink(url);\n      if (!state.md.validateLink(fullUrl)) {\n        return false;\n      }\n      if (!silent) {\n        token = state.push(\"link_open\", \"a\", 1);\n        token.attrs = [ [ \"href\", fullUrl ] ];\n        token.markup = \"autolink\";\n        token.info = \"auto\";\n        token = state.push(\"text\", \"\", 0);\n        token.content = state.md.normalizeLinkText(url);\n        token = state.push(\"link_close\", \"a\", -1);\n        token.markup = \"autolink\";\n        token.info = \"auto\";\n      }\n      state.pos += url.length + 2;\n      return true;\n    }\n    if (EMAIL_RE.test(url)) {\n      fullUrl = state.md.normalizeLink(\"mailto:\" + url);\n      if (!state.md.validateLink(fullUrl)) {\n        return false;\n      }\n      if (!silent) {\n        token = state.push(\"link_open\", \"a\", 1);\n        token.attrs = [ [ \"href\", fullUrl ] ];\n        token.markup = \"autolink\";\n        token.info = \"auto\";\n        token = state.push(\"text\", \"\", 0);\n        token.content = state.md.normalizeLinkText(url);\n        token = state.push(\"link_close\", \"a\", -1);\n        token.markup = \"autolink\";\n        token.info = \"auto\";\n      }\n      state.pos += url.length + 2;\n      return true;\n    }\n    return false;\n  };\n  var HTML_TAG_RE = html_re.HTML_TAG_RE;\n  function isLinkOpen(str) {\n    return /^<a[>\\s]/i.test(str);\n  }\n  function isLinkClose(str) {\n    return /^<\\/a\\s*>/i.test(str);\n  }\n  function isLetter(ch) {\n    /*eslint no-bitwise:0*/\n    var lc = ch | 32;\n // to lower case\n        return lc >= 97 /* a */ && lc <= 122 /* z */;\n  }\n  var html_inline = function html_inline(state, silent) {\n    var ch, match, max, token, pos = state.pos;\n    if (!state.md.options.html) {\n      return false;\n    }\n    // Check start\n        max = state.posMax;\n    if (state.src.charCodeAt(pos) !== 60 /* < */ || pos + 2 >= max) {\n      return false;\n    }\n    // Quick fail on second char\n        ch = state.src.charCodeAt(pos + 1);\n    if (ch !== 33 /* ! */ && ch !== 63 /* ? */ && ch !== 47 /* / */ && !isLetter(ch)) {\n      return false;\n    }\n    match = state.src.slice(pos).match(HTML_TAG_RE);\n    if (!match) {\n      return false;\n    }\n    if (!silent) {\n      token = state.push(\"html_inline\", \"\", 0);\n      token.content = state.src.slice(pos, pos + match[0].length);\n      if (isLinkOpen(token.content)) state.linkLevel++;\n      if (isLinkClose(token.content)) state.linkLevel--;\n    }\n    state.pos += match[0].length;\n    return true;\n  };\n  var has = utils.has;\n  var isValidEntityCode = utils.isValidEntityCode;\n  var fromCodePoint = utils.fromCodePoint;\n  var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;\n  var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;\n  var entity = function entity(state, silent) {\n    var ch, code, match, token, pos = state.pos, max = state.posMax;\n    if (state.src.charCodeAt(pos) !== 38 /* & */) return false;\n    if (pos + 1 >= max) return false;\n    ch = state.src.charCodeAt(pos + 1);\n    if (ch === 35 /* # */) {\n      match = state.src.slice(pos).match(DIGITAL_RE);\n      if (match) {\n        if (!silent) {\n          code = match[1][0].toLowerCase() === \"x\" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n          token = state.push(\"text_special\", \"\", 0);\n          token.content = isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);\n          token.markup = match[0];\n          token.info = \"entity\";\n        }\n        state.pos += match[0].length;\n        return true;\n      }\n    } else {\n      match = state.src.slice(pos).match(NAMED_RE);\n      if (match) {\n        if (has(entities, match[1])) {\n          if (!silent) {\n            token = state.push(\"text_special\", \"\", 0);\n            token.content = entities[match[1]];\n            token.markup = match[0];\n            token.info = \"entity\";\n          }\n          state.pos += match[0].length;\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  // For each opening emphasis-like marker find a matching closing one\n    function processDelimiters(state, delimiters) {\n    var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;\n    if (!max) return;\n    // headerIdx is the first delimiter of the current (where closer is) delimiter run\n        var headerIdx = 0;\n    var lastTokenIdx = -2;\n // needs any value lower than -1\n        var jumps = [];\n    for (closerIdx = 0; closerIdx < max; closerIdx++) {\n      closer = delimiters[closerIdx];\n      jumps.push(0);\n      // markers belong to same delimiter run if:\n      //  - they have adjacent tokens\n      //  - AND markers are the same\n      \n            if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n        headerIdx = closerIdx;\n      }\n      lastTokenIdx = closer.token;\n      // Length is only used for emphasis-specific \"rule of 3\",\n      // if it's not defined (in strikethrough or 3rd party plugins),\n      // we can default it to 0 to disable those checks.\n      \n            closer.length = closer.length || 0;\n      if (!closer.close) continue;\n      // Previously calculated lower bounds (previous fails)\n      // for each marker, each delimiter length modulo 3,\n      // and for whether this closer can be an opener;\n      // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460\n            if (!openersBottom.hasOwnProperty(closer.marker)) {\n        openersBottom[closer.marker] = [ -1, -1, -1, -1, -1, -1 ];\n      }\n      minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];\n      openerIdx = headerIdx - jumps[headerIdx] - 1;\n      newMinOpenerIdx = openerIdx;\n      for (;openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n        opener = delimiters[openerIdx];\n        if (opener.marker !== closer.marker) continue;\n        if (opener.open && opener.end < 0) {\n          isOddMatch = false;\n          // from spec:\n          \n          // If one of the delimiters can both open and close emphasis, then the\n          // sum of the lengths of the delimiter runs containing the opening and\n          // closing delimiters must not be a multiple of 3 unless both lengths\n          // are multiples of 3.\n          \n                    if (opener.close || closer.open) {\n            if ((opener.length + closer.length) % 3 === 0) {\n              if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n                isOddMatch = true;\n              }\n            }\n          }\n          if (!isOddMatch) {\n            // If previous delimiter cannot be an opener, we can safely skip\n            // the entire sequence in future checks. This is required to make\n            // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n            lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;\n            jumps[closerIdx] = closerIdx - openerIdx + lastJump;\n            jumps[openerIdx] = lastJump;\n            closer.open = false;\n            opener.end = closerIdx;\n            opener.close = false;\n            newMinOpenerIdx = -1;\n            // treat next token as start of run,\n            // it optimizes skips in **<...>**a**<...>** pathological case\n                        lastTokenIdx = -2;\n            break;\n          }\n        }\n      }\n      if (newMinOpenerIdx !== -1) {\n        // If match for this delimiter run failed, we want to set lower bound for\n        // future lookups. This is required to make sure algorithm has linear\n        // complexity.\n        // See details here:\n        // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n        openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;\n      }\n    }\n  }\n  var balance_pairs = function link_pairs(state) {\n    var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;\n    processDelimiters(state, state.delimiters);\n    for (curr = 0; curr < max; curr++) {\n      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n        processDelimiters(state, tokens_meta[curr].delimiters);\n      }\n    }\n  };\n  // Clean up tokens after emphasis and strikethrough postprocessing:\n    var fragments_join = function fragments_join(state) {\n    var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;\n    for (curr = last = 0; curr < max; curr++) {\n      // re-calculate levels after emphasis/strikethrough turns some text nodes\n      // into opening/closing tags\n      if (tokens[curr].nesting < 0) level--;\n // closing tag\n            tokens[curr].level = level;\n      if (tokens[curr].nesting > 0) level++;\n // opening tag\n            if (tokens[curr].type === \"text\" && curr + 1 < max && tokens[curr + 1].type === \"text\") {\n        // collapse two adjacent text nodes\n        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n      } else {\n        if (curr !== last) {\n          tokens[last] = tokens[curr];\n        }\n        last++;\n      }\n    }\n    if (curr !== last) {\n      tokens.length = last;\n    }\n  };\n  var isWhiteSpace = utils.isWhiteSpace;\n  var isPunctChar = utils.isPunctChar;\n  var isMdAsciiPunct = utils.isMdAsciiPunct;\n  function StateInline(src, md, env, outTokens) {\n    this.src = src;\n    this.env = env;\n    this.md = md;\n    this.tokens = outTokens;\n    this.tokens_meta = Array(outTokens.length);\n    this.pos = 0;\n    this.posMax = this.src.length;\n    this.level = 0;\n    this.pending = \"\";\n    this.pendingLevel = 0;\n    // Stores { start: end } pairs. Useful for backtrack\n    // optimization of pairs parse (emphasis, strikes).\n        this.cache = {};\n    // List of emphasis-like delimiters for current tag\n        this.delimiters = [];\n    // Stack of delimiter lists for upper level tags\n        this._prev_delimiters = [];\n    // backtick length => last seen position\n        this.backticks = {};\n    this.backticksScanned = false;\n    // Counter used to disable inline linkify-it execution\n    // inside <a> and markdown links\n        this.linkLevel = 0;\n  }\n  // Flush pending text\n  \n    StateInline.prototype.pushPending = function() {\n    var token$1 = new token(\"text\", \"\", 0);\n    token$1.content = this.pending;\n    token$1.level = this.pendingLevel;\n    this.tokens.push(token$1);\n    this.pending = \"\";\n    return token$1;\n  };\n  // Push new token to \"stream\".\n  // If pending text exists - flush it as text token\n  \n    StateInline.prototype.push = function(type, tag, nesting) {\n    if (this.pending) {\n      this.pushPending();\n    }\n    var token$1 = new token(type, tag, nesting);\n    var token_meta = null;\n    if (nesting < 0) {\n      // closing tag\n      this.level--;\n      this.delimiters = this._prev_delimiters.pop();\n    }\n    token$1.level = this.level;\n    if (nesting > 0) {\n      // opening tag\n      this.level++;\n      this._prev_delimiters.push(this.delimiters);\n      this.delimiters = [];\n      token_meta = {\n        delimiters: this.delimiters\n      };\n    }\n    this.pendingLevel = this.level;\n    this.tokens.push(token$1);\n    this.tokens_meta.push(token_meta);\n    return token$1;\n  };\n  // Scan a sequence of emphasis-like markers, and determine whether\n  // it can start an emphasis sequence or end an emphasis sequence.\n  \n  //  - start - position to scan from (it should point at a valid marker);\n  //  - canSplitWord - determine if these markers can be found inside a word\n  \n    StateInline.prototype.scanDelims = function(start, canSplitWord) {\n    var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);\n    // treat beginning of the line as a whitespace\n        lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;\n    while (pos < max && this.src.charCodeAt(pos) === marker) {\n      pos++;\n    }\n    count = pos - start;\n    // treat end of the line as a whitespace\n        nextChar = pos < max ? this.src.charCodeAt(pos) : 32;\n    isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n    isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n    isLastWhiteSpace = isWhiteSpace(lastChar);\n    isNextWhiteSpace = isWhiteSpace(nextChar);\n    if (isNextWhiteSpace) {\n      left_flanking = false;\n    } else if (isNextPunctChar) {\n      if (!(isLastWhiteSpace || isLastPunctChar)) {\n        left_flanking = false;\n      }\n    }\n    if (isLastWhiteSpace) {\n      right_flanking = false;\n    } else if (isLastPunctChar) {\n      if (!(isNextWhiteSpace || isNextPunctChar)) {\n        right_flanking = false;\n      }\n    }\n    if (!canSplitWord) {\n      can_open = left_flanking && (!right_flanking || isLastPunctChar);\n      can_close = right_flanking && (!left_flanking || isNextPunctChar);\n    } else {\n      can_open = left_flanking;\n      can_close = right_flanking;\n    }\n    return {\n      can_open: can_open,\n      can_close: can_close,\n      length: count\n    };\n  };\n  // re-export Token class to use in block rules\n    StateInline.prototype.Token = token;\n  var state_inline = StateInline;\n  ////////////////////////////////////////////////////////////////////////////////\n  // Parser rules\n    var _rules = [ [ \"text\", text ], [ \"linkify\", linkify ], [ \"newline\", newline ], [ \"escape\", _escape ], [ \"backticks\", backticks ], [ \"strikethrough\", strikethrough.tokenize ], [ \"emphasis\", emphasis.tokenize ], [ \"link\", link ], [ \"image\", image ], [ \"autolink\", autolink ], [ \"html_inline\", html_inline ], [ \"entity\", entity ] ];\n  // `rule2` ruleset was created specifically for emphasis/strikethrough\n  // post-processing and may be changed in the future.\n  \n  // Don't use this for anything except pairs (plugins working with `balance_pairs`).\n  \n    var _rules2 = [ [ \"balance_pairs\", balance_pairs ], [ \"strikethrough\", strikethrough.postProcess ], [ \"emphasis\", emphasis.postProcess ], \n  // rules for pairs separate '**' into its own text tokens, which may be left unused,\n  // rule below merges unused segments back with the rest of the text\n  [ \"fragments_join\", fragments_join ] ];\n  /**\n\t * new ParserInline()\n\t **/  function ParserInline() {\n    var i;\n    /**\n\t   * ParserInline#ruler -> Ruler\n\t   *\n\t   * [[Ruler]] instance. Keep configuration of inline rules.\n\t   **/    this.ruler = new ruler;\n    for (i = 0; i < _rules.length; i++) {\n      this.ruler.push(_rules[i][0], _rules[i][1]);\n    }\n    /**\n\t   * ParserInline#ruler2 -> Ruler\n\t   *\n\t   * [[Ruler]] instance. Second ruler used for post-processing\n\t   * (e.g. in emphasis-like rules).\n\t   **/    this.ruler2 = new ruler;\n    for (i = 0; i < _rules2.length; i++) {\n      this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n    }\n  }\n  // Skip single token by running all rules in validation mode;\n  // returns `true` if any rule reported success\n  \n    ParserInline.prototype.skipToken = function(state) {\n    var ok, i, pos = state.pos, rules = this.ruler.getRules(\"\"), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;\n    if (typeof cache[pos] !== \"undefined\") {\n      state.pos = cache[pos];\n      return;\n    }\n    if (state.level < maxNesting) {\n      for (i = 0; i < len; i++) {\n        // Increment state.level and decrement it later to limit recursion.\n        // It's harmless to do here, because no tokens are created. But ideally,\n        // we'd need a separate private state variable for this purpose.\n        state.level++;\n        ok = rules[i](state, true);\n        state.level--;\n        if (ok) {\n          break;\n        }\n      }\n    } else {\n      // Too much nesting, just skip until the end of the paragraph.\n      // NOTE: this will cause links to behave incorrectly in the following case,\n      //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n      //       [[[[[[[[[[[[[[[[[[[[[foo]()\n      // TODO: remove this workaround when CM standard will allow nested links\n      //       (we can replace it by preventing links from being parsed in\n      //       validation mode)\n      state.pos = state.posMax;\n    }\n    if (!ok) {\n      state.pos++;\n    }\n    cache[pos] = state.pos;\n  };\n  // Generate tokens for input range\n  \n    ParserInline.prototype.tokenize = function(state) {\n    var ok, i, rules = this.ruler.getRules(\"\"), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;\n    while (state.pos < end) {\n      // Try all possible rules.\n      // On success, rule should:\n      // - update `state.pos`\n      // - update `state.tokens`\n      // - return true\n      if (state.level < maxNesting) {\n        for (i = 0; i < len; i++) {\n          ok = rules[i](state, false);\n          if (ok) {\n            break;\n          }\n        }\n      }\n      if (ok) {\n        if (state.pos >= end) {\n          break;\n        }\n        continue;\n      }\n      state.pending += state.src[state.pos++];\n    }\n    if (state.pending) {\n      state.pushPending();\n    }\n  };\n  /**\n\t * ParserInline.parse(str, md, env, outTokens)\n\t *\n\t * Process input string and push inline tokens into `outTokens`\n\t **/  ParserInline.prototype.parse = function(str, md, env, outTokens) {\n    var i, rules, len;\n    var state = new this.State(str, md, env, outTokens);\n    this.tokenize(state);\n    rules = this.ruler2.getRules(\"\");\n    len = rules.length;\n    for (i = 0; i < len; i++) {\n      rules[i](state);\n    }\n  };\n  ParserInline.prototype.State = state_inline;\n  var parser_inline = ParserInline;\n  var re = function(opts) {\n    var re = {};\n    opts = opts || {};\n    // Use direct extract instead of `regenerate` to reduse browserified size\n        re.src_Any = regex$3.source;\n    re.src_Cc = regex$2.source;\n    re.src_Z = regex.source;\n    re.src_P = regex$4.source;\n    // \\p{\\Z\\P\\Cc\\CF} (white spaces + control + format + punctuation)\n        re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join(\"|\");\n    // \\p{\\Z\\Cc} (white spaces + control)\n        re.src_ZCc = [ re.src_Z, re.src_Cc ].join(\"|\");\n    // Experimental. List of chars, completely prohibited in links\n    // because can separate it from other part of text\n        var text_separators = \"[><\\uff5c]\";\n    // All possible word characters (everything without punctuation, spaces & controls)\n    // Defined via punctuation & spaces to save space\n    // Should be something like \\p{\\L\\N\\S\\M} (\\w but without `_`)\n        re.src_pseudo_letter = \"(?:(?!\" + text_separators + \"|\" + re.src_ZPCc + \")\" + re.src_Any + \")\";\n    // The same as abothe but without [0-9]\n    // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';\n    ////////////////////////////////////////////////////////////////////////////////\n        re.src_ip4 = \"(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\";\n    // Prohibit any of \"@/[]()\" in user/pass to avoid wrong domain fetch.\n        re.src_auth = \"(?:(?:(?!\" + re.src_ZCc + \"|[@/\\\\[\\\\]()]).)+@)?\";\n    re.src_port = \"(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?\";\n    re.src_host_terminator = \"(?=$|\" + text_separators + \"|\" + re.src_ZPCc + \")\" + \"(?!\" + (opts[\"---\"] ? \"-(?!--)|\" : \"-|\") + \"_|:\\\\d|\\\\.-|\\\\.(?!$|\" + re.src_ZPCc + \"))\";\n    re.src_path = \"(?:\" + \"[/?#]\" + \"(?:\" + \"(?!\" + re.src_ZCc + \"|\" + text_separators + \"|[()[\\\\]{}.,\\\"'?!\\\\-;]).|\" + \"\\\\[(?:(?!\" + re.src_ZCc + \"|\\\\]).)*\\\\]|\" + \"\\\\((?:(?!\" + re.src_ZCc + \"|[)]).)*\\\\)|\" + \"\\\\{(?:(?!\" + re.src_ZCc + \"|[}]).)*\\\\}|\" + '\\\\\"(?:(?!' + re.src_ZCc + '|[\"]).)+\\\\\"|' + \"\\\\'(?:(?!\" + re.src_ZCc + \"|[']).)+\\\\'|\" + \"\\\\'(?=\" + re.src_pseudo_letter + \"|[-])|\" + // allow `I'm_king` if no pair found\n    \"\\\\.{2,}[a-zA-Z0-9%/&]|\" + // google has many dots in \"google search\" links (#66, #81).\n    // github has ... in commit range links,\n    // Restrict to\n    // - english\n    // - percent-encoded\n    // - parts of file path\n    // - params separator\n    // until more examples found.\n    \"\\\\.(?!\" + re.src_ZCc + \"|[.]|$)|\" + (opts[\"---\"] ? \"\\\\-(?!--(?:[^-]|$))(?:-*)|\" : \"\\\\-+|\") + \",(?!\" + re.src_ZCc + \"|$)|\" + // allow `,,,` in paths\n    \";(?!\" + re.src_ZCc + \"|$)|\" + // allow `;` if not followed by space-like char\n    \"\\\\!+(?!\" + re.src_ZCc + \"|[!]|$)|\" + // allow `!!!` in paths, but not at the end\n    \"\\\\?(?!\" + re.src_ZCc + \"|[?]|$)\" + \")+\" + \"|\\\\/\" + \")?\";\n    // Allow anything in markdown spec, forbid quote (\") at the first position\n    // because emails enclosed in quotes are far more common\n        re.src_email_name = '[\\\\-;:&=\\\\+\\\\$,\\\\.a-zA-Z0-9_][\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]*';\n    re.src_xn = \"xn--[a-z0-9\\\\-]{1,59}\";\n    // More to read about domain names\n    // http://serverfault.com/questions/638260/\n        re.src_domain_root = \n    // Allow letters & digits (http://test1)\n    \"(?:\" + re.src_xn + \"|\" + re.src_pseudo_letter + \"{1,63}\" + \")\";\n    re.src_domain = \"(?:\" + re.src_xn + \"|\" + \"(?:\" + re.src_pseudo_letter + \")\" + \"|\" + \"(?:\" + re.src_pseudo_letter + \"(?:-|\" + re.src_pseudo_letter + \"){0,61}\" + re.src_pseudo_letter + \")\" + \")\";\n    re.src_host = \"(?:\" + \n    // Don't need IP check, because digits are already allowed in normal domain names\n    //   src_ip4 +\n    // '|' +\n    \"(?:(?:(?:\" + re.src_domain + \")\\\\.)*\" + re.src_domain /*_root*/ + \")\" + \")\";\n    re.tpl_host_fuzzy = \"(?:\" + re.src_ip4 + \"|\" + \"(?:(?:(?:\" + re.src_domain + \")\\\\.)+(?:%TLDS%))\" + \")\";\n    re.tpl_host_no_ip_fuzzy = \"(?:(?:(?:\" + re.src_domain + \")\\\\.)+(?:%TLDS%))\";\n    re.src_host_strict = re.src_host + re.src_host_terminator;\n    re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;\n    re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;\n    re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;\n    re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;\n    ////////////////////////////////////////////////////////////////////////////////\n    // Main rules\n    // Rude test fuzzy links by host, for quick deny\n        re.tpl_host_fuzzy_test = \"localhost|www\\\\.|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:\" + re.src_ZPCc + \"|>|$))\";\n    re.tpl_email_fuzzy = \"(^|\" + text_separators + '|\"|\\\\(|' + re.src_ZCc + \")\" + \"(\" + re.src_email_name + \"@\" + re.tpl_host_fuzzy_strict + \")\";\n    re.tpl_link_fuzzy = \n    // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n    // but can start with > (markdown blockquote)\n    \"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|\" + re.src_ZPCc + \"))\" + \"((?![$+<=>^`|\\uff5c])\" + re.tpl_host_port_fuzzy_strict + re.src_path + \")\";\n    re.tpl_link_no_ip_fuzzy = \n    // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n    // but can start with > (markdown blockquote)\n    \"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|\" + re.src_ZPCc + \"))\" + \"((?![$+<=>^`|\\uff5c])\" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + \")\";\n    return re;\n  };\n  ////////////////////////////////////////////////////////////////////////////////\n  // Helpers\n  // Merge objects\n  \n    function assign(obj /*from1, from2, from3, ...*/) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    sources.forEach((function(source) {\n      if (!source) {\n        return;\n      }\n      Object.keys(source).forEach((function(key) {\n        obj[key] = source[key];\n      }));\n    }));\n    return obj;\n  }\n  function _class(obj) {\n    return Object.prototype.toString.call(obj);\n  }\n  function isString(obj) {\n    return _class(obj) === \"[object String]\";\n  }\n  function isObject(obj) {\n    return _class(obj) === \"[object Object]\";\n  }\n  function isRegExp(obj) {\n    return _class(obj) === \"[object RegExp]\";\n  }\n  function isFunction(obj) {\n    return _class(obj) === \"[object Function]\";\n  }\n  function escapeRE(str) {\n    return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n  }\n  ////////////////////////////////////////////////////////////////////////////////\n    var defaultOptions = {\n    fuzzyLink: true,\n    fuzzyEmail: true,\n    fuzzyIP: false\n  };\n  function isOptionsObj(obj) {\n    return Object.keys(obj || {}).reduce((function(acc, k) {\n      return acc || defaultOptions.hasOwnProperty(k);\n    }), false);\n  }\n  var defaultSchemas = {\n    \"http:\": {\n      validate: function(text, pos, self) {\n        var tail = text.slice(pos);\n        if (!self.re.http) {\n          // compile lazily, because \"host\"-containing variables can change on tlds update.\n          self.re.http = new RegExp(\"^\\\\/\\\\/\" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, \"i\");\n        }\n        if (self.re.http.test(tail)) {\n          return tail.match(self.re.http)[0].length;\n        }\n        return 0;\n      }\n    },\n    \"https:\": \"http:\",\n    \"ftp:\": \"http:\",\n    \"//\": {\n      validate: function(text, pos, self) {\n        var tail = text.slice(pos);\n        if (!self.re.no_http) {\n          // compile lazily, because \"host\"-containing variables can change on tlds update.\n          self.re.no_http = new RegExp(\"^\" + self.re.src_auth + \n          // Don't allow single-level domains, because of false positives like '//test'\n          // with code comments\n          \"(?:localhost|(?:(?:\" + self.re.src_domain + \")\\\\.)+\" + self.re.src_domain_root + \")\" + self.re.src_port + self.re.src_host_terminator + self.re.src_path, \"i\");\n        }\n        if (self.re.no_http.test(tail)) {\n          // should not be `://` & `///`, that protects from errors in protocol name\n          if (pos >= 3 && text[pos - 3] === \":\") {\n            return 0;\n          }\n          if (pos >= 3 && text[pos - 3] === \"/\") {\n            return 0;\n          }\n          return tail.match(self.re.no_http)[0].length;\n        }\n        return 0;\n      }\n    },\n    \"mailto:\": {\n      validate: function(text, pos, self) {\n        var tail = text.slice(pos);\n        if (!self.re.mailto) {\n          self.re.mailto = new RegExp(\"^\" + self.re.src_email_name + \"@\" + self.re.src_host_strict, \"i\");\n        }\n        if (self.re.mailto.test(tail)) {\n          return tail.match(self.re.mailto)[0].length;\n        }\n        return 0;\n      }\n    }\n  };\n  /*eslint-disable max-len*/\n  // RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)\n    var tlds_2ch_src_re = \"a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]\";\n  // DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead\n    var tlds_default = \"biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\\u0440\\u0444\".split(\"|\");\n  /*eslint-enable max-len*/\n  ////////////////////////////////////////////////////////////////////////////////\n    function resetScanCache(self) {\n    self.__index__ = -1;\n    self.__text_cache__ = \"\";\n  }\n  function createValidator(re) {\n    return function(text, pos) {\n      var tail = text.slice(pos);\n      if (re.test(tail)) {\n        return tail.match(re)[0].length;\n      }\n      return 0;\n    };\n  }\n  function createNormalizer() {\n    return function(match, self) {\n      self.normalize(match);\n    };\n  }\n  // Schemas compiler. Build regexps.\n  \n    function compile(self) {\n    // Load & clone RE patterns.\n    var re$1 = self.re = re(self.__opts__);\n    // Define dynamic patterns\n        var tlds = self.__tlds__.slice();\n    self.onCompile();\n    if (!self.__tlds_replaced__) {\n      tlds.push(tlds_2ch_src_re);\n    }\n    tlds.push(re$1.src_xn);\n    re$1.src_tlds = tlds.join(\"|\");\n    function untpl(tpl) {\n      return tpl.replace(\"%TLDS%\", re$1.src_tlds);\n    }\n    re$1.email_fuzzy = RegExp(untpl(re$1.tpl_email_fuzzy), \"i\");\n    re$1.link_fuzzy = RegExp(untpl(re$1.tpl_link_fuzzy), \"i\");\n    re$1.link_no_ip_fuzzy = RegExp(untpl(re$1.tpl_link_no_ip_fuzzy), \"i\");\n    re$1.host_fuzzy_test = RegExp(untpl(re$1.tpl_host_fuzzy_test), \"i\");\n    \n    // Compile each schema\n    \n        var aliases = [];\n    self.__compiled__ = {};\n // Reset compiled data\n        function schemaError(name, val) {\n      throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val);\n    }\n    Object.keys(self.__schemas__).forEach((function(name) {\n      var val = self.__schemas__[name];\n      // skip disabled methods\n            if (val === null) {\n        return;\n      }\n      var compiled = {\n        validate: null,\n        link: null\n      };\n      self.__compiled__[name] = compiled;\n      if (isObject(val)) {\n        if (isRegExp(val.validate)) {\n          compiled.validate = createValidator(val.validate);\n        } else if (isFunction(val.validate)) {\n          compiled.validate = val.validate;\n        } else {\n          schemaError(name, val);\n        }\n        if (isFunction(val.normalize)) {\n          compiled.normalize = val.normalize;\n        } else if (!val.normalize) {\n          compiled.normalize = createNormalizer();\n        } else {\n          schemaError(name, val);\n        }\n        return;\n      }\n      if (isString(val)) {\n        aliases.push(name);\n        return;\n      }\n      schemaError(name, val);\n    }));\n    \n    // Compile postponed aliases\n    \n        aliases.forEach((function(alias) {\n      if (!self.__compiled__[self.__schemas__[alias]]) {\n        // Silently fail on missed schemas to avoid errons on disable.\n        // schemaError(alias, self.__schemas__[alias]);\n        return;\n      }\n      self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;\n      self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;\n    }));\n    \n    // Fake record for guessed links\n    \n        self.__compiled__[\"\"] = {\n      validate: null,\n      normalize: createNormalizer()\n    };\n    \n    // Build schema condition\n    \n        var slist = Object.keys(self.__compiled__).filter((function(name) {\n      // Filter disabled & fake schemas\n      return name.length > 0 && self.__compiled__[name];\n    })).map(escapeRE).join(\"|\");\n    // (?!_) cause 1.5x slowdown\n        self.re.schema_test = RegExp(\"(^|(?!_)(?:[><\\uff5c]|\" + re$1.src_ZPCc + \"))(\" + slist + \")\", \"i\");\n    self.re.schema_search = RegExp(\"(^|(?!_)(?:[><\\uff5c]|\" + re$1.src_ZPCc + \"))(\" + slist + \")\", \"ig\");\n    self.re.schema_at_start = RegExp(\"^\" + self.re.schema_search.source, \"i\");\n    self.re.pretest = RegExp(\"(\" + self.re.schema_test.source + \")|(\" + self.re.host_fuzzy_test.source + \")|@\", \"i\");\n    \n    // Cleanup\n    \n        resetScanCache(self);\n  }\n  /**\n\t * class Match\n\t *\n\t * Match result. Single element of array, returned by [[LinkifyIt#match]]\n\t **/  function Match(self, shift) {\n    var start = self.__index__, end = self.__last_index__, text = self.__text_cache__.slice(start, end);\n    /**\n\t   * Match#schema -> String\n\t   *\n\t   * Prefix (protocol) for matched string.\n\t   **/    this.schema = self.__schema__.toLowerCase();\n    /**\n\t   * Match#index -> Number\n\t   *\n\t   * First position of matched string.\n\t   **/    this.index = start + shift;\n    /**\n\t   * Match#lastIndex -> Number\n\t   *\n\t   * Next position after matched string.\n\t   **/    this.lastIndex = end + shift;\n    /**\n\t   * Match#raw -> String\n\t   *\n\t   * Matched string.\n\t   **/    this.raw = text;\n    /**\n\t   * Match#text -> String\n\t   *\n\t   * Notmalized text of matched string.\n\t   **/    this.text = text;\n    /**\n\t   * Match#url -> String\n\t   *\n\t   * Normalized url of matched string.\n\t   **/    this.url = text;\n  }\n  function createMatch(self, shift) {\n    var match = new Match(self, shift);\n    self.__compiled__[match.schema].normalize(match, self);\n    return match;\n  }\n  /**\n\t * class LinkifyIt\n\t **/\n  /**\n\t * new LinkifyIt(schemas, options)\n\t * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)\n\t * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n\t *\n\t * Creates new linkifier instance with optional additional schemas.\n\t * Can be called without `new` keyword for convenience.\n\t *\n\t * By default understands:\n\t *\n\t * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links\n\t * - \"fuzzy\" links and emails (example.com, foo@bar.com).\n\t *\n\t * `schemas` is an object, where each key/value describes protocol/rule:\n\t *\n\t * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`\n\t *   for example). `linkify-it` makes shure that prefix is not preceeded with\n\t *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.\n\t * - __value__ - rule to check tail after link prefix\n\t *   - _String_ - just alias to existing rule\n\t *   - _Object_\n\t *     - _validate_ - validator function (should return matched length on success),\n\t *       or `RegExp`.\n\t *     - _normalize_ - optional function to normalize text & url of matched result\n\t *       (for example, for @twitter mentions).\n\t *\n\t * `options`:\n\t *\n\t * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.\n\t * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts\n\t *   like version numbers. Default `false`.\n\t * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.\n\t *\n\t **/  function LinkifyIt(schemas, options) {\n    if (!(this instanceof LinkifyIt)) {\n      return new LinkifyIt(schemas, options);\n    }\n    if (!options) {\n      if (isOptionsObj(schemas)) {\n        options = schemas;\n        schemas = {};\n      }\n    }\n    this.__opts__ = assign({}, defaultOptions, options);\n    // Cache last tested result. Used to skip repeating steps on next `match` call.\n        this.__index__ = -1;\n    this.__last_index__ = -1;\n // Next scan position\n        this.__schema__ = \"\";\n    this.__text_cache__ = \"\";\n    this.__schemas__ = assign({}, defaultSchemas, schemas);\n    this.__compiled__ = {};\n    this.__tlds__ = tlds_default;\n    this.__tlds_replaced__ = false;\n    this.re = {};\n    compile(this);\n  }\n  /** chainable\n\t * LinkifyIt#add(schema, definition)\n\t * - schema (String): rule name (fixed pattern prefix)\n\t * - definition (String|RegExp|Object): schema definition\n\t *\n\t * Add new rule definition. See constructor description for details.\n\t **/  LinkifyIt.prototype.add = function add(schema, definition) {\n    this.__schemas__[schema] = definition;\n    compile(this);\n    return this;\n  };\n  /** chainable\n\t * LinkifyIt#set(options)\n\t * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n\t *\n\t * Set recognition options for links without schema.\n\t **/  LinkifyIt.prototype.set = function set(options) {\n    this.__opts__ = assign(this.__opts__, options);\n    return this;\n  };\n  /**\n\t * LinkifyIt#test(text) -> Boolean\n\t *\n\t * Searches linkifiable pattern and returns `true` on success or `false` on fail.\n\t **/  LinkifyIt.prototype.test = function test(text) {\n    // Reset scan cache\n    this.__text_cache__ = text;\n    this.__index__ = -1;\n    if (!text.length) {\n      return false;\n    }\n    var m, ml, me, len, shift, next, re, tld_pos, at_pos;\n    // try to scan for link with schema - that's the most simple rule\n        if (this.re.schema_test.test(text)) {\n      re = this.re.schema_search;\n      re.lastIndex = 0;\n      while ((m = re.exec(text)) !== null) {\n        len = this.testSchemaAt(text, m[2], re.lastIndex);\n        if (len) {\n          this.__schema__ = m[2];\n          this.__index__ = m.index + m[1].length;\n          this.__last_index__ = m.index + m[0].length + len;\n          break;\n        }\n      }\n    }\n    if (this.__opts__.fuzzyLink && this.__compiled__[\"http:\"]) {\n      // guess schemaless links\n      tld_pos = text.search(this.re.host_fuzzy_test);\n      if (tld_pos >= 0) {\n        // if tld is located after found link - no need to check fuzzy pattern\n        if (this.__index__ < 0 || tld_pos < this.__index__) {\n          if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n            shift = ml.index + ml[1].length;\n            if (this.__index__ < 0 || shift < this.__index__) {\n              this.__schema__ = \"\";\n              this.__index__ = shift;\n              this.__last_index__ = ml.index + ml[0].length;\n            }\n          }\n        }\n      }\n    }\n    if (this.__opts__.fuzzyEmail && this.__compiled__[\"mailto:\"]) {\n      // guess schemaless emails\n      at_pos = text.indexOf(\"@\");\n      if (at_pos >= 0) {\n        // We can't skip this check, because this cases are possible:\n        // 192.168.1.1@gmail.com, my.in@example.com\n        if ((me = text.match(this.re.email_fuzzy)) !== null) {\n          shift = me.index + me[1].length;\n          next = me.index + me[0].length;\n          if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {\n            this.__schema__ = \"mailto:\";\n            this.__index__ = shift;\n            this.__last_index__ = next;\n          }\n        }\n      }\n    }\n    return this.__index__ >= 0;\n  };\n  /**\n\t * LinkifyIt#pretest(text) -> Boolean\n\t *\n\t * Very quick check, that can give false positives. Returns true if link MAY BE\n\t * can exists. Can be used for speed optimization, when you need to check that\n\t * link NOT exists.\n\t **/  LinkifyIt.prototype.pretest = function pretest(text) {\n    return this.re.pretest.test(text);\n  };\n  /**\n\t * LinkifyIt#testSchemaAt(text, name, position) -> Number\n\t * - text (String): text to scan\n\t * - name (String): rule (schema) name\n\t * - position (Number): text offset to check from\n\t *\n\t * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly\n\t * at given position. Returns length of found pattern (0 on fail).\n\t **/  LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {\n    // If not supported schema check requested - terminate\n    if (!this.__compiled__[schema.toLowerCase()]) {\n      return 0;\n    }\n    return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);\n  };\n  /**\n\t * LinkifyIt#match(text) -> Array|null\n\t *\n\t * Returns array of found link descriptions or `null` on fail. We strongly\n\t * recommend to use [[LinkifyIt#test]] first, for best speed.\n\t *\n\t * ##### Result match description\n\t *\n\t * - __schema__ - link schema, can be empty for fuzzy links, or `//` for\n\t *   protocol-neutral  links.\n\t * - __index__ - offset of matched text\n\t * - __lastIndex__ - index of next char after mathch end\n\t * - __raw__ - matched text\n\t * - __text__ - normalized text\n\t * - __url__ - link, generated from matched text\n\t **/  LinkifyIt.prototype.match = function match(text) {\n    var shift = 0, result = [];\n    // Try to take previous element from cache, if .test() called before\n        if (this.__index__ >= 0 && this.__text_cache__ === text) {\n      result.push(createMatch(this, shift));\n      shift = this.__last_index__;\n    }\n    // Cut head if cache was used\n        var tail = shift ? text.slice(shift) : text;\n    // Scan string until end reached\n        while (this.test(tail)) {\n      result.push(createMatch(this, shift));\n      tail = tail.slice(this.__last_index__);\n      shift += this.__last_index__;\n    }\n    if (result.length) {\n      return result;\n    }\n    return null;\n  };\n  /**\n\t * LinkifyIt#matchAtStart(text) -> Match|null\n\t *\n\t * Returns fully-formed (not fuzzy) link if it starts at the beginning\n\t * of the string, and null otherwise.\n\t **/  LinkifyIt.prototype.matchAtStart = function matchAtStart(text) {\n    // Reset scan cache\n    this.__text_cache__ = text;\n    this.__index__ = -1;\n    if (!text.length) return null;\n    var m = this.re.schema_at_start.exec(text);\n    if (!m) return null;\n    var len = this.testSchemaAt(text, m[2], m[0].length);\n    if (!len) return null;\n    this.__schema__ = m[2];\n    this.__index__ = m.index + m[1].length;\n    this.__last_index__ = m.index + m[0].length + len;\n    return createMatch(this, 0);\n  };\n  /** chainable\n\t * LinkifyIt#tlds(list [, keepOld]) -> this\n\t * - list (Array): list of tlds\n\t * - keepOld (Boolean): merge with current list if `true` (`false` by default)\n\t *\n\t * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)\n\t * to avoid false positives. By default this algorythm used:\n\t *\n\t * - hostname with any 2-letter root zones are ok.\n\t * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\n\t *   are ok.\n\t * - encoded (`xn--...`) root zones are ok.\n\t *\n\t * If list is replaced, then exact match for 2-chars root zones will be checked.\n\t **/  LinkifyIt.prototype.tlds = function tlds(list, keepOld) {\n    list = Array.isArray(list) ? list : [ list ];\n    if (!keepOld) {\n      this.__tlds__ = list.slice();\n      this.__tlds_replaced__ = true;\n      compile(this);\n      return this;\n    }\n    this.__tlds__ = this.__tlds__.concat(list).sort().filter((function(el, idx, arr) {\n      return el !== arr[idx - 1];\n    })).reverse();\n    compile(this);\n    return this;\n  };\n  /**\n\t * LinkifyIt#normalize(match)\n\t *\n\t * Default normalizer (if schema does not define it's own).\n\t **/  LinkifyIt.prototype.normalize = function normalize(match) {\n    // Do minimal possible changes by default. Need to collect feedback prior\n    // to move forward https://github.com/markdown-it/linkify-it/issues/1\n    if (!match.schema) {\n      match.url = \"http://\" + match.url;\n    }\n    if (match.schema === \"mailto:\" && !/^mailto:/i.test(match.url)) {\n      match.url = \"mailto:\" + match.url;\n    }\n  };\n  /**\n\t * LinkifyIt#onCompile()\n\t *\n\t * Override to modify basic RegExp-s.\n\t **/  LinkifyIt.prototype.onCompile = function onCompile() {};\n  var linkifyIt = LinkifyIt;\n  /*! https://mths.be/punycode v1.4.1 by @mathias */\n  /** Highest positive signed 32-bit float value */  var maxInt = 2147483647;\n // aka. 0x7FFFFFFF or 2^31-1\n  /** Bootstring parameters */  var base = 36;\n  var tMin = 1;\n  var tMax = 26;\n  var skew = 38;\n  var damp = 700;\n  var initialBias = 72;\n  var initialN = 128;\n // 0x80\n    var delimiter = \"-\";\n // '\\x2D'\n  /** Regular expressions */  var regexPunycode = /^xn--/;\n  var regexNonASCII = /[^\\x20-\\x7E]/;\n // unprintable ASCII chars + non-ASCII chars\n    var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\n // RFC 3490 separators\n  /** Error messages */  var errors = {\n    overflow: \"Overflow: input needs wider integers to process\",\n    \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n    \"invalid-input\": \"Invalid input\"\n  };\n  /** Convenience shortcuts */  var baseMinusTMin = base - tMin;\n  var floor = Math.floor;\n  var stringFromCharCode = String.fromCharCode;\n  /*--------------------------------------------------------------------------*/\n  /**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */  function error(type) {\n    throw new RangeError(errors[type]);\n  }\n  /**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */  function map(array, fn) {\n    var length = array.length;\n    var result = [];\n    while (length--) {\n      result[length] = fn(array[length]);\n    }\n    return result;\n  }\n  /**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */  function mapDomain(string, fn) {\n    var parts = string.split(\"@\");\n    var result = \"\";\n    if (parts.length > 1) {\n      // In email addresses, only the domain name should be punycoded. Leave\n      // the local part (i.e. everything up to `@`) intact.\n      result = parts[0] + \"@\";\n      string = parts[1];\n    }\n    // Avoid `split(regex)` for IE8 compatibility. See #17.\n        string = string.replace(regexSeparators, \".\");\n    var labels = string.split(\".\");\n    var encoded = map(labels, fn).join(\".\");\n    return result + encoded;\n  }\n  /**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */  function ucs2decode(string) {\n    var output = [], counter = 0, length = string.length, value, extra;\n    while (counter < length) {\n      value = string.charCodeAt(counter++);\n      if (value >= 55296 && value <= 56319 && counter < length) {\n        // high surrogate, and there is a next character\n        extra = string.charCodeAt(counter++);\n        if ((extra & 64512) == 56320) {\n          // low surrogate\n          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);\n        } else {\n          // unmatched surrogate; only append this code unit, in case the next\n          // code unit is the high surrogate of a surrogate pair\n          output.push(value);\n          counter--;\n        }\n      } else {\n        output.push(value);\n      }\n    }\n    return output;\n  }\n  /**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */  function ucs2encode(array) {\n    return map(array, (function(value) {\n      var output = \"\";\n      if (value > 65535) {\n        value -= 65536;\n        output += stringFromCharCode(value >>> 10 & 1023 | 55296);\n        value = 56320 | value & 1023;\n      }\n      output += stringFromCharCode(value);\n      return output;\n    })).join(\"\");\n  }\n  /**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */  function basicToDigit(codePoint) {\n    if (codePoint - 48 < 10) {\n      return codePoint - 22;\n    }\n    if (codePoint - 65 < 26) {\n      return codePoint - 65;\n    }\n    if (codePoint - 97 < 26) {\n      return codePoint - 97;\n    }\n    return base;\n  }\n  /**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */  function digitToBasic(digit, flag) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n  }\n  /**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */  function adapt(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n    for (;delta > baseMinusTMin * tMax >> 1; k += base) {\n      delta = floor(delta / baseMinusTMin);\n    }\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n  }\n  /**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */  function decode(input) {\n    // Don't use UCS-2\n    var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, \n    /** Cached calculation results */\n    baseMinusT;\n    // Handle the basic code points: let `basic` be the number of input code\n    // points before the last delimiter, or `0` if there is none, then copy\n    // the first basic code points to the output.\n        basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n      basic = 0;\n    }\n    for (j = 0; j < basic; ++j) {\n      // if it's not a basic code point\n      if (input.charCodeAt(j) >= 128) {\n        error(\"not-basic\");\n      }\n      output.push(input.charCodeAt(j));\n    }\n    // Main decoding loop: start just after the last delimiter if any basic code\n    // points were copied; start at the beginning otherwise.\n        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {\n      // `index` is the index of the next character to be consumed.\n      // Decode a generalized variable-length integer into `delta`,\n      // which gets added to `i`. The overflow checking is easier\n      // if we increase `i` as we go, then subtract off its starting\n      // value at the end to obtain `delta`.\n      for (oldi = i, w = 1, k = base; ;k += base) {\n        if (index >= inputLength) {\n          error(\"invalid-input\");\n        }\n        digit = basicToDigit(input.charCodeAt(index++));\n        if (digit >= base || digit > floor((maxInt - i) / w)) {\n          error(\"overflow\");\n        }\n        i += digit * w;\n        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n        if (digit < t) {\n          break;\n        }\n        baseMinusT = base - t;\n        if (w > floor(maxInt / baseMinusT)) {\n          error(\"overflow\");\n        }\n        w *= baseMinusT;\n      }\n      out = output.length + 1;\n      bias = adapt(i - oldi, out, oldi == 0);\n      // `i` was supposed to wrap around from `out` to `0`,\n      // incrementing `n` each time, so we'll fix that now:\n            if (floor(i / out) > maxInt - n) {\n        error(\"overflow\");\n      }\n      n += floor(i / out);\n      i %= out;\n      // Insert `n` at position `i` of the output\n            output.splice(i++, 0, n);\n    }\n    return ucs2encode(output);\n  }\n  /**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */  function encode(input) {\n    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], \n    /** `inputLength` will hold the number of code points in `input`. */\n    inputLength, \n    /** Cached calculation results */\n    handledCPCountPlusOne, baseMinusT, qMinusT;\n    // Convert the input in UCS-2 to Unicode\n        input = ucs2decode(input);\n    // Cache the length\n        inputLength = input.length;\n    // Initialize the state\n        n = initialN;\n    delta = 0;\n    bias = initialBias;\n    // Handle the basic code points\n        for (j = 0; j < inputLength; ++j) {\n      currentValue = input[j];\n      if (currentValue < 128) {\n        output.push(stringFromCharCode(currentValue));\n      }\n    }\n    handledCPCount = basicLength = output.length;\n    // `handledCPCount` is the number of code points that have been handled;\n    // `basicLength` is the number of basic code points.\n    // Finish the basic string - if it is not empty - with a delimiter\n        if (basicLength) {\n      output.push(delimiter);\n    }\n    // Main encoding loop:\n        while (handledCPCount < inputLength) {\n      // All non-basic code points < n have been handled already. Find the next\n      // larger one:\n      for (m = maxInt, j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n        if (currentValue >= n && currentValue < m) {\n          m = currentValue;\n        }\n      }\n      // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n      // but guard against overflow\n            handledCPCountPlusOne = handledCPCount + 1;\n      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n        error(\"overflow\");\n      }\n      delta += (m - n) * handledCPCountPlusOne;\n      n = m;\n      for (j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n        if (currentValue < n && ++delta > maxInt) {\n          error(\"overflow\");\n        }\n        if (currentValue == n) {\n          // Represent delta as a generalized variable-length integer\n          for (q = delta, k = base; ;k += base) {\n            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n            if (q < t) {\n              break;\n            }\n            qMinusT = q - t;\n            baseMinusT = base - t;\n            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n            q = floor(qMinusT / baseMinusT);\n          }\n          output.push(stringFromCharCode(digitToBasic(q, 0)));\n          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n          delta = 0;\n          ++handledCPCount;\n        }\n      }\n      ++delta;\n      ++n;\n    }\n    return output.join(\"\");\n  }\n  /**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */  function toUnicode(input) {\n    return mapDomain(input, (function(string) {\n      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n    }));\n  }\n  /**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */  function toASCII(input) {\n    return mapDomain(input, (function(string) {\n      return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n    }));\n  }\n  var version = \"1.4.1\";\n  /**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */  var ucs2 = {\n    decode: ucs2decode,\n    encode: ucs2encode\n  };\n  var punycode$1 = {\n    version: version,\n    ucs2: ucs2,\n    toASCII: toASCII,\n    toUnicode: toUnicode,\n    encode: encode,\n    decode: decode\n  };\n  var punycode$2 =  Object.freeze({\n    __proto__: null,\n    decode: decode,\n    encode: encode,\n    toUnicode: toUnicode,\n    toASCII: toASCII,\n    version: version,\n    ucs2: ucs2,\n    default: punycode$1\n  });\n  // markdown-it default options\n    var _default = {\n    options: {\n      html: false,\n      // Enable HTML tags in source\n      xhtmlOut: false,\n      // Use '/' to close single tags (<br />)\n      breaks: false,\n      // Convert '\\n' in paragraphs into <br>\n      langPrefix: \"language-\",\n      // CSS language prefix for fenced blocks\n      linkify: false,\n      // autoconvert URL-like texts to links\n      // Enable some language-neutral replacements + quotes beautification\n      typographer: false,\n      // Double + single quotes replacement pairs, when typographer enabled,\n      // and smartquotes on. Could be either a String or an Array.\n      // For example, you can use '' for Russian, '' for German,\n      // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n      quotes: \"\\u201c\\u201d\\u2018\\u2019\",\n      /*  */\n      // Highlighter function. Should return escaped HTML,\n      // or '' if the source string is not changed and should be escaped externaly.\n      // If result starts with <pre... internal wrapper is skipped.\n      // function (/*str, lang*/) { return ''; }\n      highlight: null,\n      maxNesting: 100\n    },\n    components: {\n      core: {},\n      block: {},\n      inline: {}\n    }\n  };\n  // \"Zero\" preset, with nothing enabled. Useful for manual configuring of simple\n    var zero = {\n    options: {\n      html: false,\n      // Enable HTML tags in source\n      xhtmlOut: false,\n      // Use '/' to close single tags (<br />)\n      breaks: false,\n      // Convert '\\n' in paragraphs into <br>\n      langPrefix: \"language-\",\n      // CSS language prefix for fenced blocks\n      linkify: false,\n      // autoconvert URL-like texts to links\n      // Enable some language-neutral replacements + quotes beautification\n      typographer: false,\n      // Double + single quotes replacement pairs, when typographer enabled,\n      // and smartquotes on. Could be either a String or an Array.\n      // For example, you can use '' for Russian, '' for German,\n      // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n      quotes: \"\\u201c\\u201d\\u2018\\u2019\",\n      /*  */\n      // Highlighter function. Should return escaped HTML,\n      // or '' if the source string is not changed and should be escaped externaly.\n      // If result starts with <pre... internal wrapper is skipped.\n      // function (/*str, lang*/) { return ''; }\n      highlight: null,\n      maxNesting: 20\n    },\n    components: {\n      core: {\n        rules: [ \"normalize\", \"block\", \"inline\", \"text_join\" ]\n      },\n      block: {\n        rules: [ \"paragraph\" ]\n      },\n      inline: {\n        rules: [ \"text\" ],\n        rules2: [ \"balance_pairs\", \"fragments_join\" ]\n      }\n    }\n  };\n  // Commonmark default options\n    var commonmark = {\n    options: {\n      html: true,\n      // Enable HTML tags in source\n      xhtmlOut: true,\n      // Use '/' to close single tags (<br />)\n      breaks: false,\n      // Convert '\\n' in paragraphs into <br>\n      langPrefix: \"language-\",\n      // CSS language prefix for fenced blocks\n      linkify: false,\n      // autoconvert URL-like texts to links\n      // Enable some language-neutral replacements + quotes beautification\n      typographer: false,\n      // Double + single quotes replacement pairs, when typographer enabled,\n      // and smartquotes on. Could be either a String or an Array.\n      // For example, you can use '' for Russian, '' for German,\n      // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n      quotes: \"\\u201c\\u201d\\u2018\\u2019\",\n      /*  */\n      // Highlighter function. Should return escaped HTML,\n      // or '' if the source string is not changed and should be escaped externaly.\n      // If result starts with <pre... internal wrapper is skipped.\n      // function (/*str, lang*/) { return ''; }\n      highlight: null,\n      maxNesting: 20\n    },\n    components: {\n      core: {\n        rules: [ \"normalize\", \"block\", \"inline\", \"text_join\" ]\n      },\n      block: {\n        rules: [ \"blockquote\", \"code\", \"fence\", \"heading\", \"hr\", \"html_block\", \"lheading\", \"list\", \"reference\", \"paragraph\" ]\n      },\n      inline: {\n        rules: [ \"autolink\", \"backticks\", \"emphasis\", \"entity\", \"escape\", \"html_inline\", \"image\", \"link\", \"newline\", \"text\" ],\n        rules2: [ \"balance_pairs\", \"emphasis\", \"fragments_join\" ]\n      }\n    }\n  };\n  var punycode =  getAugmentedNamespace(punycode$2);\n  var config = {\n    default: _default,\n    zero: zero,\n    commonmark: commonmark\n  };\n  ////////////////////////////////////////////////////////////////////////////////\n  \n  // This validator can prohibit more than really needed to prevent XSS. It's a\n  // tradeoff to keep code simple and to be secure by default.\n  \n  // If you need different setup - override validator method as you wish. Or\n  // replace it with dummy function and use external sanitizer.\n  \n    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;\n  var GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/;\n  function validateLink(url) {\n    // url should be normalized at this point, and existing entities are decoded\n    var str = url.trim().toLowerCase();\n    return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;\n  }\n  ////////////////////////////////////////////////////////////////////////////////\n    var RECODE_HOSTNAME_FOR = [ \"http:\", \"https:\", \"mailto:\" ];\n  function normalizeLink(url) {\n    var parsed = mdurl.parse(url, true);\n    if (parsed.hostname) {\n      // Encode hostnames in urls like:\n      // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n      // We don't encode unknown schemas, because it's likely that we encode\n      // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n        try {\n          parsed.hostname = punycode.toASCII(parsed.hostname);\n        } catch (er) {}\n      }\n    }\n    return mdurl.encode(mdurl.format(parsed));\n  }\n  function normalizeLinkText(url) {\n    var parsed = mdurl.parse(url, true);\n    if (parsed.hostname) {\n      // Encode hostnames in urls like:\n      // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n      // We don't encode unknown schemas, because it's likely that we encode\n      // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n        try {\n          parsed.hostname = punycode.toUnicode(parsed.hostname);\n        } catch (er) {}\n      }\n    }\n    // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720\n        return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + \"%\");\n  }\n  /**\n\t * class MarkdownIt\n\t *\n\t * Main parser/renderer class.\n\t *\n\t * ##### Usage\n\t *\n\t * ```javascript\n\t * // node.js, \"classic\" way:\n\t * var MarkdownIt = require('markdown-it'),\n\t *     md = new MarkdownIt();\n\t * var result = md.render('# markdown-it rulezz!');\n\t *\n\t * // node.js, the same, but with sugar:\n\t * var md = require('markdown-it')();\n\t * var result = md.render('# markdown-it rulezz!');\n\t *\n\t * // browser without AMD, added to \"window\" on script load\n\t * // Note, there are no dash.\n\t * var md = window.markdownit();\n\t * var result = md.render('# markdown-it rulezz!');\n\t * ```\n\t *\n\t * Single line rendering, without paragraph wrap:\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')();\n\t * var result = md.renderInline('__markdown-it__ rulezz!');\n\t * ```\n\t **/\n  /**\n\t * new MarkdownIt([presetName, options])\n\t * - presetName (String): optional, `commonmark` / `zero`\n\t * - options (Object)\n\t *\n\t * Creates parser instanse with given config. Can be called without `new`.\n\t *\n\t * ##### presetName\n\t *\n\t * MarkdownIt provides named presets as a convenience to quickly\n\t * enable/disable active syntax rules and options for common use cases.\n\t *\n\t * - [\"commonmark\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -\n\t *   configures parser to strict [CommonMark](http://commonmark.org/) mode.\n\t * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -\n\t *   similar to GFM, used when no preset name given. Enables all available rules,\n\t *   but still without html, typographer & autolinker.\n\t * - [\"zero\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -\n\t *   all rules disabled. Useful to quickly setup your config via `.enable()`.\n\t *   For example, when you need only `bold` and `italic` markup and nothing else.\n\t *\n\t * ##### options:\n\t *\n\t * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!\n\t *   That's not safe! You may need external sanitizer to protect output from XSS.\n\t *   It's better to extend features via plugins, instead of enabling HTML.\n\t * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags\n\t *   (`<br />`). This is needed only for full CommonMark compatibility. In real\n\t *   world you will need HTML output.\n\t * - __breaks__ - `false`. Set `true` to convert `\\n` in paragraphs into `<br>`.\n\t * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.\n\t *   Can be useful for external highlighters.\n\t * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.\n\t * - __typographer__  - `false`. Set `true` to enable [some language-neutral\n\t *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +\n\t *   quotes beautification (smartquotes).\n\t * - __quotes__ - ``, String or Array. Double + single quotes replacement\n\t *   pairs, when typographer enabled and smartquotes on. For example, you can\n\t *   use `''` for Russian, `''` for German, and\n\t *   `['\\xA0', '\\xA0', '\\xA0', '\\xA0']` for French (including nbsp).\n\t * - __highlight__ - `null`. Highlighter function for fenced code blocks.\n\t *   Highlighter `function (str, lang)` should return escaped HTML. It can also\n\t *   return empty string if the source was not changed and should be escaped\n\t *   externaly. If result starts with <pre... internal wrapper is skipped.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * // commonmark mode\n\t * var md = require('markdown-it')('commonmark');\n\t *\n\t * // default mode\n\t * var md = require('markdown-it')();\n\t *\n\t * // enable everything\n\t * var md = require('markdown-it')({\n\t *   html: true,\n\t *   linkify: true,\n\t *   typographer: true\n\t * });\n\t * ```\n\t *\n\t * ##### Syntax highlighting\n\t *\n\t * ```js\n\t * var hljs = require('highlight.js') // https://highlightjs.org/\n\t *\n\t * var md = require('markdown-it')({\n\t *   highlight: function (str, lang) {\n\t *     if (lang && hljs.getLanguage(lang)) {\n\t *       try {\n\t *         return hljs.highlight(str, { language: lang, ignoreIllegals: true }).value;\n\t *       } catch (__) {}\n\t *     }\n\t *\n\t *     return ''; // use external default escaping\n\t *   }\n\t * });\n\t * ```\n\t *\n\t * Or with full wrapper override (if you need assign class to `<pre>`):\n\t *\n\t * ```javascript\n\t * var hljs = require('highlight.js') // https://highlightjs.org/\n\t *\n\t * // Actual default values\n\t * var md = require('markdown-it')({\n\t *   highlight: function (str, lang) {\n\t *     if (lang && hljs.getLanguage(lang)) {\n\t *       try {\n\t *         return '<pre class=\"hljs\"><code>' +\n\t *                hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +\n\t *                '</code></pre>';\n\t *       } catch (__) {}\n\t *     }\n\t *\n\t *     return '<pre class=\"hljs\"><code>' + md.utils.escapeHtml(str) + '</code></pre>';\n\t *   }\n\t * });\n\t * ```\n\t *\n\t **/  function MarkdownIt(presetName, options) {\n    if (!(this instanceof MarkdownIt)) {\n      return new MarkdownIt(presetName, options);\n    }\n    if (!options) {\n      if (!utils.isString(presetName)) {\n        options = presetName || {};\n        presetName = \"default\";\n      }\n    }\n    /**\n\t   * MarkdownIt#inline -> ParserInline\n\t   *\n\t   * Instance of [[ParserInline]]. You may need it to add new rules when\n\t   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n\t   * [[MarkdownIt.enable]].\n\t   **/    this.inline = new parser_inline;\n    /**\n\t   * MarkdownIt#block -> ParserBlock\n\t   *\n\t   * Instance of [[ParserBlock]]. You may need it to add new rules when\n\t   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n\t   * [[MarkdownIt.enable]].\n\t   **/    this.block = new parser_block;\n    /**\n\t   * MarkdownIt#core -> Core\n\t   *\n\t   * Instance of [[Core]] chain executor. You may need it to add new rules when\n\t   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n\t   * [[MarkdownIt.enable]].\n\t   **/    this.core = new parser_core;\n    /**\n\t   * MarkdownIt#renderer -> Renderer\n\t   *\n\t   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering\n\t   * rules for new token types, generated by plugins.\n\t   *\n\t   * ##### Example\n\t   *\n\t   * ```javascript\n\t   * var md = require('markdown-it')();\n\t   *\n\t   * function myToken(tokens, idx, options, env, self) {\n\t   *   //...\n\t   *   return result;\n\t   * };\n\t   *\n\t   * md.renderer.rules['my_token'] = myToken\n\t   * ```\n\t   *\n\t   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).\n\t   **/    this.renderer = new renderer;\n    /**\n\t   * MarkdownIt#linkify -> LinkifyIt\n\t   *\n\t   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.\n\t   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)\n\t   * rule.\n\t   **/    this.linkify = new linkifyIt;\n    /**\n\t   * MarkdownIt#validateLink(url) -> Boolean\n\t   *\n\t   * Link validation function. CommonMark allows too much in links. By default\n\t   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas\n\t   * except some embedded image types.\n\t   *\n\t   * You can change this behaviour:\n\t   *\n\t   * ```javascript\n\t   * var md = require('markdown-it')();\n\t   * // enable everything\n\t   * md.validateLink = function () { return true; }\n\t   * ```\n\t   **/    this.validateLink = validateLink;\n    /**\n\t   * MarkdownIt#normalizeLink(url) -> String\n\t   *\n\t   * Function used to encode link url to a machine-readable format,\n\t   * which includes url-encoding, punycode, etc.\n\t   **/    this.normalizeLink = normalizeLink;\n    /**\n\t   * MarkdownIt#normalizeLinkText(url) -> String\n\t   *\n\t   * Function used to decode link url to a human-readable format`\n\t   **/    this.normalizeLinkText = normalizeLinkText;\n    // Expose utils & helpers for easy acces from plugins\n    /**\n\t   * MarkdownIt#utils -> utils\n\t   *\n\t   * Assorted utility functions, useful to write plugins. See details\n\t   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).\n\t   **/    this.utils = utils;\n    /**\n\t   * MarkdownIt#helpers -> helpers\n\t   *\n\t   * Link components parser functions, useful to write plugins. See details\n\t   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).\n\t   **/    this.helpers = utils.assign({}, helpers);\n    this.options = {};\n    this.configure(presetName);\n    if (options) {\n      this.set(options);\n    }\n  }\n  /** chainable\n\t * MarkdownIt.set(options)\n\t *\n\t * Set parser options (in the same format as in constructor). Probably, you\n\t * will never need it, but you can change options after constructor call.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')()\n\t *             .set({ html: true, breaks: true })\n\t *             .set({ typographer, true });\n\t * ```\n\t *\n\t * __Note:__ To achieve the best possible performance, don't modify a\n\t * `markdown-it` instance options on the fly. If you need multiple configurations\n\t * it's best to create multiple instances and initialize each with separate\n\t * config.\n\t **/  MarkdownIt.prototype.set = function(options) {\n    utils.assign(this.options, options);\n    return this;\n  };\n  /** chainable, internal\n\t * MarkdownIt.configure(presets)\n\t *\n\t * Batch load of all options and compenent settings. This is internal method,\n\t * and you probably will not need it. But if you will - see available presets\n\t * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)\n\t *\n\t * We strongly recommend to use presets instead of direct config loads. That\n\t * will give better compatibility with next versions.\n\t **/  MarkdownIt.prototype.configure = function(presets) {\n    var self = this, presetName;\n    if (utils.isString(presets)) {\n      presetName = presets;\n      presets = config[presetName];\n      if (!presets) {\n        throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name');\n      }\n    }\n    if (!presets) {\n      throw new Error(\"Wrong `markdown-it` preset, can't be empty\");\n    }\n    if (presets.options) {\n      self.set(presets.options);\n    }\n    if (presets.components) {\n      Object.keys(presets.components).forEach((function(name) {\n        if (presets.components[name].rules) {\n          self[name].ruler.enableOnly(presets.components[name].rules);\n        }\n        if (presets.components[name].rules2) {\n          self[name].ruler2.enableOnly(presets.components[name].rules2);\n        }\n      }));\n    }\n    return this;\n  };\n  /** chainable\n\t * MarkdownIt.enable(list, ignoreInvalid)\n\t * - list (String|Array): rule name or list of rule names to enable\n\t * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n\t *\n\t * Enable list or rules. It will automatically find appropriate components,\n\t * containing rules with given names. If rule not found, and `ignoreInvalid`\n\t * not set - throws exception.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var md = require('markdown-it')()\n\t *             .enable(['sub', 'sup'])\n\t *             .disable('smartquotes');\n\t * ```\n\t **/  MarkdownIt.prototype.enable = function(list, ignoreInvalid) {\n    var result = [];\n    if (!Array.isArray(list)) {\n      list = [ list ];\n    }\n    [ \"core\", \"block\", \"inline\" ].forEach((function(chain) {\n      result = result.concat(this[chain].ruler.enable(list, true));\n    }), this);\n    result = result.concat(this.inline.ruler2.enable(list, true));\n    var missed = list.filter((function(name) {\n      return result.indexOf(name) < 0;\n    }));\n    if (missed.length && !ignoreInvalid) {\n      throw new Error(\"MarkdownIt. Failed to enable unknown rule(s): \" + missed);\n    }\n    return this;\n  };\n  /** chainable\n\t * MarkdownIt.disable(list, ignoreInvalid)\n\t * - list (String|Array): rule name or list of rule names to disable.\n\t * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n\t *\n\t * The same as [[MarkdownIt.enable]], but turn specified rules off.\n\t **/  MarkdownIt.prototype.disable = function(list, ignoreInvalid) {\n    var result = [];\n    if (!Array.isArray(list)) {\n      list = [ list ];\n    }\n    [ \"core\", \"block\", \"inline\" ].forEach((function(chain) {\n      result = result.concat(this[chain].ruler.disable(list, true));\n    }), this);\n    result = result.concat(this.inline.ruler2.disable(list, true));\n    var missed = list.filter((function(name) {\n      return result.indexOf(name) < 0;\n    }));\n    if (missed.length && !ignoreInvalid) {\n      throw new Error(\"MarkdownIt. Failed to disable unknown rule(s): \" + missed);\n    }\n    return this;\n  };\n  /** chainable\n\t * MarkdownIt.use(plugin, params)\n\t *\n\t * Load specified plugin with given params into current parser instance.\n\t * It's just a sugar to call `plugin(md, params)` with curring.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * var iterator = require('markdown-it-for-inline');\n\t * var md = require('markdown-it')()\n\t *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {\n\t *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');\n\t *             });\n\t * ```\n\t **/  MarkdownIt.prototype.use = function(plugin /*, params, ... */) {\n    var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));\n    plugin.apply(plugin, args);\n    return this;\n  };\n  /** internal\n\t * MarkdownIt.parse(src, env) -> Array\n\t * - src (String): source string\n\t * - env (Object): environment sandbox\n\t *\n\t * Parse input string and return list of block tokens (special token type\n\t * \"inline\" will contain list of inline tokens). You should not call this\n\t * method directly, until you write custom renderer (for example, to produce\n\t * AST).\n\t *\n\t * `env` is used to pass data between \"distributed\" rules and return additional\n\t * metadata like reference info, needed for the renderer. It also can be used to\n\t * inject data in specific cases. Usually, you will be ok to pass `{}`,\n\t * and then pass updated object to renderer.\n\t **/  MarkdownIt.prototype.parse = function(src, env) {\n    if (typeof src !== \"string\") {\n      throw new Error(\"Input data should be a String\");\n    }\n    var state = new this.core.State(src, this, env);\n    this.core.process(state);\n    return state.tokens;\n  };\n  /**\n\t * MarkdownIt.render(src [, env]) -> String\n\t * - src (String): source string\n\t * - env (Object): environment sandbox\n\t *\n\t * Render markdown string into html. It does all magic for you :).\n\t *\n\t * `env` can be used to inject additional metadata (`{}` by default).\n\t * But you will not need it with high probability. See also comment\n\t * in [[MarkdownIt.parse]].\n\t **/  MarkdownIt.prototype.render = function(src, env) {\n    env = env || {};\n    return this.renderer.render(this.parse(src, env), this.options, env);\n  };\n  /** internal\n\t * MarkdownIt.parseInline(src, env) -> Array\n\t * - src (String): source string\n\t * - env (Object): environment sandbox\n\t *\n\t * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the\n\t * block tokens list with the single `inline` element, containing parsed inline\n\t * tokens in `children` property. Also updates `env` object.\n\t **/  MarkdownIt.prototype.parseInline = function(src, env) {\n    var state = new this.core.State(src, this, env);\n    state.inlineMode = true;\n    this.core.process(state);\n    return state.tokens;\n  };\n  /**\n\t * MarkdownIt.renderInline(src [, env]) -> String\n\t * - src (String): source string\n\t * - env (Object): environment sandbox\n\t *\n\t * Similar to [[MarkdownIt.render]] but for single paragraph content. Result\n\t * will NOT be wrapped into `<p>` tags.\n\t **/  MarkdownIt.prototype.renderInline = function(src, env) {\n    env = env || {};\n    return this.renderer.render(this.parseInline(src, env), this.options, env);\n  };\n  var lib = MarkdownIt;\n  var markdownIt = lib;\n  return markdownIt;\n}));\n","define(\"pretty-text/engines/discourse-markdown/anchor\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  function setup(helper) {\n    if (helper.getOptions().previewing) {\n      return;\n    }\n\n    helper.registerPlugin(md => {\n      md.core.ruler.push(\"anchor\", state => {\n        for (let idx = 0, lvl = 0, headingId = 0; idx < state.tokens.length; idx++) {\n          if (state.tokens[idx].type === \"blockquote_open\" || state.tokens[idx].type === \"bbcode_open\" && state.tokens[idx].tag === \"aside\") {\n            ++lvl;\n          } else if (state.tokens[idx].type === \"blockquote_close\" || state.tokens[idx].type === \"bbcode_close\" && state.tokens[idx].tag === \"aside\") {\n            --lvl;\n          }\n\n          if (lvl > 0 || state.tokens[idx].type !== \"heading_open\") {\n            continue;\n          }\n\n          const linkOpen = new state.Token(\"link_open\", \"a\", 1);\n          const linkClose = new state.Token(\"link_close\", \"a\", -1);\n          let slug = state.tokens[idx + 1].content.toLowerCase().replace(/\\s+/g, \"-\").replace(/[^\\w\\-]+/g, \"\").replace(/\\-\\-+/g, \"-\").replace(/^-+/, \"\").replace(/-+$/, \"\");\n\n          if (slug.match(/^[^a-z]/)) {\n            slug = `h-${slug}`;\n          }\n\n          slug = `${slug || \"h\"}-${++headingId}`;\n          linkOpen.attrSet(\"name\", slug);\n          linkOpen.attrSet(\"class\", \"anchor\");\n          linkOpen.attrSet(\"href\", \"#\" + slug);\n          state.tokens[idx + 1].children.unshift(linkClose);\n          state.tokens[idx + 1].children.unshift(linkOpen);\n        }\n      });\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/bbcode-block\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.parseBBCodeTag = parseBBCodeTag;\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  let isWhiteSpace;\n\n  function trailingSpaceOnly(src, start, max) {\n    let i;\n\n    for (i = start; i < max; i++) {\n      let code = src.charCodeAt(i);\n\n      if (code === 0x0a) {\n        return true;\n      }\n\n      if (!isWhiteSpace(code)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  const ATTR_REGEX = /^\\s*=(.+)$|((([a-z0-9]*)\\s*)=)([\"][^\"]*[\"]|['][^']*[']|[^\"']\\S*)/gi; // parse a tag [test a=1 b=2] to a data structure\n  // {tag: \"test\", attrs={a: \"1\", b: \"2\"}\n\n  function parseBBCodeTag(src, start, max, multiline) {\n    let i;\n    let tag;\n    let attrs = {};\n    let closed = false;\n    let length = 0;\n    let closingTag = false; // closing tag\n\n    if (src.charCodeAt(start + 1) === 47) {\n      closingTag = true;\n      start += 1;\n    }\n\n    for (i = start + 1; i < max; i++) {\n      let letter = src[i];\n\n      if (!(letter >= \"a\" && letter <= \"z\" || letter >= \"A\" && letter <= \"Z\")) {\n        break;\n      }\n    }\n\n    tag = src.slice(start + 1, i);\n\n    if (!tag) {\n      return;\n    }\n\n    if (closingTag) {\n      if (src[i] === \"]\") {\n        if (multiline && !trailingSpaceOnly(src, i + 1, max)) {\n          return;\n        }\n\n        tag = tag.toLowerCase();\n        return {\n          tag,\n          length: tag.length + 3,\n          closing: true\n        };\n      }\n\n      return;\n    }\n\n    for (; i < max; i++) {\n      let letter = src[i];\n\n      if (letter === \"]\") {\n        closed = true;\n        break;\n      }\n    }\n\n    if (closed) {\n      length = i - start + 1;\n      let raw = src.slice(start + tag.length + 1, i); // trivial parser that is going to have to be rewritten at some point\n\n      if (raw) {\n        let match, key, val;\n\n        while (match = ATTR_REGEX.exec(raw)) {\n          if (match[1]) {\n            key = \"_default\";\n          } else {\n            key = match[4];\n          }\n\n          val = match[1] || match[5];\n\n          if (val) {\n            val = val.trim();\n            val = val.replace(/^[\"'](.*)[\"']$/, \"$1\");\n            attrs[key] = val;\n          }\n        }\n      }\n\n      if (multiline && !trailingSpaceOnly(src, start + length, max)) {\n        return;\n      }\n\n      tag = tag.toLowerCase();\n      return {\n        tag,\n        attrs,\n        length\n      };\n    }\n  }\n\n  function findBlockCloseTag(state, openTag, startLine, endLine) {\n    let nesting = 0,\n        line = startLine - 1,\n        start,\n        closeTag,\n        max;\n\n    for (;;) {\n      line++;\n\n      if (line >= endLine) {\n        // unclosed bbcode block should not be autoclosed by end of document.\n        return;\n      }\n\n      start = state.bMarks[line] + state.tShift[line];\n      max = state.eMarks[line];\n\n      if (start < max && state.sCount[line] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      } // bbcode close [ === 91\n\n\n      if (91 !== state.src.charCodeAt(start)) {\n        continue;\n      }\n\n      if (state.sCount[line] - state.blkIndent >= 4) {\n        // closing bbcode less than 4 spaces\n        continue;\n      }\n\n      closeTag = parseBBCodeTag(state.src, start, max, true);\n\n      if (closeTag && closeTag.closing && closeTag.tag === openTag.tag) {\n        if (nesting === 0) {\n          closeTag.line = line;\n          closeTag.block = true;\n          break;\n        }\n\n        nesting--;\n      }\n\n      if (closeTag && !closeTag.closing && closeTag.tag === openTag.tag) {\n        nesting++;\n      }\n\n      closeTag = null;\n    }\n\n    return closeTag;\n  }\n\n  function findInlineCloseTag(state, openTag, start, max) {\n    let closeTag;\n    let possibleTag = false;\n\n    for (let j = max - 1; j > start; j--) {\n      if (!possibleTag) {\n        if (state.src.charCodeAt(j) === 93\n        /* ] */\n        ) {\n          possibleTag = true;\n          continue;\n        }\n\n        if (!isWhiteSpace(state.src.charCodeAt(j))) {\n          break;\n        }\n      } else {\n        if (state.src.charCodeAt(j) === 91\n        /* [ */\n        ) {\n          closeTag = parseBBCodeTag(state.src, j, max);\n\n          if (!closeTag || closeTag.tag !== openTag.tag || !closeTag.closing) {\n            closeTag = null;\n          } else {\n            closeTag.start = j;\n            break;\n          }\n        }\n      }\n    }\n\n    return closeTag;\n  }\n\n  function applyBBCode(state, startLine, endLine, silent, md) {\n    let nextLine,\n        oldParent,\n        oldLineMax,\n        rule,\n        start = state.bMarks[startLine] + state.tShift[startLine],\n        initial = start,\n        max = state.eMarks[startLine]; // [ === 91\n\n    if (91 !== state.src.charCodeAt(start)) {\n      return false;\n    }\n\n    let info = parseBBCodeTag(state.src, start, max);\n\n    if (!info || info.closing) {\n      return false;\n    }\n\n    let ruleInfo = md.block.bbcode.ruler.getRuleForTag(info.tag);\n\n    if (!ruleInfo) {\n      return false;\n    }\n\n    rule = ruleInfo.rule; // Since start is found, we can report success here in validation mode\n\n    if (silent) {\n      return true;\n    } // Search for the end of the block\n\n\n    nextLine = startLine; // We might have a single inline bbcode\n\n    let closeTag = findInlineCloseTag(state, info, start + info.length, max);\n\n    if (!closeTag) {\n      if (!trailingSpaceOnly(state.src, start + info.length, max)) {\n        return false;\n      }\n\n      closeTag = findBlockCloseTag(state, info, nextLine + 1, endLine);\n    }\n\n    if (!closeTag) {\n      return false;\n    }\n\n    nextLine = closeTag.line || startLine;\n    oldParent = state.parentType;\n    oldLineMax = state.lineMax; // this will prevent lazy continuations from ever going past our end marker\n    // which can happen if we are parsing a bbcode block\n\n    state.lineMax = nextLine;\n\n    if (rule.replace) {\n      let content;\n\n      if (startLine === nextLine) {\n        content = state.src.slice(start + info.length, closeTag.start);\n      } else {\n        content = state.src.slice(state.bMarks[startLine + 1], state.eMarks[nextLine - 1]);\n      }\n\n      if (!rule.replace.call(this, state, info, content)) {\n        return false;\n      }\n    } else {\n      if (rule.before) {\n        rule.before.call(this, state, info, state.src.slice(initial, initial + info.length + 1));\n      }\n\n      let wrapTag;\n\n      if (rule.wrap) {\n        let token;\n\n        if (typeof rule.wrap === \"function\") {\n          token = new state.Token(\"wrap_bbcode\", \"div\", 1);\n          token.level = state.level + 1;\n\n          if (!rule.wrap(token, info)) {\n            return false;\n          }\n\n          state.tokens.push(token);\n          state.level = token.level;\n          wrapTag = token.tag;\n        } else {\n          let split = rule.wrap.split(\".\");\n          wrapTag = split[0];\n          let className = split.slice(1).join(\" \");\n          token = state.push(\"wrap_bbcode\", wrapTag, 1);\n\n          if (className) {\n            token.attrs = [[\"class\", className]];\n          }\n        }\n      }\n\n      let lastToken = state.tokens[state.tokens.length - 1];\n      lastToken.map = [startLine, nextLine];\n\n      if (closeTag.block) {\n        state.md.block.tokenize(state, startLine + 1, nextLine);\n      } else {\n        let token = state.push(\"paragraph_open\", \"p\", 1);\n        token.map = [startLine, startLine];\n        token = state.push(\"inline\", \"\", 0);\n        token.children = [];\n        token.map = [startLine, startLine];\n        token.content = state.src.slice(start + info.length, closeTag.start);\n        state.push(\"paragraph_close\", \"p\", -1);\n      }\n\n      if (rule.wrap) {\n        state.push(\"wrap_bbcode\", wrapTag, -1);\n      }\n\n      if (rule.after) {\n        rule.after.call(this, state, lastToken, state.src.slice(start - 2, start + closeTag.length - 1));\n      }\n    }\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.line = nextLine + 1;\n    return true;\n  }\n\n  function setup(helper) {\n    helper.registerPlugin(md => {\n      const ruler = md.block.bbcode.ruler;\n      ruler.push(\"excerpt\", {\n        tag: \"excerpt\",\n        wrap: \"div.excerpt\"\n      });\n      ruler.push(\"code\", {\n        tag: \"code\",\n\n        replace(state, tagInfo, content) {\n          let token;\n          token = state.push(\"fence\", \"code\", 0);\n          token.content = content;\n          return true;\n        }\n\n      });\n      isWhiteSpace = md.utils.isWhiteSpace;\n      md.block.ruler.after(\"fence\", \"bbcode\", (state, startLine, endLine, silent) => {\n        return applyBBCode(state, startLine, endLine, silent, md);\n      }, {\n        alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"]\n      });\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/bbcode-inline\", [\"exports\", \"pretty-text/engines/discourse-markdown/bbcode-block\"], function (_exports, _bbcodeBlock) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71f0,\"pretty-text/engines/discourse-markdown/bbcode-block\"eaimeta@70e063a35619d71f\n\n  function tokenizeBBCode(state, silent, ruler) {\n    let pos = state.pos; // 91 = [\n\n    if (silent || state.src.charCodeAt(pos) !== 91) {\n      return false;\n    }\n\n    const tagInfo = (0, _bbcodeBlock.parseBBCodeTag)(state.src, pos, state.posMax);\n\n    if (!tagInfo) {\n      return false;\n    }\n\n    let rule, i;\n    let ruleInfo = ruler.getRuleForTag(tagInfo.tag);\n\n    if (!ruleInfo) {\n      return false;\n    }\n\n    rule = ruleInfo.rule;\n\n    if (rule.replace) {\n      // special handling for replace\n      // we pass raw contents to callback so we simply need to greedy match to end tag\n      if (tagInfo.closing) {\n        return false;\n      }\n\n      let closeTag = \"[/\" + tagInfo.tag + \"]\";\n      let found = false;\n\n      for (i = state.pos + tagInfo.length; i <= state.posMax - closeTag.length; i++) {\n        if (state.src.charCodeAt(pos) === 91 && state.src.slice(i, i + closeTag.length).toLowerCase() === closeTag) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        return false;\n      }\n\n      let content = state.src.slice(state.pos + tagInfo.length, i);\n\n      if (rule.replace(state, tagInfo, content)) {\n        state.pos = i + closeTag.length;\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      tagInfo.rule = rule;\n      let token = state.push(\"text\", \"\", 0);\n      token.content = state.src.slice(pos, pos + tagInfo.length);\n      token.meta = \"bbcode\";\n      state.delimiters.push({\n        bbInfo: tagInfo,\n        marker: \"bb\" + tagInfo.tag,\n        open: !tagInfo.closing,\n        close: !!tagInfo.closing,\n        token: state.tokens.length - 1,\n        level: state.level,\n        end: -1,\n        jump: 0\n      });\n      state.pos = pos + tagInfo.length;\n      return true;\n    }\n  }\n\n  function processBBCode(state, silent) {\n    let i,\n        startDelim,\n        endDelim,\n        tagInfo,\n        delimiters = state.delimiters,\n        max = delimiters.length;\n\n    if (silent) {\n      return;\n    }\n\n    for (i = 0; i < max - 1; i++) {\n      startDelim = delimiters[i];\n      tagInfo = startDelim.bbInfo;\n\n      if (!tagInfo) {\n        continue;\n      }\n\n      if (startDelim.end === -1) {\n        continue;\n      }\n\n      endDelim = delimiters[startDelim.end];\n      let tag, className;\n      const startToken = state.tokens[startDelim.token];\n      const endToken = state.tokens[endDelim.token];\n\n      if (typeof tagInfo.rule.wrap === \"function\") {\n        let content = \"\";\n\n        for (let j = startDelim.token + 1; j < endDelim.token; j++) {\n          let inner = state.tokens[j];\n\n          if (inner.type === \"text\" && inner.meta !== \"bbcode\") {\n            content += inner.content;\n          }\n        }\n\n        tagInfo.rule.wrap(startToken, endToken, tagInfo, content, state);\n        continue;\n      } else {\n        let split = tagInfo.rule.wrap.split(\".\");\n        tag = split[0];\n        className = split.slice(1).join(\" \");\n      }\n\n      startToken.type = \"bbcode_\" + tagInfo.tag + \"_open\";\n      startToken.tag = tag;\n\n      if (className) {\n        startToken.attrs = [[\"class\", className]];\n      }\n\n      startToken.nesting = 1;\n      startToken.markup = startToken.content;\n      startToken.content = \"\";\n      endToken.type = \"bbcode_\" + tagInfo.tag + \"_close\";\n      endToken.tag = tag;\n      endToken.nesting = -1;\n      endToken.markup = startToken.content;\n      endToken.content = \"\";\n    }\n\n    return false;\n  }\n\n  function setup(helper) {\n    helper.allowList([\"span.bbcode-b\", \"span.bbcode-i\", \"span.bbcode-u\", \"span.bbcode-s\"]);\n    helper.registerOptions(opts => {\n      opts.features[\"bbcode-inline\"] = true;\n    });\n    helper.registerPlugin(md => {\n      const ruler = md.inline.bbcode.ruler;\n      md.inline.ruler.push(\"bbcode-inline\", (state, silent) => tokenizeBBCode(state, silent, ruler));\n      md.inline.ruler2.before(\"fragments_join\", \"bbcode-inline\", processBBCode);\n      ruler.push(\"code\", {\n        tag: \"code\",\n\n        replace(state, tagInfo, content) {\n          let token;\n          token = state.push(\"code_inline\", \"code\", 0);\n          token.content = content;\n          return true;\n        }\n\n      });\n      const simpleUrlRegex = /^https?:\\/\\//;\n      ruler.push(\"url\", {\n        tag: \"url\",\n\n        wrap(startToken, endToken, tagInfo, content, state) {\n          const url = (tagInfo.attrs[\"_default\"] || content).trim();\n          let linkifyFound = false;\n\n          if (state.md.options.linkify) {\n            const tokens = state.tokens;\n            const startIndex = tokens.indexOf(startToken);\n            const endIndex = tokens.indexOf(endToken); // reuse existing tokens from linkify if they exist\n\n            for (let index = startIndex + 1; index < endIndex; index++) {\n              const token = tokens[index];\n\n              if (token.markup === \"linkify\" && token.info === \"auto\" && token.type === \"link_open\") {\n                linkifyFound = true;\n                token.attrs.push([\"data-bbcode\", \"true\"]);\n                break;\n              }\n            }\n          }\n\n          if (!linkifyFound && simpleUrlRegex.test(url)) {\n            startToken.type = \"link_open\";\n            startToken.tag = \"a\";\n            startToken.attrs = [[\"href\", url], [\"data-bbcode\", \"true\"]];\n            startToken.content = \"\";\n            startToken.nesting = 1;\n            endToken.type = \"link_close\";\n            endToken.tag = \"a\";\n            endToken.content = \"\";\n            endToken.nesting = -1;\n          } else {\n            // just strip the bbcode tag\n            endToken.content = \"\";\n            startToken.content = \"\"; // edge case, we don't want this detected as a onebox if auto linked\n            // this ensures it is not stripped\n\n            startToken.type = \"html_inline\";\n          }\n\n          return false;\n        }\n\n      });\n      ruler.push(\"email\", {\n        tag: \"email\",\n\n        replace(state, tagInfo, content) {\n          let token;\n          const email = tagInfo.attrs[\"_default\"] || content;\n          token = state.push(\"link_open\", \"a\", 1);\n          token.attrs = [[\"href\", \"mailto:\" + email], [\"data-bbcode\", \"true\"]];\n          token = state.push(\"text\", \"\", 0);\n          token.content = content;\n          state.push(\"link_close\", \"a\", -1);\n          return true;\n        }\n\n      });\n      ruler.push(\"image\", {\n        tag: \"img\",\n\n        replace(state, tagInfo, content) {\n          let token = state.push(\"image\", \"img\", 0);\n          token.attrs = [[\"src\", content], [\"alt\", \"\"]];\n          token.children = [];\n          return true;\n        }\n\n      });\n      ruler.push(\"bold\", {\n        tag: \"b\",\n        wrap: \"span.bbcode-b\"\n      });\n      ruler.push(\"italic\", {\n        tag: \"i\",\n        wrap: \"span.bbcode-i\"\n      });\n      ruler.push(\"underline\", {\n        tag: \"u\",\n        wrap: \"span.bbcode-u\"\n      });\n      ruler.push(\"strike\", {\n        tag: \"s\",\n        wrap: \"span.bbcode-s\"\n      });\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/category-hashtag\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  function addHashtag(buffer, matches, state) {\n    const options = state.md.options.discourse;\n    const slug = matches[1];\n    const categoryHashtagLookup = options.categoryHashtagLookup;\n    const result = categoryHashtagLookup && categoryHashtagLookup(slug);\n    let token;\n\n    if (result) {\n      token = new state.Token(\"link_open\", \"a\", 1);\n      token.attrs = [[\"class\", \"hashtag\"], [\"href\", result[0]]];\n      token.block = false;\n      buffer.push(token);\n      token = new state.Token(\"text\", \"\", 0);\n      token.content = \"#\";\n      buffer.push(token);\n      token = new state.Token(\"span_open\", \"span\", 1);\n      token.block = false;\n      buffer.push(token);\n      token = new state.Token(\"text\", \"\", 0);\n      token.content = result[1];\n      buffer.push(token);\n      buffer.push(new state.Token(\"span_close\", \"span\", -1));\n      buffer.push(new state.Token(\"link_close\", \"a\", -1));\n    } else {\n      token = new state.Token(\"span_open\", \"span\", 1);\n      token.attrs = [[\"class\", \"hashtag\"]];\n      buffer.push(token);\n      token = new state.Token(\"text\", \"\", 0);\n      token.content = matches[0];\n      buffer.push(token);\n      token = new state.Token(\"span_close\", \"span\", -1);\n      buffer.push(token);\n    }\n  }\n\n  function setup(helper) {\n    helper.registerPlugin(md => {\n      const rule = {\n        matcher: /#([\\u00C0-\\u1FFF\\u2C00-\\uD7FF\\w:-]{1,101})/,\n        onMatch: addHashtag\n      };\n      md.core.textPostProcess.ruler.push(\"category-hashtag\", rule);\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/censored\", [\"exports\", \"pretty-text/censored-words\"], function (_exports, _censoredWords) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71f0,\"pretty-text/censored-words\"eaimeta@70e063a35619d71f\n\n  function recurse(tokens, apply) {\n    let i;\n\n    for (i = 0; i < tokens.length; i++) {\n      if (tokens[i].type === \"html_raw\" && tokens[i].onebox) {\n        continue;\n      }\n\n      apply(tokens[i]);\n\n      if (tokens[i].children) {\n        recurse(tokens[i].children, apply);\n      }\n    }\n  }\n\n  function censorTree(state, censor) {\n    if (!state.tokens) {\n      return;\n    }\n\n    recurse(state.tokens, token => {\n      if (token.content) {\n        token.content = censor(token.content);\n      }\n    });\n  }\n\n  function setup(helper) {\n    helper.registerPlugin(md => {\n      const censoredRegexps = md.options.discourse.censoredRegexp;\n\n      if (Array.isArray(censoredRegexps) && censoredRegexps.length > 0) {\n        const replacement = String.fromCharCode(9632);\n        const censor = (0, _censoredWords.censorFn)(censoredRegexps, replacement);\n        md.core.ruler.push(\"censored\", state => censorTree(state, censor));\n      }\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/code\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  // we need a custom renderer for code blocks cause we have a slightly non compliant\n  // format with special handling for text and so on\n  const TEXT_CODE_CLASSES = [\"text\", \"pre\", \"plain\"];\n\n  function extractTokenInfo(info, md) {\n    if (!info) {\n      return;\n    }\n\n    info = info.trim();\n    const matches = info.match(/(^\\s*\\S*)\\s*(.*)/i);\n\n    if (!matches) {\n      return;\n    } // ensure the token has only valid chars\n    // c++, strucuted-text and p91, are all valid\n\n\n    if (!/^[\\w+-]*$/i.test(matches[1])) {\n      return;\n    }\n\n    const ASCII_REGEX = /[^\\x00-\\x7F]/;\n    const tag = md.utils.unescapeAll(matches[1].replace(ASCII_REGEX, \"\"));\n    const extractedData = {\n      tag,\n      attributes: {}\n    };\n\n    if (matches[2]?.length) {\n      md.utils.unescapeAll(matches[2].replace(ASCII_REGEX, \"\")).split(\",\").forEach(potentialPair => {\n        const [key, value] = potentialPair.trim().split(/\\s+/g)[0].split(\"=\"); // invalid pairs would get caught here and not used, eg `foo=`\n\n        if (key && value) {\n          extractedData.attributes[key] = value;\n        }\n      });\n    }\n\n    return extractedData;\n  }\n\n  function render(tokens, idx, options, env, slf, md) {\n    const token = tokens[idx];\n    const escapedContent = md.utils.escapeHtml(token.content);\n    const tokenInfo = extractTokenInfo(token.info, md);\n    const tag = tokenInfo?.tag || md.options.discourse.defaultCodeLang;\n    const attributes = tokenInfo?.attributes || {};\n    let className;\n    const acceptableCodeClasses = md.options.discourse.acceptableCodeClasses || [];\n\n    if (TEXT_CODE_CLASSES.includes(tag)) {\n      className = \"lang-nohighlight\";\n    } else if (acceptableCodeClasses.includes(tag)) {\n      className = `lang-${tag}`;\n    } else {\n      className = \"lang-nohighlight\";\n      attributes[\"wrap\"] = tag;\n    }\n\n    const dataAttributes = Object.keys(attributes).map(key => {\n      const value = md.utils.escapeHtml(attributes[key]);\n      key = md.utils.escapeHtml(key);\n      return `data-code-${key}=\"${value}\"`;\n    }).join(\" \");\n    return `<pre${dataAttributes ? ` ${dataAttributes}` : \"\"}><code${className ? ` class=\"${className}\"` : \"\"}>${escapedContent}</code></pre>\\n`;\n  }\n\n  function setup(helper) {\n    helper.registerOptions((opts, siteSettings) => {\n      opts.defaultCodeLang = siteSettings.default_code_lang;\n      opts.acceptableCodeClasses = (siteSettings.highlighted_languages || \"\").split(\"|\").filter(Boolean).concat([\"auto\", \"nohighlight\"]);\n    });\n    helper.allowList([\"pre[data-code-*]\"]);\n    helper.allowList({\n      custom(tag, name, value) {\n        if (tag === \"code\" && name === \"class\") {\n          const m = /^lang\\-(.+)$/.exec(value);\n\n          if (m) {\n            return helper.getOptions().acceptableCodeClasses.includes(m[1]);\n          }\n        }\n      }\n\n    });\n    helper.registerPlugin(md => {\n      md.renderer.rules.fence = (tokens, idx, options, env, slf) => render(tokens, idx, options, env, slf, md);\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/custom-typographer-replacements\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  // Simple typographic replacements\n  //\n  // (tm) (TM)  \n  // +-  \n  // ...   (also ?....  ?.., !....  !..)\n  // ????????  ???, !!!!!  !!!, `,,`  `,`\n  // --  &ndash;, ---  &mdash;\n  // --> <-- -> <- to    \n  // (pa) (PA)  \n  //\n  // Disabled replacements:\n  //\n  // (c) (C)  \n  // (r) (R)  \n  // (p) (P) -> \n  let RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--|-->|<--|->|<-/;\n  let SCOPED_ABBR_RE = /\\((tm|pa)\\)/gi;\n  let SCOPED_ABBR = {\n    pa: \"\",\n    tm: \"\"\n  };\n\n  function replaceFn(match, name) {\n    return SCOPED_ABBR[name.toLowerCase()];\n  }\n\n  function replaceScoped(inlineTokens) {\n    let i, token;\n\n    for (i = inlineTokens.length - 1; i >= 0; i--) {\n      token = inlineTokens[i];\n\n      if (token.type === \"text\") {\n        token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);\n      }\n    }\n  }\n\n  function replaceRare(inlineTokens) {\n    let i,\n        token,\n        inside_autolink = 0;\n\n    for (i = inlineTokens.length - 1; i >= 0; i--) {\n      token = inlineTokens[i];\n\n      if (token.type === \"text\" && !inside_autolink) {\n        if (RARE_RE.test(token.content)) {\n          token.content = token.content.replace(/\\+-/g, \"\") // Custom arrows\n          .replace(/(^|\\s)-{1,2}>(\\s|$)/gm, \"\\u0020\\u2192\\u0020\").replace(/(^|\\s)<-{1,2}(\\s|$)/gm, \"\\u0020\\u2190\\u0020\") // .., ..., ....... -> \n          // but ?..... & !..... -> ?.. & !..\n          .replace(/\\.{2,}/g, \"\").replace(/([?!])/g, \"$1..\").replace(/([?!]){4,}/g, \"$1$1$1\").replace(/,{2,}/g, \",\") // em-dash\n          .replace(/(^|[^-])---(?=[^-]|$)/gm, \"$1\\u2014\") // en-dash\n          .replace(/(^|\\s)--(?=\\s|$)/gm, \"$1\\u2013\").replace(/(^|[^-\\s])--(?=[^-\\s]|$)/gm, \"$1\\u2013\");\n        }\n      }\n\n      if (token.type === \"link_open\" && token.info === \"auto\") {\n        inside_autolink--;\n      }\n\n      if (token.type === \"link_close\" && token.info === \"auto\") {\n        inside_autolink++;\n      }\n    }\n  }\n\n  function replace(state) {\n    let blkIdx;\n\n    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n      if (state.tokens[blkIdx].type !== \"inline\") {\n        continue;\n      }\n\n      if (SCOPED_ABBR_RE.test(state.tokens[blkIdx].content)) {\n        replaceScoped(state.tokens[blkIdx].children);\n      }\n\n      if (RARE_RE.test(state.tokens[blkIdx].content)) {\n        replaceRare(state.tokens[blkIdx].children);\n      }\n    }\n  }\n\n  function setup(helper) {\n    helper.registerPlugin(md => {\n      if (md.options.typographer) {\n        md.core.ruler.at(\"replacements\", replace);\n      }\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/d-wrap\", [\"exports\", \"pretty-text/engines/discourse-markdown/bbcode-block\"], function (_exports, _bbcodeBlock) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71f0,\"pretty-text/engines/discourse-markdown/bbcode-block\"eaimeta@70e063a35619d71f\n\n  const WRAP_CLASS = \"d-wrap\";\n\n  function parseAttributes(tagInfo) {\n    const attributes = tagInfo.attrs._default || \"\";\n    return (0, _bbcodeBlock.parseBBCodeTag)(`[wrap wrap=${attributes}]`, 0, attributes.length + 12).attrs || {};\n  }\n\n  function camelCaseToDash(str) {\n    return str.replace(/([a-zA-Z])(?=[A-Z])/g, \"$1-\").toLowerCase();\n  }\n\n  function applyDataAttributes(token, state, attributes) {\n    Object.keys(attributes).forEach(tag => {\n      const value = state.md.utils.escapeHtml(attributes[tag]);\n      tag = camelCaseToDash(state.md.utils.escapeHtml(tag.replace(/[^A-Za-z\\-0-9]/g, \"\")));\n\n      if (value && tag && tag.length > 1) {\n        token.attrs.push([`data-${tag}`, value]);\n      }\n    });\n  }\n\n  const blockRule = {\n    tag: \"wrap\",\n\n    before(state, tagInfo) {\n      let token = state.push(\"wrap_open\", \"div\", 1);\n      token.attrs = [[\"class\", WRAP_CLASS]];\n      applyDataAttributes(token, state, parseAttributes(tagInfo));\n    },\n\n    after(state) {\n      state.push(\"wrap_close\", \"div\", -1);\n    }\n\n  };\n  const inlineRule = {\n    tag: \"wrap\",\n\n    replace(state, tagInfo, content) {\n      let token = state.push(\"wrap_open\", \"span\", 1);\n      token.attrs = [[\"class\", WRAP_CLASS]];\n      applyDataAttributes(token, state, parseAttributes(tagInfo));\n\n      if (content) {\n        token = state.push(\"text\", \"\", 0);\n        token.content = content;\n      }\n\n      state.push(\"wrap_close\", \"span\", -1);\n      return true;\n    }\n\n  };\n\n  function setup(helper) {\n    helper.registerPlugin(md => {\n      md.inline.bbcode.ruler.push(\"inline-wrap\", inlineRule);\n      md.block.bbcode.ruler.push(\"block-wrap\", blockRule);\n    });\n    helper.allowList([`div.${WRAP_CLASS}`, `span.${WRAP_CLASS}`, \"span[data-*]\"]);\n  }\n});","define(\"pretty-text/engines/discourse-markdown/emoji\", [\"exports\", \"pretty-text/emoji\", \"pretty-text/emoji/data\"], function (_exports, _emoji, _data) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.resetTranslationTree = resetTranslationTree;\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71f0,\"pretty-text/emoji\",0,\"pretty-text/emoji/data\"eaimeta@70e063a35619d71f\n\n  const MAX_NAME_LENGTH = 60;\n  let translationTree = null;\n\n  function resetTranslationTree() {\n    translationTree = null;\n  } // This allows us to efficiently search for aliases\n  // We build a data structure that allows us to quickly\n  // search through our N next chars to see if any match\n  // one of our alias emojis.\n\n\n  function buildTranslationTree(customEmojiTranslation) {\n    let tree = [];\n    let lastNode;\n    const allTranslations = Object.assign({}, _data.translations, customEmojiTranslation || {});\n    Object.keys(allTranslations).forEach(key => {\n      let node = tree;\n\n      for (let i = 0; i < key.length; i++) {\n        let code = key.charCodeAt(i);\n        let found = false;\n\n        for (let j = 0; j < node.length; j++) {\n          if (node[j][0] === code) {\n            node = node[j][1];\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          // code, children, value\n          let tmp = [code, []];\n          node.push(tmp);\n          lastNode = tmp;\n          node = tmp[1];\n        }\n      }\n\n      lastNode[2] = allTranslations[key];\n    });\n    return tree;\n  }\n\n  function imageFor(code, opts) {\n    code = code.toLowerCase();\n    const url = (0, _emoji.buildEmojiUrl)(code, opts);\n\n    if (url) {\n      const title = `:${code}:`;\n      const classes = (0, _emoji.isCustomEmoji)(code, opts) ? \"emoji emoji-custom\" : \"emoji\";\n      return {\n        url,\n        title,\n        classes\n      };\n    }\n  }\n\n  function getEmojiName(content, pos, state, inlineEmoji) {\n    if (content.charCodeAt(pos) !== 58) {\n      return;\n    }\n\n    if (pos > 0) {\n      let prev = content.charCodeAt(pos - 1);\n\n      if (!inlineEmoji && !state.md.utils.isSpace(prev) && !state.md.utils.isPunctChar(String.fromCharCode(prev))) {\n        return;\n      }\n    }\n\n    pos++;\n\n    if (content.charCodeAt(pos) === 58) {\n      return;\n    }\n\n    let length = 0;\n\n    while (length < MAX_NAME_LENGTH) {\n      length++;\n\n      if (content.charCodeAt(pos + length) === 58) {\n        // check for t2-t6\n        if (content.slice(pos + length + 1, pos + length + 4).match(/t[2-6]:/)) {\n          length += 3;\n        }\n\n        break;\n      }\n\n      if (pos + length > content.length) {\n        return;\n      }\n    }\n\n    if (length === MAX_NAME_LENGTH) {\n      return;\n    }\n\n    return content.slice(pos, pos + length);\n  } // straight forward :smile: to emoji image\n\n\n  function getEmojiTokenByName(name, state) {\n    let info;\n\n    if (info = imageFor(name, state.md.options.discourse)) {\n      let token = new state.Token(\"emoji\", \"img\", 0);\n      token.attrs = [[\"src\", info.url], [\"title\", info.title], [\"class\", info.classes], [\"alt\", info.title], [\"loading\", \"lazy\"], [\"width\", \"20\"], [\"height\", \"20\"]];\n      return token;\n    }\n  }\n\n  function getEmojiTokenByTranslation(content, pos, state, customEmojiTranslation) {\n    translationTree = translationTree || buildTranslationTree(customEmojiTranslation);\n    let t = translationTree;\n    let start = pos;\n    let found = null;\n\n    while (t.length > 0 && pos < content.length) {\n      let matched = false;\n      let code = content.charCodeAt(pos);\n\n      for (let i = 0; i < t.length; i++) {\n        if (t[i][0] === code) {\n          matched = true;\n          found = t[i][2];\n          t = t[i][1];\n          break;\n        }\n      }\n\n      if (!matched) {\n        return;\n      }\n\n      pos++;\n    }\n\n    if (!found) {\n      return;\n    } // quick boundary check\n\n\n    if (start > 0) {\n      let leading = content.charAt(start - 1);\n\n      if (!state.md.utils.isSpace(leading.charCodeAt(0)) && !state.md.utils.isPunctChar(leading)) {\n        return;\n      }\n    } // check trailing for punct or space\n\n\n    if (pos < content.length) {\n      let trailing = content.charCodeAt(pos);\n\n      if (!state.md.utils.isSpace(trailing)) {\n        return;\n      }\n    }\n\n    let token = getEmojiTokenByName(found, state);\n\n    if (token) {\n      return {\n        pos,\n        token\n      };\n    }\n  }\n\n  function applyEmoji(content, state, emojiUnicodeReplacer, enableShortcuts, inlineEmoji, customEmojiTranslation) {\n    let result = null;\n    let start = 0;\n\n    if (emojiUnicodeReplacer) {\n      content = emojiUnicodeReplacer(content);\n    }\n\n    let end = content.length;\n\n    for (let i = 0; i < content.length - 1; i++) {\n      let offset = 0;\n      let token = null;\n      const name = getEmojiName(content, i, state, inlineEmoji);\n\n      if (name) {\n        token = getEmojiTokenByName(name, state);\n\n        if (token) {\n          offset = name.length + 2;\n        }\n      }\n\n      if (enableShortcuts && !token) {\n        // handle aliases (note: we can't do this in inline cause ; is not a split point)\n        const info = getEmojiTokenByTranslation(content, i, state, customEmojiTranslation);\n\n        if (info) {\n          offset = info.pos - i;\n          token = info.token;\n        }\n      }\n\n      if (token) {\n        result = result || [];\n\n        if (i - start > 0) {\n          let text = new state.Token(\"text\", \"\", 0);\n          text.content = content.slice(start, i);\n          result.push(text);\n        }\n\n        result.push(token);\n        end = start = i + offset;\n        i += offset - 1;\n      }\n    }\n\n    if (end < content.length) {\n      let text = new state.Token(\"text\", \"\", 0);\n      text.content = content.slice(end);\n      result.push(text);\n    } // we check for a result <= 5 because we support maximum 3 large emojis\n    // EMOJI SPACE EMOJI SPACE EMOJI => 5 tokens\n\n\n    if (result && result.length > 0 && result.length <= 5) {\n      // we ensure line starts and ends with an emoji\n      // and has no more than 3 emojis\n      if (result[0].type === \"emoji\" && result[result.length - 1].type === \"emoji\" && result.filter(r => r.type === \"emoji\").length <= 3) {\n        let onlyEmojiLine = true;\n        let index = 0;\n\n        const checkNextToken = t => {\n          if (!t) {\n            return;\n          }\n\n          if (![\"emoji\", \"text\"].includes(t.type)) {\n            onlyEmojiLine = false;\n          } // a text token should always have an emoji before\n          // and be a space\n\n\n          if (t.type === \"text\" && (result[index - 1] && result[index - 1].type !== \"emoji\" || t.content !== \" \")) {\n            onlyEmojiLine = false;\n          } // exit as soon as possible\n\n\n          if (onlyEmojiLine) {\n            index += 1;\n            checkNextToken(result[index]);\n          }\n        };\n\n        checkNextToken(result[index]);\n\n        if (onlyEmojiLine) {\n          result.forEach(r => {\n            if (r.type === \"emoji\") {\n              applyOnlyEmojiClass(r);\n            }\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function applyOnlyEmojiClass(token) {\n    token.attrs.forEach(attr => {\n      if (attr[0] === \"class\") {\n        attr[1] = `${attr[1]} only-emoji`;\n      }\n    });\n  }\n\n  function setup(helper) {\n    helper.registerOptions((opts, siteSettings, state) => {\n      opts.features.emoji = !state.disableEmojis && !!siteSettings.enable_emoji;\n      opts.features.emojiShortcuts = !!siteSettings.enable_emoji_shortcuts;\n      opts.features.inlineEmoji = !!siteSettings.enable_inline_emoji_translation;\n      opts.emojiSet = siteSettings.emoji_set || \"\";\n      opts.customEmoji = state.customEmoji;\n      opts.emojiCDNUrl = siteSettings.external_emoji_url;\n    });\n    helper.registerPlugin(md => {\n      md.core.ruler.push(\"emoji\", state => md.options.discourse.helpers.textReplace(state, (c, s) => applyEmoji(c, s, md.options.discourse.emojiUnicodeReplacer, md.options.discourse.features.emojiShortcuts, md.options.discourse.features.inlineEmoji, md.options.discourse.customEmojiTranslation)));\n    });\n    helper.allowList([\"img[class=emoji]\", \"img[class=emoji emoji-custom]\", \"img[class=emoji emoji-custom only-emoji]\", \"img[class=emoji only-emoji]\", \"img[loading=lazy]\", \"img[width=20]\", \"img[height=20]\"]);\n  }\n});","define(\"pretty-text/engines/discourse-markdown/helpers\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.default = void 0;\n  _exports.textReplace = textReplace;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  // since the markdown.it interface is a bit on the verbose side\n  // we can keep some general patterns here\n  var _default = null; // creates a rule suitable for inline parsing and replacement\n  //\n  // example:\n  // const rule = inlineRegexRule(md, {\n  //   start: '#',\n  //   matcher: /^#([\\w-:]{1,101})/i,\n  //   emitter: emitter\n  // });\n  // based off https://github.com/markdown-it/markdown-it-emoji/blob/master/dist/markdown-it-emoji.js\n  //\n\n  _exports.default = _default;\n\n  function textReplace(state, callback, skipAllLinks) {\n    let i,\n        j,\n        l,\n        tokens,\n        token,\n        blockTokens = state.tokens,\n        linkLevel = 0;\n\n    for (j = 0, l = blockTokens.length; j < l; j++) {\n      if (blockTokens[j].type !== \"inline\") {\n        continue;\n      }\n\n      tokens = blockTokens[j].children; // We scan from the end, to keep position when new tags added.\n      // Use reversed logic in links start/end match\n\n      for (i = tokens.length - 1; i >= 0; i--) {\n        token = tokens[i];\n\n        if (skipAllLinks) {\n          if (token.type === \"link_open\" || token.type === \"link_close\") {\n            linkLevel -= token.nesting;\n          } else if (token.type === \"html_inline\") {\n            const openLink = token.content.slice(0, 2).toLowerCase();\n\n            if (openLink === \"<a\") {\n              if (token.content.match(/^<a(\\s.*)?>/i)) {\n                linkLevel++;\n              }\n            } else if (token.content.slice(0, 4).toLowerCase() === \"</a>\") {\n              linkLevel--;\n            }\n          }\n        } else {\n          if (token.type === \"link_open\" || token.type === \"link_close\") {\n            if (token.info === \"auto\") {\n              linkLevel -= token.nesting;\n            }\n          }\n        }\n\n        if (token.type === \"text\" && linkLevel === 0) {\n          let split;\n\n          if (split = callback(token.content, state)) {\n            // replace current node\n            blockTokens[j].children = tokens = state.md.utils.arrayReplaceAt(tokens, i, split);\n          }\n        }\n      }\n    }\n  }\n});","define(\"pretty-text/engines/discourse-markdown/html-img\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  // special handling for IMG tags on a line by themselves\n  // we always have to handle it as so it is an inline\n  // see: https://talk.commonmark.org/t/newline-and-img-tags/2511\n  const REGEX = /^<img.*\\\\?>\\s*$/i;\n\n  function rule(state, startLine, endLine) {\n    let nextLine,\n        token,\n        lineText,\n        pos = state.bMarks[startLine] + state.tShift[startLine],\n        max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block\n\n    if (state.sCount[startLine] - state.blkIndent >= 4) {\n      return false;\n    }\n\n    if (!state.md.options.html) {\n      return false;\n    }\n\n    if (state.src.charCodeAt(pos) !== 0x3c\n    /* < */\n    ) {\n      return false;\n    }\n\n    let pos1 = state.src.charCodeAt(pos + 1);\n\n    if (pos1 !== 73\n    /* I */\n    && pos1 !== 105\n    /* i */\n    ) {\n      return false;\n    }\n\n    lineText = state.src.slice(pos, max);\n\n    if (!REGEX.test(lineText)) {\n      return false;\n    }\n\n    let lines = [];\n    lines.push(lineText);\n    nextLine = startLine + 1;\n\n    for (; nextLine < endLine; nextLine++) {\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      lineText = state.src.slice(pos, max);\n\n      if (lineText.trim() === \"\") {\n        break;\n      }\n\n      if (!REGEX.test(lineText)) {\n        break;\n      }\n\n      lines.push(lineText);\n    }\n\n    state.line = nextLine;\n    let oldParentType = state.parentType;\n    state.parentType = \"paragraph\";\n    token = state.push(\"paragraph_open\", \"p\", 1);\n    token.map = [startLine, state.line];\n    token = state.push(\"inline\", \"\", 0);\n    token.content = lines.join(\"\\n\");\n    token.map = [startLine, state.line];\n    token.children = [];\n    state.push(\"paragraph_close\", \"p\", -1);\n    state.parentType = oldParentType;\n    return true;\n  }\n\n  function setup(helper) {\n    helper.registerPlugin(md => {\n      md.block.ruler.before(\"html_block\", \"html_img\", rule, {\n        alt: [\"fence\"]\n      });\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/image-controls\", [\"exports\", \"I18n\"], function (_exports, _I18n) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.priority = void 0;\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71f0,\"I18n\"eaimeta@70e063a35619d71f\n\n  const SCALES = [\"100\", \"75\", \"50\"];\n\n  function isUpload(token) {\n    return token.content.includes(\"upload://\");\n  }\n\n  function hasMetadata(token) {\n    return token.content.match(/(\\d{1,4}x\\d{1,4})/);\n  }\n\n  function appendMetaData(index, token) {\n    const sizePart = token.content.split(\"|\").find(x => x.match(/\\d{1,4}x\\d{1,4}(,\\s*\\d{1,3}%)?/));\n    let selectedScale = sizePart && sizePart.split(\",\").pop().trim().replace(\"%\", \"\");\n    const overwriteScale = !SCALES.find(scale => scale === selectedScale);\n\n    if (overwriteScale) {\n      selectedScale = \"100\";\n    }\n\n    token.attrs.push([\"index-image\", index]);\n    token.attrs.push([\"scale\", selectedScale]);\n  }\n\n  function rule(state) {\n    let currentIndex = 0;\n\n    for (let i = 0; i < state.tokens.length; i++) {\n      let blockToken = state.tokens[i];\n      const blockTokenImage = blockToken.tag === \"img\";\n\n      if (blockTokenImage && isUpload(blockToken) && hasMetadata(blockToken)) {\n        appendMetaData(currentIndex, blockToken);\n        currentIndex++;\n      }\n\n      if (!blockToken.children) {\n        continue;\n      }\n\n      for (let j = 0; j < blockToken.children.length; j++) {\n        let token = blockToken.children[j];\n        const childrenImage = token.tag === \"img\";\n\n        if (childrenImage && isUpload(blockToken) && hasMetadata(token)) {\n          appendMetaData(currentIndex, token);\n          currentIndex++;\n        }\n      }\n    }\n  }\n\n  function buildScaleButton(selectedScale, scale) {\n    const activeScaleClass = selectedScale === scale ? \" active\" : \"\";\n    return \"<span class='scale-btn\" + activeScaleClass + \"' data-scale='\" + scale + \"'>\" + scale + \"%</span>\";\n  }\n\n  function buildImageShowAltTextControls(altText) {\n    return `\n  <span class=\"alt-text-readonly-container\">\n  <span class=\"alt-text-edit-btn\">\n  <svg aria-hidden=\"true\" class=\"fa d-icon d-icon-pencil svg-icon svg-string\"><use href=\"#pencil-alt\"></use></svg>\n</span>\n\n  <span class=\"alt-text\" aria-label=\"${_I18n.default.t(\"composer.image_alt_text.aria_label\")}\">${altText}</span>\n  </span>\n  `;\n  }\n\n  function buildImageEditAltTextControls(altText) {\n    return `\n  <span class=\"alt-text-edit-container\" hidden=\"true\">\n    <input class=\"alt-text-input\" type=\"text\" value=\"${altText}\" />\n    <button class=\"alt-text-edit-ok btn-primary\">\n        <svg class=\"fa d-icon d-icon-check svg-icon svg-string\"><use href=\"#check\"></use></svg>\n    </button>\n    <button class=\"alt-text-edit-cancel btn-default\">\n        <svg class=\"fa d-icon d-icon-times svg-icon svg-string\"><use href=\"#times\"></use></svg>\n    </button>\n  </span>\n  `;\n  }\n\n  function buildImageDeleteButton() {\n    return `\n  <span class=\"delete-image-button\" aria-label=\"${_I18n.default.t(\"composer.delete_image_button\")}\">\n  <svg class=\"fa d-icon d-icon-trash-alt svg-icon svg-string\" xmlns=\"http://www.w3.org/2000/svg\">\n  <use href=\"#far-trash-alt\"></use>\n  </svg>\n   </span>\n  `;\n  } // We need this to load after `upload-protocol` which is priority 0\n\n\n  const priority = 1;\n  _exports.priority = priority;\n\n  function ruleWithImageControls(oldRule) {\n    return function (tokens, idx, options, env, slf) {\n      const token = tokens[idx];\n      const scaleIndex = token.attrIndex(\"scale\");\n      const imageIndex = token.attrIndex(\"index-image\");\n\n      if (scaleIndex !== -1) {\n        let selectedScale = token.attrs[scaleIndex][1];\n        let index = token.attrs[imageIndex][1];\n        let result = `<span class=\"image-wrapper\">`;\n        result += oldRule(tokens, idx, options, env, slf);\n        result += `<span class=\"button-wrapper\" data-image-index=\"${index}\">`;\n        result += buildImageShowAltTextControls(token.attrs[token.attrIndex(\"alt\")][1]);\n        result += buildImageEditAltTextControls(token.attrs[token.attrIndex(\"alt\")][1]);\n        result += `<span class=\"scale-btn-container\">`;\n        result += SCALES.map(scale => buildScaleButton(selectedScale, scale)).join(\"\");\n        result += `</span>`;\n        result += buildImageDeleteButton();\n        result += \"</span></span>\";\n        return result;\n      } else {\n        return oldRule(tokens, idx, options, env, slf);\n      }\n    };\n  }\n\n  function setup(helper) {\n    const opts = helper.getOptions();\n\n    if (opts.previewing) {\n      helper.allowList([\"span.image-wrapper\", \"span.button-wrapper\", \"span[class=scale-btn-container]\", \"span[class=scale-btn]\", \"span[class=scale-btn active]\", \"span.separator\", \"span.scale-btn[data-scale]\", \"span.button-wrapper[data-image-index]\", \"span[aria-label]\", \"span[class=delete-image-button]\", \"span.alt-text-container\", \"span.alt-text-readonly-container\", \"span.alt-text-readonly-container.alt-text\", \"span.alt-text-readonly-container.alt-text-edit-btn\", \"svg[class=fa d-icon d-icon-pencil svg-icon svg-string]\", \"use[href=#pencil-alt]\", \"use[href=#far-trash-alt]\", \"span.alt-text-edit-container\", \"span.delete-image-button\", \"span[hidden=true]\", \"input[type=text]\", \"input[class=alt-text-input]\", \"button[class=alt-text-edit-ok btn-primary]\", \"svg[class=fa d-icon d-icon-check svg-icon svg-string]\", \"use[href=#check]\", \"button[class=alt-text-edit-cancel btn-default]\", \"svg[class=fa d-icon d-icon-times svg-icon svg-string]\", \"svg[class=fa d-icon d-icon-trash-alt svg-icon svg-string]\", \"use[href=#times]\"]);\n      helper.registerPlugin(md => {\n        const oldRule = md.renderer.rules.image;\n        md.renderer.rules.image = ruleWithImageControls(oldRule);\n        md.core.ruler.after(\"upload-protocol\", \"resize-controls\", rule);\n      });\n    }\n  }\n});","define(\"pretty-text/engines/discourse-markdown/mentions\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.mentionRegex = mentionRegex;\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  function addMention(buffer, matches, state) {\n    let username = matches[1] || matches[2];\n    let tag = \"span\";\n    let className = \"mention\";\n    let token = new state.Token(\"mention_open\", tag, 1);\n    token.attrs = [[\"class\", className]];\n    buffer.push(token);\n    token = new state.Token(\"text\", \"\", 0);\n    token.content = \"@\" + username;\n    buffer.push(token);\n    token = new state.Token(\"mention_close\", tag, -1);\n    buffer.push(token);\n  }\n\n  function setup(helper) {\n    helper.registerOptions((opts, siteSettings) => {\n      opts.features.mentions = !!siteSettings.enable_mentions;\n      opts.features.unicodeUsernames = !!siteSettings.unicode_usernames;\n    });\n    helper.registerPlugin(md => {\n      const rule = {\n        matcher: mentionRegex(md.options.discourse.features.unicodeUsernames),\n        onMatch: addMention\n      };\n      md.core.textPostProcess.ruler.push(\"mentions\", rule);\n    });\n  }\n\n  function mentionRegex(unicodeUsernames) {\n    if (unicodeUsernames) {\n      try {\n        // Create the regex from a string, because Babel doesn't understand\n        // Unicode property escapes and completely mangles the regexp.\n        const alnum = \"\\\\p{Alphabetic}\\\\p{Mark}\\\\p{Decimal_Number}\";\n        return new RegExp(`@([${alnum}_][${alnum}._-]{0,58}[${alnum}])|@([${alnum}_])`, \"u\");\n      } catch (e) {\n        if (!(e instanceof SyntaxError)) {\n          throw e;\n        } // Fallback for older browsers and MiniRacer.\n        // Created with regexpu-core@4.5.4 by executing the following in nodejs:\n        //\n        // const rewritePattern = require('regexpu-core')\n        // new RegExp(rewritePattern(/[\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}]/u.source, 'u', { 'unicodePropertyEscape': true }))\n\n\n        const alnum = /(?:[0-9A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06E1-\\u06E8\\u06DF-\\u06E4\\u06ED-\\u06F9\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D3-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABE\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u24B6-\\u24E9\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA672\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC82-\\uDCBA\\uDC7F-\\uDC82\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD46\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E\\uDC5F\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83C[\\uDD30-\\uDD49\\uDD50-\\uDD69\\uDD70-\\uDD89]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF])/.source;\n        return new RegExp(`@((?:_|${alnum})(?:[._-]|${alnum}){0,58}${alnum})|@(?:(_|${alnum}))`);\n      }\n    } else {\n      return /@(\\w[\\w.-]{0,58}[^\\W_])|@(\\w)/;\n    }\n  }\n});","define(\"pretty-text/engines/discourse-markdown/newline\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  // see: https://github.com/markdown-it/markdown-it/issues/375\n  //\n  // we use a custom paragraph rule cause we have to signal when a\n  // link starts with a space, so we can bypass a onebox\n  // this is a freedom patch, so careful, may break on updates\n  function newline(state, silent) {\n    let token,\n        pmax,\n        max,\n        ws,\n        pos = state.pos;\n\n    if (state.src.charCodeAt(pos) !== 0x0a\n    /* \\n */\n    ) {\n      return false;\n    }\n\n    pmax = state.pending.length - 1;\n    max = state.posMax; // '  \\n' -> hardbreak\n    // Lookup in pending chars is bad practice! Don't copy to other rules!\n    // Pending string is stored in concat mode, indexed lookups will cause\n    // conversion to flat mode.\n\n    if (!silent) {\n      if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n        if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n          // Find whitespaces tail of pending chars.\n          ws = pmax - 1;\n\n          while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 0x20) {\n            ws--;\n          }\n\n          state.pending = state.pending.slice(0, ws);\n          token = state.push(\"hardbreak\", \"br\", 0);\n        } else {\n          state.pending = state.pending.slice(0, -1);\n          token = state.push(\"softbreak\", \"br\", 0);\n        }\n      } else {\n        token = state.push(\"softbreak\", \"br\", 0);\n      }\n    }\n\n    pos++; // skip heading spaces for next line\n\n    while (pos < max && state.md.utils.isSpace(state.src.charCodeAt(pos))) {\n      if (token) {\n        token.leading_space = true;\n      }\n\n      pos++;\n    }\n\n    state.pos = pos;\n    return true;\n  }\n\n  function setup(helper) {\n    helper.registerPlugin(md => {\n      md.inline.ruler.at(\"newline\", newline);\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/onebox\", [\"exports\", \"pretty-text/inline-oneboxer\", \"pretty-text/oneboxer-cache\"], function (_exports, _inlineOneboxer, _oneboxerCache) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71f0,\"pretty-text/inline-oneboxer\",0,\"pretty-text/oneboxer-cache\"eaimeta@70e063a35619d71f\n\n  const ONEBOX = 1;\n  const INLINE = 2;\n\n  function isTopLevel(href) {\n    let split = href.split(/https?:\\/\\/[^\\/]+[\\/?]/i);\n    let hasExtra = split && split[1] && split[1].length > 0;\n    return !hasExtra;\n  }\n\n  function applyOnebox(state, silent) {\n    if (silent || !state.tokens) {\n      return;\n    }\n\n    for (let i = 1; i < state.tokens.length; i++) {\n      let token = state.tokens[i];\n      let prev = state.tokens[i - 1];\n      let mode = prev.type === \"paragraph_open\" && prev.level === 0 ? ONEBOX : INLINE;\n\n      if (token.type === \"inline\") {\n        let children = token.children;\n\n        for (let j = 0; j < children.length - 2; j++) {\n          let child = children[j];\n\n          if (child.type === \"link_open\" && child.markup === \"linkify\" && child.info === \"auto\") {\n            if (j > children.length - 3) {\n              continue;\n            }\n\n            if (j === 0 && token.leading_space) {\n              mode = INLINE;\n            } else if (j > 0) {\n              let prevSibling = children[j - 1];\n\n              if (prevSibling.tag !== \"br\" || prevSibling.leading_space) {\n                mode = INLINE;\n              }\n            } // look ahead for soft or hard break\n\n\n            let text = children[j + 1];\n            let close = children[j + 2];\n            let lookahead = children[j + 3];\n\n            if (lookahead && lookahead.tag !== \"br\") {\n              mode = INLINE;\n            } // check attrs only include a href\n\n\n            let attrs = child.attrs;\n\n            if (!attrs || attrs.length !== 1 || attrs[0][0] !== \"href\") {\n              continue;\n            }\n\n            let href = attrs[0][1]; // edge case ... what if this is not http or protocolless?\n\n            if (!/^http|^\\/\\//i.test(href)) {\n              continue;\n            } // we already know text matches cause it is an auto link\n\n\n            if (!close || close.type !== \"link_close\") {\n              continue;\n            }\n\n            if (mode === ONEBOX) {\n              // we already determined earlier that 0 0 was href\n              let cached = (0, _oneboxerCache.lookupCache)(attrs[0][1]);\n\n              if (cached) {\n                // replace link with 2 blank text nodes and inline html for onebox\n                child.type = \"html_raw\";\n                child.content = cached;\n                child.inline = true;\n                child.onebox = true;\n                text.type = \"html_raw\";\n                text.content = \"\";\n                text.inline = true;\n                close.type = \"html_raw\";\n                close.content = \"\";\n                close.inline = true;\n              } else {\n                // decorate...\n                attrs.push([\"class\", \"onebox\"]);\n                attrs.push([\"target\", \"_blank\"]);\n              }\n            } else if (mode === INLINE && !isTopLevel(href)) {\n              const onebox = (0, _inlineOneboxer.cachedInlineOnebox)(href);\n\n              if (onebox && onebox.title) {\n                text.content = onebox.title;\n                attrs.push([\"class\", \"inline-onebox\"]);\n              } else if (!onebox) {\n                attrs.push([\"class\", \"inline-onebox-loading\"]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function setup(helper) {\n    helper.registerPlugin(md => {\n      md.core.ruler.after(\"linkify\", \"onebox\", applyOnebox);\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/paragraph\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  // see: https://github.com/markdown-it/markdown-it/issues/375\n  //\n  // we use a custom paragraph rule cause we have to signal when a\n  // link starts with a space, so we can bypass a onebox\n  // this is a freedom patch, so careful, may break on updates\n  function paragraph(state, startLine\n  /*, endLine*/\n  ) {\n    let content,\n        terminate,\n        i,\n        l,\n        token,\n        oldParentType,\n        nextLine = startLine + 1,\n        terminatorRules = state.md.block.ruler.getRules(\"paragraph\"),\n        endLine = state.lineMax,\n        hasLeadingSpace = false;\n    oldParentType = state.parentType;\n    state.parentType = \"paragraph\"; // jump line-by-line until empty one or EOF\n\n    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.sCount[nextLine] - state.blkIndent > 3) {\n        continue;\n      } // quirk for blockquotes, this line should already be checked by that rule\n\n\n      if (state.sCount[nextLine] < 0) {\n        continue;\n      } // Some tags can terminate paragraph without empty line.\n\n\n      terminate = false;\n\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n\n      if (terminate) {\n        break;\n      }\n    } // START CUSTOM CODE\n\n\n    content = state.getLines(startLine, nextLine, state.blkIndent, false);\n    i = 0;\n    let contentLength = content.length;\n\n    while (i < contentLength) {\n      let chr = content.charCodeAt(i);\n\n      if (chr === 0x0a) {\n        hasLeadingSpace = false;\n      } else if (state.md.utils.isWhiteSpace(chr)) {\n        hasLeadingSpace = true;\n      } else {\n        break;\n      }\n\n      i++;\n    }\n\n    content = content.trim(); // END CUSTOM CODE\n\n    state.line = nextLine;\n    token = state.push(\"paragraph_open\", \"p\", 1);\n    token.map = [startLine, state.line]; // CUSTOM\n\n    token.leading_space = hasLeadingSpace;\n    token = state.push(\"inline\", \"\", 0);\n    token.content = content;\n    token.map = [startLine, state.line];\n    token.children = []; // CUSTOM\n\n    token.leading_space = hasLeadingSpace;\n    state.push(\"paragraph_close\", \"p\", -1);\n    state.parentType = oldParentType;\n    return true;\n  }\n\n  function setup(helper) {\n    helper.registerPlugin(md => {\n      md.block.ruler.at(\"paragraph\", paragraph);\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/quotes\", [\"exports\", \"pretty-text/emoji\"], function (_exports, _emoji) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71f0,\"pretty-text/emoji\"eaimeta@70e063a35619d71f\n\n  const rule = {\n    tag: \"quote\",\n\n    before(state, tagInfo) {\n      const attrs = tagInfo.attrs;\n      let options = state.md.options.discourse;\n      let quoteInfo = attrs[\"_default\"];\n      let username, postNumber, topicId, avatarImg, primaryGroupName, full, displayName;\n\n      if (quoteInfo) {\n        let split = quoteInfo.split(/\\,\\s*/);\n        username = split[0];\n        let i;\n\n        for (i = 1; i < split.length; i++) {\n          if (split[i].startsWith(\"post:\")) {\n            postNumber = parseInt(split[i].slice(5), 10);\n            continue;\n          }\n\n          if (split[i].startsWith(\"topic:\")) {\n            topicId = parseInt(split[i].slice(6), 10);\n            continue;\n          }\n\n          if (/full:\\s*true/.test(split[i])) {\n            full = true;\n            continue;\n          } // if we have the additional attribute of username: because we are prioritizing full name\n          // then assign the name to be the displayName\n\n\n          if (split[i].startsWith(\"username:\")) {\n            // return users name by selecting all values from the first index to the post\n            // this protects us from when a user has a `,` in their name\n            displayName = split.slice(0, split.indexOf(`post:${postNumber}`)); // preserve `,` in a users name if they exist\n\n            if (displayName.length > 1) {\n              displayName = displayName.join(\", \");\n            } // strip key of 'username:' and return username\n\n\n            username = split[i].slice(9);\n            continue;\n          }\n        }\n      }\n\n      if (options.lookupAvatarByPostNumber) {\n        // client-side, we can retrieve the avatar from the post\n        avatarImg = options.lookupAvatarByPostNumber(postNumber, topicId);\n      } else if (options.lookupAvatar) {\n        // server-side, we need to lookup the avatar from the username\n        avatarImg = options.lookupAvatar(username);\n      }\n\n      if (options.lookupPrimaryUserGroupByPostNumber) {\n        // client-side, we can retrieve the primary user group from the post\n        primaryGroupName = options.lookupPrimaryUserGroupByPostNumber(postNumber, topicId);\n      } else if (options.lookupPrimaryUserGroup) {\n        // server-side, we need to lookup the primary user group from the username\n        primaryGroupName = options.lookupPrimaryUserGroup(username);\n      }\n\n      if (options.formatUsername) {\n        displayName = displayName || options.formatUsername(username);\n      } else {\n        displayName = displayName || username;\n      }\n\n      let token = state.push(\"bbcode_open\", \"aside\", 1);\n      token.attrs = [];\n\n      if (primaryGroupName && primaryGroupName.length !== 0) {\n        token.attrs.push([\"class\", `quote group-${primaryGroupName}`]);\n      } else {\n        token.attrs.push([\"class\", \"quote no-group\"]);\n      }\n\n      if (username) {\n        token.attrs.push([\"data-username\", username]);\n      }\n\n      if (postNumber) {\n        token.attrs.push([\"data-post\", postNumber]);\n      }\n\n      if (topicId) {\n        token.attrs.push([\"data-topic\", topicId]);\n      }\n\n      if (full) {\n        token.attrs.push([\"data-full\", \"true\"]);\n      }\n\n      if (username) {\n        let forOtherTopic = options.topicId && topicId !== options.topicId;\n        let offTopicQuote = postNumber && options.getTopicInfo && (forOtherTopic || options.forceQuoteLink); // on topic quote\n\n        token = state.push(\"quote_header_open\", \"div\", 1);\n        token.attrs = [[\"class\", \"title\"]];\n        token = state.push(\"quote_controls_open\", \"div\", 1);\n        token.attrs = [[\"class\", \"quote-controls\"]];\n        state.push(\"quote_controls_close\", \"div\", -1);\n\n        if (avatarImg) {\n          token = state.push(\"html_inline\", \"\", 0);\n          token.content = avatarImg;\n        }\n\n        if (offTopicQuote) {\n          const topicInfo = options.getTopicInfo(topicId);\n\n          if (topicInfo) {\n            let href = topicInfo.href;\n\n            if (postNumber > 0) {\n              href += \"/\" + postNumber;\n            }\n\n            let title = topicInfo.title;\n\n            if (options.enableEmoji) {\n              title = (0, _emoji.performEmojiUnescape)(topicInfo.title, {\n                getURL: options.getURL,\n                emojiSet: options.emojiSet,\n                emojiCDNUrl: options.emojiCDNUrl,\n                enableEmojiShortcuts: options.enableEmojiShortcuts,\n                inlineEmoji: options.inlineEmoji,\n                lazy: true\n              });\n            }\n\n            token = state.push(\"link_open\", \"a\", 1);\n            token.attrs = [[\"href\", href]];\n            token.block = false;\n            token = state.push(\"html_inline\", \"\", 0);\n            token.content = title;\n            token = state.push(\"link_close\", \"a\", -1);\n            token.block = false;\n          }\n        } else {\n          token = state.push(\"text\", \"\", 0);\n          token.content = ` ${displayName}:`;\n        }\n\n        state.push(\"quote_header_close\", \"div\", -1);\n      }\n\n      state.push(\"bbcode_open\", \"blockquote\", 1);\n    },\n\n    after(state) {\n      state.push(\"bbcode_close\", \"blockquote\", -1);\n      state.push(\"bbcode_close\", \"aside\", -1);\n    }\n\n  };\n\n  function setup(helper) {\n    helper.registerOptions((opts, siteSettings) => {\n      opts.enableEmoji = siteSettings.enable_emoji;\n      opts.emojiSet = siteSettings.emoji_set;\n      opts.emojiCDNUrl = siteSettings.external_emoji_url;\n      opts.enableEmojiShortcuts = siteSettings.enable_emoji_shortcuts;\n      opts.inlineEmoji = siteSettings.enable_inline_emoji_translation;\n    });\n    helper.registerPlugin(md => {\n      md.block.bbcode.ruler.push(\"quotes\", rule);\n    });\n    helper.allowList([\"img[class=avatar]\", \"img[loading=lazy]\"]);\n    helper.allowList({\n      custom(tag, name, value) {\n        if (tag === \"aside\" && name === \"class\") {\n          return value === \"quote no-group\" || !!/^quote group\\-(.+)$/.exec(value);\n        }\n      }\n\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/table\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  function setup(helper) {\n    helper.registerPlugin(md => {\n      md.renderer.rules.table_open = function () {\n        return '<div class=\"md-table\">\\n<table>\\n';\n      };\n\n      md.renderer.rules.table_close = function () {\n        return \"</table>\\n</div>\";\n      };\n    }); // we need a custom callback for style handling\n\n    helper.allowList({\n      custom(tag, attr, val) {\n        if (tag !== \"th\" && tag !== \"td\") {\n          return false;\n        }\n\n        if (attr !== \"style\") {\n          return false;\n        }\n\n        return val === \"text-align:right\" || val === \"text-align:left\" || val === \"text-align:center\";\n      }\n\n    });\n    helper.allowList([\"table\", \"tbody\", \"thead\", \"tr\", \"th\", \"td\", \"div.md-table\"]);\n  }\n});","define(\"pretty-text/engines/discourse-markdown/text-post-process\", [\"exports\"], function (_exports) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.TextPostProcessRuler = void 0;\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71feaimeta@70e063a35619d71f\n\n  class TextPostProcessRuler {\n    constructor() {\n      this.rules = [];\n    }\n\n    getRules() {\n      return this.rules;\n    } // TODO error handling\n\n\n    getMatcher() {\n      if (this.matcher) {\n        return this.matcher;\n      }\n\n      this.matcherIndex = [];\n      const rules = [];\n      const flags = new Set(\"g\");\n      this.rules.forEach(r => {\n        const matcher = r.rule.matcher;\n        rules.push(`(${matcher.source})`);\n        matcher.flags.split(\"\").forEach(f => flags.add(f));\n      });\n      let i;\n      let regexString = \"\";\n      let last = 1; // this code is a bit tricky, our matcher may have multiple capture groups\n      // we want to dynamically determine how many\n\n      for (i = 0; i < rules.length; i++) {\n        this.matcherIndex[i] = last;\n\n        if (i === rules.length - 1) {\n          break;\n        }\n\n        if (i > 0) {\n          regexString = regexString + \"|\";\n        }\n\n        regexString = regexString + rules[i];\n        let regex = new RegExp(regexString + \"|(x)\");\n        last = \"x\".match(regex).length - 1;\n      }\n\n      this.matcher = new RegExp(rules.join(\"|\"), [...flags].join(\"\"));\n      return this.matcher;\n    }\n\n    applyRule(buffer, match, state) {\n      let i;\n\n      for (i = 0; i < this.rules.length; i++) {\n        let index = this.matcherIndex[i];\n\n        if (match[index]) {\n          this.rules[i].rule.onMatch(buffer, match.slice(index, this.matcherIndex[i + 1]), state);\n          break;\n        }\n      }\n    } // TODO validate inputs\n\n\n    push(name, rule) {\n      this.rules.push({\n        name,\n        rule\n      });\n      this.matcher = null;\n    }\n\n  }\n\n  _exports.TextPostProcessRuler = TextPostProcessRuler;\n\n  function allowedBoundary(content, index, utils) {\n    let code = content.charCodeAt(index);\n    return utils.isWhiteSpace(code) || utils.isPunctChar(String.fromCharCode(code));\n  }\n\n  function textPostProcess(content, state, ruler) {\n    let result = null;\n    let match;\n    let pos = 0;\n    const matcher = ruler.getMatcher();\n\n    while (match = matcher.exec(content)) {\n      // something is wrong\n      if (match.index < pos) {\n        break;\n      } // check boundary\n\n\n      if (match.index > 0) {\n        if (!allowedBoundary(content, match.index - 1, state.md.utils)) {\n          continue;\n        }\n      } // check forward boundary as well\n\n\n      if (match.index + match[0].length < content.length) {\n        if (!allowedBoundary(content, match.index + match[0].length, state.md.utils)) {\n          continue;\n        }\n      }\n\n      result = result || [];\n\n      if (match.index > pos) {\n        let token = new state.Token(\"text\", \"\", 0);\n        token.content = content.slice(pos, match.index);\n        result.push(token);\n      }\n\n      ruler.applyRule(result, match, state);\n      pos = match.index + match[0].length;\n    }\n\n    if (result && pos < content.length) {\n      let token = new state.Token(\"text\", \"\", 0);\n      token.content = content.slice(pos);\n      result.push(token);\n    }\n\n    return result;\n  }\n\n  function setup(helper) {\n    helper.registerPlugin(md => {\n      const ruler = md.core.textPostProcess.ruler;\n\n      const replacer = (content, state) => textPostProcess(content, state, ruler);\n\n      md.core.ruler.push(\"text-post-process\", state => md.options.discourse.helpers.textReplace(state, replacer, true));\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/upload-protocol\", [\"exports\", \"xss\"], function (_exports, _xss) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71f0,\"xss\"eaimeta@70e063a35619d71f\n\n  const HTML_TYPES = [\"html_block\", \"html_inline\"]; // add image to array if src has an upload\n\n  function addImage(uploads, token) {\n    if (token.attrs) {\n      for (let i = 0; i < token.attrs.length; i++) {\n        const value = token.attrs[i][1];\n\n        if (value?.startsWith(\"upload://\")) {\n          uploads.push({\n            token,\n            srcIndex: i,\n            origSrc: value\n          });\n          break;\n        }\n      }\n    }\n  }\n\n  function attr(name, value) {\n    if (value) {\n      return `${name}=\"${_xss.default.escapeAttrValue(value)}\"`;\n    }\n\n    return name;\n  }\n\n  function uploadLocatorString(url) {\n    return `___REPLACE_UPLOAD_SRC_${url}___`;\n  }\n\n  function findUploadsInHtml(uploads, blockToken) {\n    // Slightly misusing our HTML sanitizer to look for upload://\n    // image src attributes, and replace them with a placeholder.\n    // Note that we can't use browser DOM APIs because this needs\n    // to run in mini-racer.\n    let foundImage = false;\n    let allowList;\n    const filter = new _xss.default.FilterXSS({\n      allowList: [],\n      allowCommentTag: true,\n\n      onTag(tag, html, info) {\n        // We're not using this for sanitizing, so allow all tags through\n        info.isWhite = true;\n        allowList[tag] = [];\n      },\n\n      onTagAttr(tag, name, value) {\n        if (tag === \"img\" && name === \"src\" && value.startsWith(\"upload://\")) {\n          uploads.push({\n            token: blockToken,\n            srcIndex: null,\n            origSrc: value\n          });\n          foundImage = true;\n          return uploadLocatorString(value);\n        }\n\n        return attr(name, value);\n      }\n\n    });\n    allowList = filter.options.whiteList;\n    const newContent = filter.process(blockToken.content);\n\n    if (foundImage) {\n      blockToken.content = newContent;\n    }\n  }\n\n  function processToken(uploads, token) {\n    if (token.tag === \"img\" || token.tag === \"a\") {\n      addImage(uploads, token);\n    } else if (HTML_TYPES.includes(token.type)) {\n      findUploadsInHtml(uploads, token);\n    }\n\n    if (token.children) {\n      for (let j = 0; j < token.children.length; j++) {\n        const childToken = token.children[j];\n        processToken(uploads, childToken);\n      }\n    }\n  }\n\n  function rule(state) {\n    let uploads = [];\n\n    for (let i = 0; i < state.tokens.length; i++) {\n      let blockToken = state.tokens[i];\n      processToken(uploads, blockToken);\n    }\n\n    if (uploads.length > 0) {\n      let srcList = uploads.map(u => u.origSrc); // In client-side cooking, this lookup returns nothing\n      // This means we set data-orig-src, and let decorateCooked\n      // lookup the image URLs asynchronously\n\n      let lookup = state.md.options.discourse.lookupUploadUrls;\n      let longUrls = lookup && lookup(srcList) || {};\n      uploads.forEach(_ref => {\n        let {\n          token,\n          srcIndex,\n          origSrc\n        } = _ref;\n        let mapped = longUrls[origSrc];\n\n        if (HTML_TYPES.includes(token.type)) {\n          const locator = uploadLocatorString(origSrc);\n          let attrs = [];\n\n          if (mapped) {\n            attrs.push(attr(\"src\", mapped.url), attr(\"data-base62-sha1\", mapped.base62_sha1));\n          } else {\n            attrs.push(attr(\"src\", state.md.options.discourse.getURL(\"/images/transparent.png\")), attr(\"data-orig-src\", origSrc));\n          }\n\n          token.content = token.content.replace(locator, attrs.join(\" \"));\n        } else if (token.tag === \"img\") {\n          if (mapped) {\n            token.attrs[srcIndex][1] = mapped.url;\n            token.attrs.push([\"data-base62-sha1\", mapped.base62_sha1]);\n          } else {\n            // no point putting a transparent .png for audio/video\n            if (token.content.match(/\\|video|\\|audio/)) {\n              token.attrs[srcIndex][1] = state.md.options.discourse.getURL(\"/404\");\n            } else {\n              token.attrs[srcIndex][1] = state.md.options.discourse.getURL(\"/images/transparent.png\");\n            }\n\n            token.attrs.push([\"data-orig-src\", origSrc]);\n          }\n        } else if (token.tag === \"a\") {\n          if (mapped) {\n            // when secure media is enabled we want the full /secure-media-uploads/\n            // url to take advantage of access control security\n            if (state.md.options.discourse.limitedSiteSettings.secureMedia && mapped.url.includes(\"secure-media-uploads\")) {\n              token.attrs[srcIndex][1] = mapped.url;\n            } else {\n              token.attrs[srcIndex][1] = mapped.short_path;\n            }\n          } else {\n            token.attrs[srcIndex][1] = state.md.options.discourse.getURL(\"/404\");\n            token.attrs.push([\"data-orig-href\", origSrc]);\n          }\n        }\n      });\n    }\n  }\n\n  function setup(helper) {\n    const opts = helper.getOptions();\n\n    if (opts.previewing) {\n      helper.allowList([\"img.resizable\"]);\n    }\n\n    helper.allowList([\"img[data-orig-src]\", \"img[data-base62-sha1]\", \"a[data-orig-href]\"]);\n    helper.registerPlugin(md => {\n      md.core.ruler.push(\"upload-protocol\", rule);\n    });\n  }\n});","define(\"pretty-text/engines/discourse-markdown/watched-words\", [\"exports\", \"discourse-common/utils/watched-words\"], function (_exports, _watchedWords) {\n  \"use strict\";\n\n  Object.defineProperty(_exports, \"__esModule\", {\n    value: true\n  });\n  _exports.priority = void 0;\n  _exports.setup = setup;\n  0; //eaimeta@70e063a35619d71f0,\"discourse-common/utils/watched-words\"eaimeta@70e063a35619d71f\n\n  const MAX_MATCHES = 100;\n\n  function isLinkOpen(str) {\n    return /^<a[>\\s]/i.test(str);\n  }\n\n  function isLinkClose(str) {\n    return /^<\\/a\\s*>/i.test(str);\n  }\n\n  function findAllMatches(text, matchers) {\n    const matches = [];\n    let count = 0;\n    matchers.forEach(matcher => {\n      let match;\n\n      while ((match = matcher.pattern.exec(text)) !== null && count++ < MAX_MATCHES) {\n        matches.push({\n          index: match.index + match[0].indexOf(match[1]),\n          text: match[1],\n          replacement: matcher.replacement,\n          link: matcher.link\n        });\n      }\n    });\n    return matches.sort((a, b) => a.index - b.index);\n  } // We need this to load after mentions and hashtags which are priority 0\n\n\n  const priority = 1;\n  _exports.priority = priority;\n  const NONE = 0;\n  const MENTION = 1;\n  const HASHTAG_LINK = 2;\n  const HASHTAG_SPAN = 3;\n\n  function setup(helper) {\n    const opts = helper.getOptions();\n    helper.registerPlugin(md => {\n      const matchers = [];\n\n      if (md.options.discourse.watchedWordsReplace) {\n        Object.entries(md.options.discourse.watchedWordsReplace).map(_ref => {\n          let [regexpString, options] = _ref;\n          const word = (0, _watchedWords.toWatchedWord)({\n            [regexpString]: options\n          });\n          matchers.push({\n            pattern: (0, _watchedWords.createWatchedWordRegExp)(word),\n            replacement: options.replacement,\n            link: false\n          });\n        });\n      }\n\n      if (md.options.discourse.watchedWordsLink) {\n        Object.entries(md.options.discourse.watchedWordsLink).map(_ref2 => {\n          let [regexpString, options] = _ref2;\n          const word = (0, _watchedWords.toWatchedWord)({\n            [regexpString]: options\n          });\n          matchers.push({\n            pattern: (0, _watchedWords.createWatchedWordRegExp)(word),\n            replacement: options.replacement,\n            link: true\n          });\n        });\n      }\n\n      if (matchers.length === 0) {\n        return;\n      }\n\n      const cache = new Map();\n      md.core.ruler.push(\"watched-words\", state => {\n        for (let j = 0, l = state.tokens.length; j < l; j++) {\n          if (state.tokens[j].type !== \"inline\") {\n            continue;\n          }\n\n          let tokens = state.tokens[j].children;\n          let htmlLinkLevel = 0; // We scan once to mark tokens that must be skipped because they are\n          // mentions or hashtags\n\n          let lastType = NONE;\n\n          for (let i = 0; i < tokens.length; ++i) {\n            const currentToken = tokens[i];\n\n            if (currentToken.type === \"mention_open\") {\n              lastType = MENTION;\n            } else if ((currentToken.type === \"link_open\" || currentToken.type === \"span_open\") && currentToken.attrs && currentToken.attrs.some(attr => attr[0] === \"class\" && attr[1] === \"hashtag\")) {\n              lastType = currentToken.type === \"link_open\" ? HASHTAG_LINK : HASHTAG_SPAN;\n            }\n\n            if (lastType !== NONE) {\n              currentToken.skipReplace = true;\n            }\n\n            if (lastType === MENTION && currentToken.type === \"mention_close\" || lastType === HASHTAG_LINK && currentToken.type === \"link_close\" || lastType === HASHTAG_SPAN && currentToken.type === \"span_close\") {\n              lastType = NONE;\n            }\n          } // We scan from the end, to keep position when new tags added.\n          // Use reversed logic in links start/end match\n\n\n          for (let i = tokens.length - 1; i >= 0; i--) {\n            const currentToken = tokens[i]; // Skip content of markdown links\n\n            if (currentToken.type === \"link_close\") {\n              i--;\n\n              while (tokens[i].level !== currentToken.level && tokens[i].type !== \"link_open\") {\n                i--;\n              }\n\n              continue;\n            } // Skip content of html tag links\n\n\n            if (currentToken.type === \"html_inline\") {\n              if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n                htmlLinkLevel--;\n              }\n\n              if (isLinkClose(currentToken.content)) {\n                htmlLinkLevel++;\n              }\n            } // Skip content of mentions or hashtags\n\n\n            if (currentToken.skipReplace) {\n              continue;\n            }\n\n            if (currentToken.type === \"text\") {\n              const text = currentToken.content;\n              let matches;\n\n              if (cache.has(text)) {\n                matches = cache.get(text);\n              } else {\n                matches = findAllMatches(text, matchers);\n                cache.set(text, matches);\n              } // Now split string to nodes\n\n\n              const nodes = [];\n              let level = currentToken.level;\n              let lastPos = 0;\n              let token;\n\n              for (let ln = 0; ln < matches.length; ln++) {\n                if (matches[ln].index < lastPos) {\n                  continue;\n                }\n\n                if (matches[ln].index > lastPos) {\n                  token = new state.Token(\"text\", \"\", 0);\n                  token.content = text.slice(lastPos, matches[ln].index);\n                  token.level = level;\n                  nodes.push(token);\n                }\n\n                if (matches[ln].link) {\n                  const url = state.md.normalizeLink(matches[ln].replacement);\n\n                  if (htmlLinkLevel === 0 && state.md.validateLink(url)) {\n                    token = new state.Token(\"link_open\", \"a\", 1);\n                    token.attrs = [[\"href\", url]];\n\n                    if (opts.discourse.previewing) {\n                      token.attrs.push([\"data-word\", \"\"]);\n                    }\n\n                    token.level = level++;\n                    token.markup = \"linkify\";\n                    token.info = \"auto\";\n                    nodes.push(token);\n                    token = new state.Token(\"text\", \"\", 0);\n                    token.content = matches[ln].text;\n                    token.level = level;\n                    nodes.push(token);\n                    token = new state.Token(\"link_close\", \"a\", -1);\n                    token.level = --level;\n                    token.markup = \"linkify\";\n                    token.info = \"auto\";\n                    nodes.push(token);\n                  }\n                } else {\n                  token = new state.Token(\"text\", \"\", 0);\n                  token.content = matches[ln].replacement;\n                  token.level = level;\n                  nodes.push(token);\n                }\n\n                lastPos = matches[ln].index + matches[ln].text.length;\n              }\n\n              if (lastPos < text.length) {\n                token = new state.Token(\"text\", \"\", 0);\n                token.content = text.slice(lastPos);\n                token.level = level;\n                nodes.push(token);\n              } // replace current node\n\n\n              state.tokens[j].children = tokens = md.utils.arrayReplaceAt(tokens, i, nodes);\n            }\n          }\n        }\n      });\n    });\n  }\n});"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3xQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;","file":"markdown-it-bundle.js"}